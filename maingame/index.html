
<!--
================================================================================
  特雷森规则怪谈 - 训练员生存指南
  
  作者: Eternal zz
  创意支持，技术支持
  Discord ID: eternalzz0840
  
  版权声明:
  - 禁止商用
  - 禁止二创
  - 只能在类脑、旅程二传
  
  未经作者许可，不得用于任何商业用途或进行二次创作
================================================================================
-->
<!doctype html>

<html lang="zh-CN">

  <head>

    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>特雷森学院怪谈</title>

    <meta name="description" content="特雷森学院怪谈 - 恐怖视觉小说界面" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <link

      href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;600;700&family=Noto+Serif+SC:wght@400;500;600&display=swap"

      rel="stylesheet"

    />

    <link rel="stylesheet" href="/app.css" />



    <script>

      var e = Object.defineProperty,

        t = (t, n, s) => (

          ((t, n, s) => {

            n in t ? e(t, n, { enumerable: !0, configurable: !0, writable: !0, value: s }) : (t[n] = s);

          })(t, 'symbol' != typeof n ? n + '' : n, s),

          s

        );

      !(function () {

        const e = document.createElement('link').relList;

        if (!(e && e.supports && e.supports('modulepreload'))) {

          for (const e of document.querySelectorAll('link[rel="modulepreload"]')) t(e);

          new MutationObserver(e => {

            for (const n of e)

              if ('childList' === n.type)

                for (const e of n.addedNodes) 'LINK' === e.tagName && 'modulepreload' === e.rel && t(e);

          }).observe(document, { childList: !0, subtree: !0 });

        }

        function t(e) {

          if (e.ep) return;

          e.ep = !0;

          const t = (function (e) {

            const t = {};

            return (

              e.integrity && (t.integrity = e.integrity),

              e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy),

              'use-credentials' === e.crossOrigin

                ? (t.credentials = 'include')

                : 'anonymous' === e.crossOrigin

                  ? (t.credentials = 'omit')

                  : (t.credentials = 'same-origin'),

              t

            );

          })(e);

          fetch(e.href, t);

        }

      })();

      const n = new (class {

        constructor() {

          // 检查全局函数是否可用
          if (typeof window.eventEmit === 'undefined' || typeof window.eventOn === 'undefined') {
            console.warn('⚠️ MVU全局函数未找到，可能影响MVU功能');
            console.log('可用的全局函数:', Object.keys(window).filter(key => typeof window[key] === 'function'));
          }

          // 初始化马娘记名册已添加集合，避免重复计算
          this.umaRosterAdded = new Set();
          
          // 初始化状态动画标志，防止重复触发
          this.statusAnimationActive = false;

          (t(this, 'updateInterval', null),

            t(this, 'isInitialized', !1),

            console.log('🎮 特雷森学院怪谈MVU界面管理器已创建'));

        }

        async init() {

          if (!this.isInitialized) {

            if ((console.group('🚀 特雷森学院怪谈MVU界面初始化'), void 0 === window.TavernHelper))

              return (console.error('❌ TavernHelper环境未找到'), void console.groupEnd());

            (console.log('✅ TavernHelper环境已找到'),

              console.log('🔧 设置事件监听器...'),

              this.setupEventListeners(),

              console.log('🔧 设置控制台命令...'),

              this.setupConsoleCommands(),

              console.log('🔄 设置流式更新监听...'),

              this.setupStreamListeners(),

              console.log('🔄 更新界面...'),

              await this.updateInterface(),

              console.log('⏰ 启动回复时间定时器...'),

              this.startReplyTimer(),

              (this.updateInterval = setInterval(async () => {

                await this.updateInterface();

              }, 2e3)),

              (this.isInitialized = !0),

              console.log('✅ MVU界面初始化完成'),

              console.groupEnd());

          }

        }

        // 新增：MVU环境诊断和修复函数
        debugMVUEnvironment() {
            console.group('🔍 MVU环境诊断');
            
            // 检查基本函数
            console.log('window.eventEmit:', typeof window.eventEmit);
            console.log('window.eventOn:', typeof window.eventOn);
            console.log('getAllVariables:', typeof this.getAllVariables);
            
            // 检查MVU对象
            console.log('window.Mvu:', window.Mvu);
            console.log('window.mag_invoke_mvu:', typeof window.mag_invoke_mvu);
            
            // 检查TavernHelper环境
            console.log('window.TavernHelper:', window.TavernHelper);
            
            // 检查当前变量状态
            try {
                const currentVars = this.getAllVariables();
                console.log('当前变量状态:', currentVars);
            } catch (e) {
                console.error('获取变量失败:', e);
            }
            
            console.groupEnd();
        }

        // 新增：设置MVU事件监听器
        setupMVUListeners() {
            console.log('🔧 设置MVU事件监听器...');
            
            // 监听MVU变量更新事件
            if (typeof window.eventOn === 'function') {
                window.eventOn('mag_variable_updated', (statData, path, oldValue, newValue) => {
                    console.log('✅ MVU变量更新事件:', path, oldValue, '→', newValue);
                });
                
                window.eventOn('mag_variable_update_ended', (variables) => {
                    console.log('✅ MVU变量更新完成事件:', variables);
                });
                
                window.eventOn('mag_variable_update_started', (variables) => {
                    console.log('🔄 MVU变量更新开始事件:', variables);
                });
                
                console.log('✅ MVU事件监听器设置完成');
            } else {
                console.warn('⚠️ window.eventOn函数不可用，无法设置MVU事件监听器');
                console.log('可用的全局函数:', Object.keys(window).filter(key => typeof window[key] === 'function'));
            }
        }

        setupEventListeners() {

          $(document).ready(() => {

            (console.log('🔧 使用jQuery设置事件监听器...'),

              $('#save-load-btn').on('click', () => {

                const e = document.getElementById('save-load-sound');

                (e && e.play().catch(e => console.log('音效播放失败:', e)), this.handleSaveLoad());

              }),

              $('#fullscreen-btn').on('click', () => this.toggleFullscreen()),

              $('#danger-btn').on('click', () => {

                const e = document.getElementById('danger-rules-sound');

                (e && e.play().catch(e => console.log('音效播放失败:', e)), this.handleDangerPeriod());

              }),

              $('#debug-btn').on('click', () => this.debugVariables()),

              $('#btn-send-action').on('click', async () => {

                await this.handleActionSubmit();

              }),

              $('#profile-expand').on('click', () => this.toggleProfile()),

              $('#journey-history-btn').on('click', () => this.handleHistory()),

              $('#manage-talents-btn').on('click', () => this.showTalentsModal()),

              $('#close-talents-btn').on('click', () => {

                this.closeTalentsModal();

              }),

              $('#talents-modal').on('click', (e) => {

                if (e.target.id === 'talents-modal') {

                  this.closeTalentsModal();

                }

              }),

              this.setupRulesModal(),

              this.setupLoadModal(),

              this.setupHistoryModal(),

              // 设置MVU事件监听器
              this.setupMVUListeners(),

              document.addEventListener('fullscreenchange', () => this.handleFullscreenChange()),

              document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange()),

              document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange()),

              document.addEventListener('MSFullscreenChange', () => this.handleFullscreenChange()),

              console.log('✅ 事件监听器设置完成'));

          });

        }

        async updateInterface() {

          try {

            // 保存当前滚动位置

            const rightPanelContent = document.querySelector('.right-panel .panel-content');

            const leftPanelContent = document.querySelector('.left-panel .panel-content');

            const savedRightScrollTop = rightPanelContent ? rightPanelContent.scrollTop : 0;

            const savedLeftScrollTop = leftPanelContent ? leftPanelContent.scrollTop : 0;



            // 立即更新基础状态

            (this.updateTrainerStatus(), this.updateUmaStatus(), this.updateTimeDisplay(), this.updateReplyTimer());



            const e = Date.now();

            const lastUpdate = parseInt(localStorage.getItem('teresen_last_full_update') || '0');

            const isFirstLoad = lastUpdate === 0;

            const shouldUpdate = isFirstLoad || e - lastUpdate > 1e4;



            if (shouldUpdate) {

              console.log('🔄 执行完整界面更新...');

              await this.updateStoryContent();

              this.updateInventory();

              this.updateRules();

              this.updateCurrencySystem();

              this.updateFestivalNotice();

              this.updateRulesCountdown();

              this.updateLocation();

              this.updateGachaCoin();

              localStorage.setItem('teresen_last_full_update', e.toString());

              console.log('✅ 完整界面更新完成');

            }



            // 恢复滚动位置（使用setTimeout确保DOM更新完成）

            setTimeout(() => {

              if (rightPanelContent && savedRightScrollTop > 0) {

                rightPanelContent.scrollTop = savedRightScrollTop;

              }

              if (leftPanelContent && savedLeftScrollTop > 0) {

                leftPanelContent.scrollTop = savedLeftScrollTop;

              }

            }, 0);

          } catch (e) {

            console.error('更新界面时出错:', e);

          }

        }



        // 新增：参考项目的updateDynamicData方法，确保所有动态数据都更新

        async updateDynamicData() {

          try {

            console.log('🔄 开始更新动态数据...');



            // 强制更新所有关键界面元素

            this.updateTrainerStatus();

            this.updateUmaStatus();

            this.updateTimeDisplay();

            this.updateReplyTimer();



            // 强制更新所有面板内容

            await this.updateStoryContent();

            this.updateInventory();

            this.updateRules();

            this.updateCurrencySystem();

            this.updateFestivalNotice();

            this.updateRulesCountdown();

            this.updateLocation();

            this.updateGachaCoin();



            console.log('✅ 动态数据更新完成');

          } catch (error) {

            console.error('❌ 更新动态数据时出错:', error);

          }

        }

        getAllVariables() {
          // 重要：优先使用MVU返回的最新数据
          if (this.currentMvuState && this.currentMvuState.stat_data) {
            console.log('✅ 使用MVU返回的最新数据');
            return this.currentMvuState;
          }

          if ((console.group('🔍 获取变量调试信息'), 'function' == typeof getAllVariables)) {

            console.log('✅ getAllVariables函数存在，正在调用...');

            const e = getAllVariables();

            return (

              console.log('📊 获取到的变量数据:', e),

              e && e.stat_data

                ? (console.log('✅ 找到stat_data结构'),

                  console.log('🏃 训练员数据:', e.stat_data.训练员),

                  console.log('🌍 世界数据:', e.stat_data.世界),

                  console.log('🐎 马娘数据:', e.stat_data.马娘),

                  e.stat_data.规则 && console.log('📜 规则数据:', e.stat_data.规则),

                  e.stat_data.外神 && console.log('👹 外神数据:', e.stat_data.外神))

                : (console.warn('⚠️ 未找到stat_data结构'), console.log('🔍 完整返回结果:', e)),

              console.groupEnd(),

              e

            );

          }

          return (

            console.error('❌ getAllVariables函数不存在'),

            console.log(

              '🔍 当前全局函数:',

              Object.keys(window).filter(e => 'function' == typeof window[e]),

            ),

            console.groupEnd(),

            {}

          );

        }

        // 新增：统一的UI渲染函数
        renderUI(data) {
            if (!data) {
                console.warn('RenderUI 调用失败：没有提供数据。');
                return;
            }
            
            console.log('🔄 开始渲染UI，数据:', data);
            
            try {
                // 重要：先更新this.currentMvuState，确保后续函数使用最新数据
                if (this.currentMvuState && this.currentMvuState.stat_data) {
                    console.log('✅ 使用MVU返回的最新数据渲染UI');
                    // 强制更新getAllVariables的缓存
                    this._forceRefreshVariables();
                }
                
                // 更新训练员状态
                this.updateTrainerStatus();
                
                // 更新马娘状态
                this.updateUmaStatus();
                
                // 更新时间显示
                this.updateTimeDisplay();
                
                // 更新回复计时器
                this.updateReplyTimer();
                
                // 更新故事内容
                this.updateStoryContent();
                
                // 更新其他界面元素
                this.updateInventory();
                this.updateRules();
                this.updateCurrencySystem();
                this.updateFestivalNotice();
                this.updateRulesCountdown();
                this.updateLocation();
                this.updateGachaCoin();
                
                console.log('✅ UI渲染完成');
            } catch (error) {
                console.error('❌ UI渲染失败:', error);
            }
        }

        // 新增：强制刷新变量状态，使用MVU返回的最新数据
        _forceRefreshVariables() {
            try {
                console.log('🔄 强制刷新变量状态...');
                
                // 如果MVU返回了新状态，强制更新getAllVariables的缓存
                if (this.currentMvuState && this.currentMvuState.stat_data) {
                    console.log('✅ 检测到MVU新状态，强制刷新变量');
                    
                    // 这里可以添加逻辑来强制刷新TavernHelper的变量缓存
                    // 或者直接使用this.currentMvuState中的数据
                    
                    console.log('📊 MVU新状态数据:', this.currentMvuState.stat_data);
                }
            } catch (error) {
                console.error('❌ 强制刷新变量失败:', error);
            }
        }

        updateTrainerStatus() {

          const e = this.getAllVariables(),

            t = this.getVariable(e, 'stat_data.训练员.体力[0]', 100),

            n = this.getVariable(e, 'stat_data.训练员.理智[0]', 100),

            s = this.getVariable(e, 'stat_data.训练员.运气[0]', 50),

            o = this.getVariable(e, 'stat_data.训练员.在校天数[0]', 0),

            b = this.getVariable(e, 'stat_data.训练员.背景[0]', '无'),

            talent = this.getVariable(e, 'stat_data.训练员.天赋.大天赋.name[0]', '无'),

            crystals = this.getVariable(e, 'stat_data.训练员.畸形情感结晶[0]', 0);



          // 更新进度条颜色

          this.updateProgressBar('stamina-bar', 'stamina-value', t, this.getStaminaColor(t));

          this.updateProgressBar('sanity-bar', 'sanity-value', n, this.getSanityColor(n));

          this.updateProgressBar('luck-bar', 'luck-value', s);



          const a = document.getElementById('trainer-status'),

            l = document.getElementById('days-in-park'),

            bg = document.getElementById('trainer-background'),

            tal = document.getElementById('trainer-talent'),

            cry = document.getElementById('trainer-crystals');



          // 更新状态文本和样式

          if (a) {

            const statusText = this.getTrainerStatusText(n, t);

            a.textContent = statusText;

            a.className = `value ${this.getTrainerStatusClass(n, t)}`;

          }



          // 更新在校天数

          if (l) {

            l.textContent = `${o}天`;

          }



          // 更新训练员背景

          if (bg) {

            bg.textContent = b;

          }



          // 更新训练员天赋

          if (tal) {

            tal.textContent = talent;

          }



          // 更新畸形情感结晶

          if (cry) {

            cry.textContent = crystals;

          }

        }

        updateUmaStatus() {

          const e = document.getElementById('uma-status');

          if (!e) return;

          const t = this.getAllVariables();

          console.log('🔍 所有变量:', t);

          const n = this.getVariable(t, 'stat_data.马娘', {});

          if ((console.log('🐎 马娘数据:', n), !n || 0 === Object.keys(n).length))

            return void (e.innerHTML = '<div class="empty-uma">暂无马娘数据</div>');



          // 检查是否已经存在uma-content，如果不存在则创建

          let umaContent = e.querySelector('.uma-content');

          if (!umaContent) {

            e.innerHTML = '<div class="uma-content"></div>';

            umaContent = e.querySelector('.uma-content');

          }



          // 更新现有的马娘项目，而不是重新生成整个HTML

          Object.keys(n).forEach((umaName, index) => {
            // 自动添加到马娘记名册（只在首次遇到时添加）
            if (window.teresenDebug && window.teresenDebug.addUmaToRoster && !this.umaRosterAdded.has(umaName)) {
              window.teresenDebug.addUmaToRoster(umaName, {
                notes: `首次遇到: ${new Date().toLocaleString('zh-CN')}`
              });
              this.umaRosterAdded.add(umaName);
            }

            const n = this.getVariable(t, `stat_data.马娘.${umaName}.好感度[0]`, 20),

              o = this.getVariable(t, `stat_data.马娘.${umaName}.状态[0]`, '正常'),

              a = this.getUmaDescription(umaName, n, o),

              l = this.getUmaStatusClass(o),

              r = Math.max(1, Math.floor(n / 20)),

              i = this.getUmaAvatar(umaName),

              c = this.getVariable(t, 'stat_data.世界.当前时间[0]', '06:00'),

              d = this.getTimeDangerLevel(c),

              g = this.getVariable(t, `stat_data.马娘.${umaName}.独占度[0]`, 0),

              u = this.getAvatarStyle(g, d);

            (console.log(`🐎 ${umaName} - 好感度: ${n}, 心数: ${r}, 独占度: ${g}`),

              console.log(`💖 ${umaName} 爱心计算: ${n} / 20 = ${n / 20}, Math.floor = ${r}`),

              console.log(`📊 ${umaName} 状态: ${o}, 状态类: ${l}`),

              console.log(`🎨 ${umaName} 头像样式: ${u}`));



            // 查找或创建马娘项目

            let umaItem = umaContent.children[index];

            if (!umaItem) {

              umaItem = document.createElement('div');

              umaItem.className = 'uma-item';

              umaContent.appendChild(umaItem);

            }



            // 根据好感度和独占度计算动态样式

            const nameColor = this.getUmaNameColor(n, g);

            const statusColor = this.getUmaStatusColor(o, g, index);

            const statusBackground = this.getStatusBackgroundColor(o, g, index);



            // 更新马娘项目的内容

            umaItem.innerHTML = `

              <div class="uma-header">

                                  <div class="uma-info">

                    ${i ? `<img src="${i}" alt="${umaName}" class="uma-avatar" style="${u}">` : ''}

                    <div class="uma-text-info">

                      <div class="uma-name" style="color: ${nameColor}">${umaName}</div>
                      <div class="uma-status-text" style="color: ${statusColor}">${o}</div>

                    </div>

                  </div>

              </div>

              <div class="uma-desc">${a}</div>

              <div class="uma-hearts">

                ${this.generateHeartIcons(r)}

              </div>

            `;



            // 设置基础背景色

            umaItem.style.setProperty('background', '#fdfbf7', 'important');

            umaItem.style.setProperty('background-color', '#fdfbf7', 'important');



            // 根据独占度添加JavaScript绘制的花朵

            if (g > 30) {

              // 创建canvas元素来绘制花朵

              const canvas = document.createElement('canvas');

              canvas.width = 200;

              canvas.height = 200;

              canvas.style.cssText = `

                position: absolute;

                top: 50%;

                right: -20px;

                transform: translateY(-50%);

                width: 80px;

                height: 80px;

                pointer-events: none;

                z-index: 1;

                opacity: 0.4;

                filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.6));

              `;

              

              const ctx = canvas.getContext('2d');

              const progress = g / 100;

              

              // 绘制花朵 - 参考背景图片的样式

              ctx.save();

              ctx.translate(100, 100);

              

              // 根据独占度确定颜色和样式

              let flowerColor, petalCount, petalSize;

              if (g > 90) {

                // 90-100%: 深红色复杂花朵

                flowerColor = '#8B0000';

                petalCount = 8;

                petalSize = 25;

              } else if (g > 80) {

                // 80-90%: 红色花朵

                flowerColor = '#DC143C';

                petalCount = 7;

                petalSize = 25;

              } else if (g > 70) {

                // 70-80%: 浅红色花朵

                flowerColor = '#EF4444';

                petalCount = 6;

                petalSize = 25;

              } else if (g > 60) {

                // 60-70%: 粉红色花朵

                flowerColor = '#F87171';

                petalCount = 6;

                petalSize = 25;

              } else if (g > 50) {

                // 50-60%: 浅粉色花朵

                flowerColor = '#FCA5A5';

                petalCount = 5;

                petalSize = 25;

              } else if (g > 40) {

                // 40-50%: 白色花朵

                flowerColor = '#FFFFFF';

                petalCount = 5;

                petalSize = 25;

              } else {

                // 30-40%: 很淡的白色花朵

                flowerColor = '#FFFFFF';

                petalCount = 4;

                petalSize = 25;

              }

              

              // 绘制花瓣 - 使用更自然的曲线

              for (let i = 0; i < petalCount; i++) {

                ctx.save();

                ctx.rotate((Math.PI * 2 / petalCount) * i);

                

                ctx.beginPath();

                ctx.moveTo(0, 0);

                // 使用贝塞尔曲线创建更自然的花瓣形状

                ctx.bezierCurveTo(

                  petalSize * 0.3, -petalSize * 0.4,

                  petalSize * 0.7, -petalSize * 0.3,

                  petalSize * 0.8, 0

                );

                ctx.bezierCurveTo(

                  petalSize * 0.7, petalSize * 0.3,

                  petalSize * 0.3, petalSize * 0.4,

                  0, 0

                );

                

                ctx.fillStyle = flowerColor;

                ctx.fill();

                

                // 添加花瓣边缘的细节

                ctx.strokeStyle = flowerColor;

                ctx.lineWidth = 1;

                ctx.stroke();

                

                ctx.restore();

              }

              

              // 绘制花心

              ctx.beginPath();

              ctx.arc(0, 0, 8, 0, Math.PI * 2);

              ctx.fillStyle = flowerColor;

              ctx.fill();

              

              // 添加花心细节

              ctx.beginPath();

              ctx.arc(0, 0, 4, 0, Math.PI * 2);

              ctx.fillStyle = '#FFF';

              ctx.fill();

              

              ctx.restore();

              

              // 将花朵添加到描述区域的最右边

              const descElement = umaItem.querySelector('.uma-desc');

              if (descElement) {

                descElement.style.position = 'relative';

                descElement.appendChild(canvas);

              } else {

                // 如果找不到描述元素，则添加到整个卡片

                umaItem.style.position = 'relative';

                umaItem.appendChild(canvas);

              }

            }

          });



          // 移除多余的马娘项目

          while (umaContent.children.length > Object.keys(n).length) {

            umaContent.removeChild(umaContent.lastChild);

          }



          // 更新QTE区域状态

          this.updateQTESection();

        }

        // 新增：获取状态装饰图标
        getStatusDecoration(status, exclusiveLevel) {
          const decorations = {
            '正常': '🌸',      // 樱花 - 代表正常状态
            '独占': '🌹',      // 玫瑰 - 代表独占状态
            '失踪': '🌙',      // 月亮 - 代表失踪状态
            '混乱': '🌀',      // 漩涡 - 代表混乱状态
            '警戒': '⚠️',      // 警告 - 代表警戒状态
            '病娇': '💀',      // 骷髅 - 代表病娇状态
            'default': '✨'    // 默认装饰
          };
          
          // 根据独占度调整装饰
          if (exclusiveLevel > 80) {
            return '🔥'; // 高独占度用火焰
          } else if (exclusiveLevel > 60) {
            return '⭐'; // 中高独占度用星星
          } else if (exclusiveLevel > 40) {
            return '💎'; // 中独占度用钻石
          }
          
          return decorations[status] || decorations['default'];
        }

        getUmaAvatar(e) {

          return (

            {

              爱丽数码: 'https://files.catbox.moe/d70ku1.png',

              爱丽速子: 'https://files.catbox.moe/3r2gqv.png',

              爱慕织姬: 'https://files.catbox.moe/wc144f.png',

              爱如往昔: 'https://files.catbox.moe/j7set1.png',

              八重无敌: 'https://files.catbox.moe/fuvyvk.png',

              北部玄驹: 'https://files.catbox.moe/d7990k.png',

              北港火山: 'https://files.catbox.moe/21rq96.png',

              草上飞: 'https://files.catbox.moe/jevm3a.png',

              超级小海湾: 'https://files.catbox.moe/x3ee0m.png',

              成田白仁: 'https://files.catbox.moe/75oai9.png',

              成田路: 'https://files.catbox.moe/90ws3a.png',

              创升: 'https://files.catbox.moe/19o3se.png',

              创世驹: 'https://files.catbox.moe/1xs8sb.png',

              春田乌拉拉: 'https://files.catbox.moe/nvz9k4.png',

              大和赤骥: 'https://files.catbox.moe/8ffgfq.png',

              大鸣大放: 'https://files.catbox.moe/unxq4t.png',

              大树快车: 'https://files.catbox.moe/5jg2l4.png',

              大拓太阳神: 'https://files.catbox.moe/c7z8tt.png',

              待兼福来: 'https://files.catbox.moe/v4dt95.png',

              帝王光环: 'https://files.catbox.moe/b04n2e.png',

              第一红宝石: 'https://files.catbox.moe/j5as90.png',

              东海帝王: 'https://files.catbox.moe/r0i1vk.png',

              东商变革: 'https://files.catbox.moe/02229w.png',

              多旺达: 'https://files.catbox.moe/8smudh.png',

              伏特加: 'https://files.catbox.moe/mef00p.png',

              高尚骏逸: 'https://files.catbox.moe/jp4src.png',

              葛城王牌: 'https://files.catbox.moe/twqi3m.png',

              贵妇人: 'https://files.catbox.moe/9myg2p.png',

              好歌剧: 'https://files.catbox.moe/ymxboj.png',

              荒漠英雄: 'https://files.catbox.moe/y61wwa.png',

              黄金城市: 'https://files.catbox.moe/832mml.png',

              黄金船: 'https://files.catbox.moe/puxu1y.png',

              黄金巨匠: 'https://files.catbox.moe/lg6d5i.png',

              极峰: 'https://files.catbox.moe/j282j7.png',

              金镇之光: 'https://files.catbox.moe/4lx5nv.png',

              骏川手纲: 'https://files.catbox.moe/7apiow.png',

              凯旋芭蕾: 'https://files.catbox.moe/rdldum.png',

              里见光钻: 'https://files.catbox.moe/meq8kw.png',

              里见皇冠: 'https://files.catbox.moe/mvmeuq.png',

              菱钻奇宝: 'https://files.catbox.moe/xm3tws.png',

              鲁道夫象征: 'https://files.catbox.moe/zogjie.png',

              曼城茶座: 'https://files.catbox.moe/8s8ow2.png',

              美妙姿势: 'https://files.catbox.moe/j4gt6b.png',

              美浦波旁: 'https://files.catbox.moe/1dtwml.png',

              梦之旅: 'https://files.catbox.moe/1k3mhi.png',

              迷人景致: 'https://files.catbox.moe/8x3cjc.png',

              米浴: 'https://files.catbox.moe/c3gtgi.png',

              名将怒涛: 'https://files.catbox.moe/xwghd4.png',

              摩耶重炮: 'https://files.catbox.moe/czbbvd.png',

              谋勇兼备: 'https://files.catbox.moe/eq4zkw.png',

              目白阿尔丹: 'https://files.catbox.moe/ob99q8.png',

              目白多伯: 'https://files.catbox.moe/gbvkte.png',

              目白高峰: 'https://files.catbox.moe/iysgye.png',

              目白光明: 'https://files.catbox.moe/8d1iwy.png',

              目白麦昆: 'https://files.catbox.moe/tpep4q.png',

              目白善信: 'https://files.catbox.moe/p7t876.png',

              奇锐骏: 'https://files.catbox.moe/6asj2q.png',

              气槽: 'https://files.catbox.moe/bk7n8x.png',

              千明代表: 'https://files.catbox.moe/0q627d.png',

              强击: 'https://files.catbox.moe/vzxfrt.png',

              青云天空: 'https://files.catbox.moe/5xrxk5.png',

              秋川弥生: 'https://files.catbox.moe/2mr9zz.png',

              荣进闪耀: 'https://files.catbox.moe/87lcsh.png',

              森林宝穴: 'https://files.catbox.moe/50rq7n.png',

              神鹰: 'https://files.catbox.moe/1bch4y.png',

              双涡轮: 'https://files.catbox.moe/ffi15d.png',

              特别周: 'https://files.catbox.moe/waylx3.png',

              天狼星象征: 'https://files.catbox.moe/457y2f.png',

              丸善斯基: 'https://files.catbox.moe/jujcy2.png',

              无声铃鹿: 'https://files.catbox.moe/s6pnkl.png',

              西野花: 'https://files.catbox.moe/4qzhsz.png',

              小栗帽: 'https://files.catbox.moe/nmgyj9.png',

              小林厉奇: 'https://files.catbox.moe/sd03xi.png',

              新宇宙: 'https://files.catbox.moe/zaad8r.png',

              杏目: 'https://files.catbox.moe/vejrmc.png',

              樱花千代王: 'https://files.catbox.moe/a3g3gf.png',

              玉藻十字: 'https://files.catbox.moe/5g6z60.png',

              真弓快车: 'https://files.catbox.moe/unihzk.png',

              真机伶: 'https://files.catbox.moe/5y8jxf.png',

              中山庆典: 'https://files.catbox.moe/x8az97.png',

              周日宁静: 'https://files.catbox.moe/uccqyf.png',

              卓芙: 'https://files.catbox.moe/syhdp7.png',

              达利阿拉伯: 'https://files.catbox.moe/c2ldl4.png',

              高多芬阿拉伯: 'https://files.catbox.moe/x2unca.png',

              黄金旅程: 'https://files.catbox.moe/ebrxrn.png',

              艾尼斯风神: 'https://files.catbox.moe/nnd19a.png',

              富士奇石: 'https://files.catbox.moe/2p60gy.png',

              菱亚马逊: 'https://files.catbox.moe/xeeyrl.png',

              胜利奖券: 'https://files.catbox.moe/lnhtai.png',

            }[e] || null

          );

        }

        getAvatarStyle(e, t) {

          return `width: 58.44px; height: 64px; border-radius: 0.5rem; object-fit: cover;`;

        }



        // 根据好感度和独占度计算名字颜色

        getUmaNameColor(favorability, exclusivity) {

          // 高独占度时显示红色系

          if (exclusivity > 90) return '#dc2626'; // 深红色

          if (exclusivity > 80) return '#ef4444'; // 红色

          if (exclusivity > 70) return '#f87171'; // 浅红色



          // 高好感度时显示粉色系

          if (favorability > 80) return '#ec4899'; // 粉色

          if (favorability > 60) return '#f472b6'; // 浅粉色

          if (favorability > 40) return '#f9a8d4'; // 更浅粉色



          // 默认颜色

          return '#8b6914'; // 金色

        }



        // 状态文字颜色固定为白色

        getUmaStatusColor(status, exclusivity, index = 0) {

          return '#ffffff'; // 固定白色

        }



        // 根据卡片索引计算状态徽章背景色

        getStatusBackgroundColor(status, exclusivity, index = 0) {

          // 根据卡片排序分布背景色，与文字颜色形成对比

          const backgrounds = [

            'rgba(239, 68, 68, 0.15)', // 浅红色背景

            'rgba(59, 130, 246, 0.15)', // 浅蓝色背景

            'rgba(34, 197, 94, 0.15)', // 浅绿色背景

            'rgba(251, 191, 36, 0.15)', // 浅黄色背景

            'rgba(139, 92, 246, 0.15)', // 浅紫色背景

            'rgba(249, 115, 22, 0.15)', // 浅橙色背景

            'rgba(6, 182, 212, 0.15)', // 浅青色背景

            'rgba(236, 72, 153, 0.15)', // 浅粉色背景

            'rgba(132, 204, 22, 0.15)', // 浅青绿色背景

            'rgba(245, 158, 11, 0.15)', // 浅琥珀色背景

          ];

          return backgrounds[index % backgrounds.length];

        }



        updateCurrencySystem() {

          const e = this.getAllVariables(),

            t = this.getVariable(e, 'stat_data.训练员.实验数据点[0]', 0),

            n = document.getElementById('currency-value');

          n && (n.textContent = t.toString());

        }

        updateFestivalNotice() {

          const e = this.getAllVariables(),

            t = this.getVariable(e, 'stat_data.世界.当前节日[0]', ''),

            s = document.getElementById('festival-notice'),

            o = document.getElementById('festival-text');

          s &&

            o &&

            (t && t !== '' && t !== null && t !== 'null'

              ? ((o.textContent = `${t}`), (s.style.display = 'flex'))

              : ((o.textContent = '平平无奇的一天'), (s.style.display = 'flex')));

        }

        updateRulesCountdown() {

          const e = this.getAllVariables(),

            t = this.getVariable(e, 'stat_data.世界.规则刷新日[0]', 0),

            n = document.getElementById('rules-countdown'),

            s = document.getElementById('countdown-text');

          n &&

            s &&

            (t > 0

              ? ((s.textContent = `规则刷新: ${t}天后`), (n.style.display = 'flex'))

              : ((s.textContent = '规则今日刷新'), (n.style.display = 'flex')));

        }

        updateReplyTimer() {

          try {

            const e = document.getElementById('reply-timer'),

              t = document.getElementById('reply-timer-text');

            if (!e || !t) return;

            const n = localStorage.getItem('teresen_waiting_for_reply'),

              s = localStorage.getItem('teresen_reply_start_time');

            if ('true' === n && s) {

              const n = parseInt(s),

                o = new Date().getTime() - n,

                a = Math.floor(o / 6e4),

                l = Math.floor((o % 6e4) / 1e3);

              ((t.textContent = `Eternal zz码字中: ${a.toString().padStart(2, '0')}:${l.toString().padStart(2, '0')}`),

                (e.className = o >= 3e5 ? 'reply-timer danger' : o >= 18e4 ? 'reply-timer warning' : 'reply-timer'),

                (e.style.display = 'flex'));

            } else {

              const n = localStorage.getItem('teresen_last_reply_time');

              const evaluation = localStorage.getItem('teresen_last_reply_evaluation') || '';

              if (n) {

                const s = parseInt(n),

                  o = Math.floor(s / 6e4),

                  a = Math.floor((s % 6e4) / 1e3);

                const timeText = `${o.toString().padStart(2, '0')}:${a.toString().padStart(2, '0')}`;

                const displayText = evaluation

                  ? `${timeText}，E眼盯帧：${evaluation}`

                  : `${timeText}`;

                ((t.textContent = displayText), (e.className = 'reply-timer'), (e.style.display = 'flex'));

              } else this.hideReplyTimer();

            }

          } catch (e) {

            (console.error('更新回复时间计算失败:', e), this.hideReplyTimer());

          }

        }

        hideReplyTimer() {

          const e = document.getElementById('reply-timer');

          e && (e.style.display = 'none');

        }

        startReplyTimer() {

          setInterval(() => {

            this.updateReplyTimer();

          }, 1e3);

        }

        setupStreamListeners() {

          try {

            if ('undefined' != typeof eventOn && void 0 !== window.iframe_events) {

              const e = window.iframe_events;

              (eventOn(e.GENERATION_STARTED, () => {

                (console.log('🚀 AI开始生成回复'), this.startReplyTiming());

              }),

                eventOn(e.STREAM_TOKEN_RECEIVED_FULLY, e => {

                  this.updateInterface();

                }),

                eventOn(e.GENERATION_ENDED, e => {

                  (console.log('✅ AI回复生成完成'), this.endReplyTimer(), this.updateInterface());

                  // AI回复完成后，让中央面板滚动到顶部

                  setTimeout(() => {

                    const centerPanel = document.querySelector('.center-panel');

                    if (centerPanel) {

                      centerPanel.scrollTop = 0;

                      console.log('📜 中央面板已滚动到顶部');

                    }

                  }, 100);



                  // AI回复完成后，检测是否需要显示QTE（简化版）

                  setTimeout(() => {

                    try {

                      console.log('🔍 检测QTE触发条件...');



                      // 方法1：通过TavernHelper API获取最新AI消息

                      let aiContent = '';

                      if (typeof TavernHelper !== 'undefined' && TavernHelper.getChatMessages) {

                        try {

                          const messages = TavernHelper.getChatMessages();

                          const aiMessages = messages.filter(msg => msg.role === 'assistant');

                          if (aiMessages.length > 0) {

                            const lastMessage = aiMessages[aiMessages.length - 1];

                            aiContent = lastMessage.content || '';

                            console.log('🔍 通过API获取AI内容，长度:', aiContent.length);

                          }

                        } catch (apiError) {

                          console.warn('API获取失败，使用DOM方法:', apiError);

                        }

                      }



                      // 方法2：如果API失败，使用DOM方法

                      if (!aiContent) {

                        aiContent =

                          $('#chat_container .mes_text_ai').last().text() ||

                          $('#chat_container .mes_text').last().text() ||

                          '';

                        console.log('🔍 通过DOM获取AI内容，长度:', aiContent.length);

                      }



                      console.log('🔍 AI内容前100字符:', aiContent.substring(0, 100));



                      if (aiContent && this.containsBindingKeywords(aiContent)) {

                        $('#qte-section').show();

                        console.log('🎮 QTE已显示');

                      } else {

                        $('#qte-section').hide();

                        console.log('🎮 QTE已隐藏');

                      }

                    } catch (error) {

                      console.error('❌ QTE检测失败:', error);

                    }

                  }, 1500);

                }),

                console.log('✅ 流式更新监听器设置完成'));

            } else

              (console.warn('⚠️ 流式事件API不可用，使用传统更新方式'),

                $('#btn-send-action').on('click', () => {

                  (console.log('🚀 备用方案：开始计时'), this.startReplyTiming());

                }));

          } catch (e) {

            console.error('❌ 设置流式监听器失败:', e);

          }

        }

        startReplyTiming() {

          const e = new Date().getTime();

          (localStorage.setItem('teresen_reply_start_time', e.toString()),

            localStorage.setItem('teresen_waiting_for_reply', 'true'),

            console.log('⏱️ 开始计时:', new Date(e).toLocaleString()));

        }

        endReplyTimer() {

          try {

            const e = localStorage.getItem('teresen_reply_start_time'),

              t = localStorage.getItem('teresen_waiting_for_reply');

            if (e && 'true' === t) {

              const t = parseInt(e),

                n = new Date().getTime() - t;

              const seconds = Math.floor(n / 1e3);



              // 根据回复时间生成评价

              let evaluation = '';

              if (seconds <= 20) {

                evaluation = '神！';

              } else if (seconds <= 30) {

                evaluation = '很快！';

              } else if (seconds <= 40) {

                evaluation = '快！';

              } else if (seconds <= 50) {

                evaluation = '还行！';

              } else if (seconds <= 60) {

                evaluation = '一般！';

              } else if (seconds <= 90) {

                evaluation = '慢！';

              } else if (seconds <= 120) {

                evaluation = '很慢！';

              } else {

                evaluation = '太慢了！';

              }



              (localStorage.setItem('teresen_last_reply_time', n.toString()),

                localStorage.setItem('teresen_waiting_for_reply', 'false'),

                localStorage.setItem('teresen_last_reply_evaluation', evaluation),

                console.log(`✅ 回复生成完成，耗时: ${seconds}秒，E眼盯帧：${evaluation}`),

                this.updateReplyTimer());

            }

          } catch (e) {

            console.error('结束计时失败:', e);

          }

        }

        async updateStoryContent() {

          try {

            const t = this.getAllVariables();

            let n = this.getVariable(t, 'stat_data.世界.当前正文[0]', '');

            if (!n && 'function' == typeof getChatMessages)

              try {

                const e = await getChatMessages(0);

                e && e.length > 0 && e[0].message && (n = e[0].message);

              } catch (e) {

                console.warn('获取0层消息失败:', e);

              }



            // 如果没有内容，使用默认内容

            n ||

              (n =

                '你刚刚来到特雷森学院，作为一名新晋训练员，你被分配到了这所著名的赛马娘学院。学院里充满了神秘的气息，你感觉到这里似乎隐藏着什么不为人知的秘密...\n\n深夜的训练场总是格外寂静...你站在训练场的阴影中，月光透过云层洒在跑道上。今晚的训练已经结束，但你却感觉到有什么不对劲的地方。\n\n空气中弥漫着一种奇怪的气息，仿佛有什么东西在暗中窥视着你。你想起了最近流传的那些传言——关于深夜训练场上出现的神秘身影，关于那些消失的训练员...\n\n你的手不自觉地握紧了手中的秒表，这是你作为训练员最重要的工具。但现在，它似乎变得异常沉重。你想起了她...那个总是在你梦中出现的身影。\n\n远处传来了马蹄声，但这个时间不应该有任何赛马娘在训练。声音越来越近，你感到一阵寒意爬上脊背。但同时，你的心中涌起了一种奇怪的期待...\n\n"训练员..."一个熟悉的声音在风中飘荡，是她的声音。你知道你应该离开，但你的双脚却不听使唤。\n\n在你面前，有几个选择摆在眼前...');



            // 提取 <content></content> 标签中的内容

            const contentMatch = n.match(/<content>(.*?)<\/content>/s);

            if (contentMatch) {

              n = contentMatch[1].trim();

              console.log('✅ 从<content></content>标签中提取内容成功');

            } else {

              console.log('📝 未找到<content></content>标签，使用原始内容');

            }

            // 应用去八股正则脚本

            n = this.applyAntiBoilerplateRules(n);

            const s = document.getElementById('story-content');

            s && (s.innerHTML = `<p class="story-text">${n}</p><span class="typewriter-cursor">|</span>`);

          } catch (e) {

            console.log('无法获取正文内容:', e);

          }

        }

        applyAntiBoilerplateRules(content) {
          if (!content || typeof content !== 'string') return content;
          
          let processed = content;
          
          // 基础总则 - 删除特定词汇
          processed = processed.replace(/((?:绝望|麻木|勾起|一丝(?:丝)|封闭|僵住|恐惧|恐慌|惧怕|震惊|羞耻|屈辱|病态|崩溃|四肢百骸|cốgắng|subtly|yet|滚烫的岩浆|生理(?:的|性|层面|本能)|压抑|不似人声|机械地|野兽|幼兽|毒蛇|藤蔓|缠绕|肉刃|尖锐|冰冷|难以置信|不容(?:置疑|置喙)|泛白|他知道|她知道|濒临失控|意味深长|邪魅|邪笑|吞吃入腹|海啸|闪着|闪烁|低吼|唇舌|研磨|骨血|骨血之中|躁候|极致|弧度|小(?:兽|妖精|骚货|可爱|极度|东西|狐狸|野猫)|弓(?:起|着))[地丝的得]?\**)/g, '  ');
          
          // 删除总则 - 删除特定表达
          processed = processed.replace(/不似人声(的|地|得)?|(恨不|想要).*?塞进去[,\\.，。]?|不容[\u4e00-\u9fff]{2}(的|地|得)/g, '');
          
          // 警觉替换
          processed = processed.replace(/(警觉|警觉)/g, this.getRandomReplacement(['留心', '稍作留意', '注意']));
          
          // 餍足替换
          processed = processed.replace(/(餍足)/g, '满足');
          
          // 野兽系替换
          processed = processed.replace(/(小兽|幼兽)/g, this.getRandomReplacement(['像小猫', '率直', '本能而急切', '像小狗', '纯粹凭着感觉', '懵懵懂懂']));
          
          // 肉刃替换
          processed = processed.replace(/(肉刃|肉茎)/g, this.getRandomReplacement(['肉柱', '阳具', '阴茎', '鸡巴', '巨物', '龙根']));
          
          // 痉挛替换
          processed = processed.replace(/(痉挛)/g, this.getRandomReplacement(['抽搐', '强力收缩', '肌肉紧张']));
          
          // 甬道替换
          processed = processed.replace(/(甬道)/g, '通道');
          
          // 生理系替换
          processed = processed.replace(/(生理性|生理上|生理层面)/g, this.getRandomReplacement(['本能的', '源自身体的']));
          
          // 狡黠替换
          processed = processed.replace(/(狡黠)/g, this.getRandomReplacement(['古灵精怪', '调皮', '促狭']));
          
          // 灭顶替换
          processed = processed.replace(/(灭顶)/g, this.getRandomReplacement(['强烈', '无边', '难以言喻']));
          
          // 机械地替换
          processed = processed.replace(/(机械地)/g, this.getRandomReplacement(['单调地', '主动地']));
          
          // 扭曲替换
          processed = processed.replace(/(扭曲)/g, this.getRandomReplacement(['别样', '不凡', '独特', '特殊']));
          
          // 封闭替换
          processed = processed.replace(/(封闭)/g, this.getRandomReplacement(['略有犹豫', '若有所思', '短暂沉默']));
          
          // 四肢百骸替换
          processed = processed.replace(/(四肢百骸)/g, this.getRandomReplacement(['全身', '周身', '从头到脚', '整个身体']));
          
          // 喟叹替换
          processed = processed.replace(/(喟叹)/g, this.getRandomReplacement(['叹息', '感叹']));
          
          // 吼叫类替换
          processed = processed.replace(/(低吼)/g, this.getRandomReplacement(['闷哼', '低喘', '喉音', '粗重的呼吸', '低吼']));
          
          // 勐替换
          processed = processed.replace(/(勐)/g, '猛');
          
          // 全然替换
          processed = processed.replace(/(全然)/g, this.getRandomReplacement(['纯粹', '完全', '全身心']));
          
          // 不易察觉替换
          processed = processed.replace(/(不易察觉)/g, this.getRandomReplacement(['难以察觉', '细微', '隐约', '难以觉察']));
          
          // 一丝替换
          processed = processed.replace(/(一丝丝|一丝(?!不苟))/g, this.getRandomReplacement(['些微', '些许', '一点', '一丝']));
          
          // 外语词汇替换
          processed = processed.replace(/(влажной)/g, this.getRandomReplacement(['湿润', '泛滥', '泥泞']));
          processed = processed.replace(/(vén)/g, '静脉');
          processed = processed.replace(/(subtly)/g, this.getRandomReplacement(['微妙的', '精妙的']));
          processed = processed.replace(/(strangely)/g, '奇怪');
          processed = processed.replace(/(cốgắng)/g, this.getRandomReplacement(['努力地', '尽力地', '力图']));
          
          // 投石系删除 - 删除各种投石相关的表达
          processed = processed.replace(/(?:[,，]\s*)?(?:(?:如同|仿佛|犹如|像)\s+)?[^.。！？>:：""\n]*?(?:掉落|掉入|掉进|抛入|抛进|抛落|落入|投进|投入|丢进|丢入|放入|投下)[^,，.。！？>:：""\n]*?(?:(?:风|铁块|种子|铜块|金块|冰块|石头|石子|大石|巨石|炸弹|鹅卵石|清油|糖果|滴水|海绵|浓墨|闪电|催化剂|冷水|钥匙|水滴|冰水|冰山)[^,，.。！？>:：""\n]*?[,，.。！？>:：""\n][^,，.。！？>:：""\n]*?涟漪[)）]?|(?:风|铁块|种子|铜块|金块|冰块|石头|石子|大石|巨石|炸弹|鹅卵石|清油|糖果|滴水|海绵|浓墨|闪电|催化剂|冷水|钥匙|水滴|冰水|冰山)[)）]?|[,，.。！？>:：""\n][^,，.。！？>:：""\n]*?涟漪[)）]?|[,，.。！？>:：""\n])/g, '');
          
          // 其他常见替换
          processed = processed.replace(/(绝望|麻木|崩溃)/g, '失落');
          processed = processed.replace(/(恐惧|恐慌|惧怕)/g, '害怕');
          processed = processed.replace(/(震惊|难以置信)/g, '惊讶');
          processed = processed.replace(/(羞耻|屈辱)/g, '羞愧');
          
          // 文本格式美化
          processed = processed.replace(/“([^”]+)”/g, (match, p1) => {
              return `<span class="dialogue-text">${match}</span>`;
          });          
          processed = processed.replace(/\[([^\]]+)\]/g, (match, p1) => {
              return `<span class="psychology-text">${match}</span>`;
          });
          processed = processed.replace(/\*\*([^*]+)\*\*/g, (match, p1) => {
              return `<span class="scenery-text">${match}</span>`;
          });
          
          return processed;
        }

        getRandomReplacement(options) {
          if (!Array.isArray(options) || options.length === 0) return options;
          return options[Math.floor(Math.random() * options.length)];
        }

        async syncMVUToMessage() {

          try {

            if ('function' == typeof getChatMessages && 'undefined' != typeof TavernHelper) {

              const e = await getChatMessages(0);

              if (e && e.length > 0) {

                const t = e[0],

                  n = this.getAllVariables();

                ((t.data = n),

                  await TavernHelper.setChatMessages([t], { refresh: 'none' }),

                  console.log('✅ MVU状态已同步到0层消息'));

              }

            }

          } catch (e) {

            console.error('❌ 同步MVU状态失败:', e);

          }

        }

        updateTimeDisplay() {

          const e = this.getAllVariables(),

            t = this.getVariable(e, 'stat_data.世界.当前时间[0]', '06:00'),

            n = this.getVariable(e, 'stat_data.世界.当前日期[0]', '2024-01-01'),

            s = this.getVariable(e, 'stat_data.训练员.位置[0]', '训练员宿舍'),

            o = document.getElementById('current-time');

          o && (o.textContent = `📍 ${s} | 🕐 ${n} - ${t}`);

        }

        getTimeDangerLevel(e) {

          const t = parseInt(e.split(':')[0]);

          return t >= 6 && t < 8

            ? 'safe'

            : t >= 8 && t < 12

              ? 'low'

              : t >= 12 && t < 17

                ? 'medium'

                : t >= 17 && t < 20

                  ? 'high'

                  : 'extreme';

        }

        getDangerLevelText(e) {

          switch (e) {

            case 'safe':

              return '相对安全期';

            case 'low':

              return '中等风险期';

            case 'medium':

              return '较高风险期';

            case 'high':

              return '高风险期';

            case 'extreme':

              return '极度危险期';

            default:

              return '未知时段';

          }

        }

        getDangerLevelDetails(e) {

          switch (e) {

            case 'safe':

              return '<strong>早晨 6:00-8:00：相对安全期</strong>\n\n<div class="danger-stars">危险等级：★☆☆☆☆</div>\n\n马娘欲望处于初醒状态，表现相对温和\n\n<div class="danger-suggestion">\n<strong>主要风险：</strong>拒绝"早安问候"可能引发的隔离警告\n</div>\n\n<div class="danger-suggestion">\n<strong>建议：</strong>接受所有形式的早晨互动，保持基本礼仪\n</div>\n\n此阶段是收集信息和建立日常routine的最佳时机';

            case 'low':

              return '<strong>上午 8:00-12:00：中等风险期</strong>\n\n<div class="danger-stars">危险等级：★★☆☆☆</div>\n\n马娘开始竞争注意力，妒意开始积累\n\n<div class="danger-suggestion">\n<strong>主要风险：</strong>表现出明显偏好会激化马娘间的竞争\n</div>\n\n<div class="danger-suggestion">\n<strong>建议：</strong>保持绝对公正的态度，平均分配关注度\n</div>\n\n注意观察马娘间的微妙互动，预判可能冲突';

            case 'medium':

              return '<strong>午后 12:00-17:00：较高风险期</strong>\n\n<div class="danger-stars">危险等级：★★★☆☆</div>\n\n马娘开始渗透个人空间，独占度开始提升\n\n<div class="danger-suggestion">\n<strong>主要风险：</strong>过度接受协助会导致某位马娘独占度急剧上升\n</div>\n\n<div class="danger-suggestion">\n<strong>建议：</strong>适度接受帮助但保持距离，避免形成固定模式\n</div>\n\n注意保护个人物品和空间不被过度侵占';

            case 'high':

              return '<strong>傍晚 17:00-20:00：高风险期</strong>\n\n<div class="danger-stars">危险等级：★★★★☆</div>\n\n马娘欲望达到峰值，寻求深度亲密互动\n\n<div class="danger-suggestion">\n<strong>极高风险：</strong>拒绝会引发补偿性索取，接受会导致过度亲密\n</div>\n\n<div class="danger-suggestion">\n<strong>建议：</strong>谨慎选择互动对象，设定明确边界\n</div>\n\n准备应对可能触发的夜晚特殊事件';

            case 'extreme':

              return '<strong>夜晚 20:00-6:00：极度危险期</strong>\n\n<div class="danger-stars">危险等级：★★★★★</div>\n\n马娘褪去所有伪装，展现最原始的狩猎本能\n\n<div class="danger-suggestion">\n<strong>极端危险：</strong>规则界限模糊，欲望完全释放\n</div>\n\n<div class="danger-suggestion">\n<strong>建议：</strong>尽量避免单独行动，保持高度警觉\n</div>\n\n必须随身携带生存道具，做好应急准备\n此阶段生存概率最低，需要最大程度的谨慎\n\n<div class="danger-suggestion" style="background: rgba(220, 38, 38, 0.1); border-left-color: #dc2626;">\n<strong>【特别警告】</strong>夜晚时段是生存挑战最大的阶段，马娘们的欲望不再受到任何约束，建议训练员在此时间段尽量减少外出，锁好房门，并准备好应对各种突发状况的生存道具。\n</div>';

            default:

              return '未知时段，请保持警惕';

          }

        }

        updateInventory() {

          const e = this.getAllVariables();

          console.group('🔍 更新物品栏调试');

          const t = this.getVariable(e, 'stat_data.训练员.物品栏', {});

          console.log('物品栏原始数据:', t);



          console.log('物品栏对象:', t);

          const s = document.getElementById('inventory-list');

          if ((console.log('物品栏容器:', s), !s))

            return (console.error('❌ 找不到物品栏容器'), void console.groupEnd());



          // 保存当前滚动位置

          const savedInventoryScrollTop = s ? s.scrollTop : 0;



          if (!t || 0 === Object.keys(t).length) {

            console.warn('⚠️ 物品栏为空');

            // 检查是否已经有空状态显示

            const existingEmpty = s.querySelector('.empty-inventory');

            if (!existingEmpty) {

              s.innerHTML = '<div class="empty-inventory">暂无道具</div>';

            }

            console.groupEnd();

            return;

          }



          // 获取当前所有道具项目

          const currentItems = Array.from(s.querySelectorAll('.inventory-item'));

          const itemNames = Object.keys(t);



          // 更新现有道具项目

          itemNames.forEach((itemName, index) => {

            const itemData = t[itemName];

            let itemElement = currentItems[index];



            // 如果元素不存在，创建新的

            if (!itemElement) {

              itemElement = document.createElement('div');

              itemElement.className = 'inventory-item';

              itemElement.setAttribute('data-item-index', index);

              s.appendChild(itemElement);

            }



            // 更新道具内容

            if (typeof itemData === 'object' && itemData.描述) {

              itemElement.innerHTML = `

                <div class="item-header">

                  <div class="item-name">${itemName}</div>

                </div>

              `;

            } else {

              itemElement.innerHTML = `<span>${itemName}</span>`;

            }

          });



          // 删除多余的道具项目

          for (let i = itemNames.length; i < currentItems.length; i++) {

            currentItems[i].remove();

          }



          // 移除空状态显示

          const emptyElement = s.querySelector('.empty-inventory');

          if (emptyElement) {

            emptyElement.remove();

          }

          setTimeout(() => {

            $('.item-header')

              .off('click')

              .on('click', function (e) {

                e.preventDefault();

                e.stopPropagation();

                console.log('道具被点击了！');

                const itemIndex = $(this).closest('.inventory-item').data('item-index');

                const itemData = t[Object.keys(t)[itemIndex]];

                if (itemData && itemData.描述) {

                  console.log('道具索引:', itemIndex);

                  console.log('道具数据:', itemData);

                  $('.item-detail-popup').remove();

                  const popup = $(

                    `\n               <div class="item-detail-popup">\n                 <div class="item-name">${Object.keys(t)[itemIndex]}</div>\n                 <div class="item-desc">${itemData.描述}</div>\n                 <div class="item-effect">效果: ${itemData.效果}</div>\n                 <div class="item-info-row">\n                   <div class="item-rarity rarity-${itemData.稀有度}">${itemData.稀有度}</div>\n                   <div class="item-actions">\n                     <button class="item-use-btn" title="使用">🎯</button>\n                     <button class="item-discard-btn" title="丢弃">🗑️</button>\n                     <button class="item-lock-btn" title="锁定">🔒</button>\n                     <button class="item-gift-btn" title="赠送">🎁</button>\n                   </div>\n                 </div>\n               </div>\n             `,

                  );

                  $('body').append(popup);

                  const element = $(this)[0];

                  if (element && popup.length > 0) {

                    const rect = element.getBoundingClientRect(),

                      popupHeight = popup.outerHeight() || 0;

                    popup.css({ position: 'fixed', top: rect.top - popupHeight - 10, left: rect.left, zIndex: 9999 });

                  }

                  $(document).one('click', function (e) {

                    $(e.target).closest('.item-detail-popup').length || $('.item-detail-popup').remove();

                  });



                  // 绑定道具操作按钮事件

                  popup.find('.item-use-btn').on('click', function () {

                    const itemName = Object.keys(t)[itemIndex];

                    addPendingAction('use', itemName);

                    $('.item-detail-popup').remove();

                  });



                  popup.find('.item-discard-btn').on('click', function () {

                    const itemName = Object.keys(t)[itemIndex];

                    addPendingAction('discard', itemName);

                    $('.item-detail-popup').remove();

                  });



                  popup.find('.item-lock-btn').on('click', function () {

                    const itemName = Object.keys(t)[itemIndex];

                    toggleItemLock(itemName, $(this));

                  });



                  popup.find('.item-gift-btn').on('click', function () {

                    const itemName = Object.keys(t)[itemIndex];

                    startGiftSelection(itemName);

                    $('.item-detail-popup').remove();

                  });

                }

              });

          }, 100);



          console.groupEnd();

        }

        updateRules() {

          this.updateRulesModal();

        }

        updateRulesModal() {

          const fixedRules = [

            '你是这里唯一的人类训练员，请不要拒绝马娘',
            '请夜晚不要单独待在宿舍',
            '作为训练员，你需要组建一个马娘团队，并带领她们参加比赛',
            '在学院外面若察觉到被尾随，请立即前往目白城和黄金家族的居所',
            '你可以完全相信你的最佳搭档，若是与最佳搭档同行，可以不遵守以上规则',

          ];

          
          // 更新固定规则
          const fixedRulesList = document.getElementById('fixed-rules-list');

          if (fixedRulesList) {

            let fixedRulesHtml = '';

            fixedRules.forEach((rule, index) => {

              fixedRulesHtml += `\n          <div class="rule-item-handwritten">\n            <span class="rule-number-handwritten">${index + 1}.</span>\n            <span class="rule-text-handwritten">${rule}</span>\n          </div>\n        `;

            });

            fixedRulesList.innerHTML = fixedRulesHtml;

          }

          
          // 更新用户记录的规则
          this.updateUserRules();
          
          // 确保规则记录按钮事件绑定
          setTimeout(() => {
            $('#add-rule-btn').off('click').on('click', () => {
              console.log('🎯 添加规则按钮被点击');
              this.addRule();
            });
            $('#clear-rules-btn').off('click').on('click', () => {
              console.log('🎯 清空规则按钮被点击');
              this.clearAllRules();
            });
          }, 100);
        }
        
        // 获取用户记录的规则
        getUserRules() {
          const savedRules = localStorage.getItem('teresen-user-rules');
          return savedRules ? JSON.parse(savedRules) : [];
        }
        
        // 保存用户记录的规则
        saveUserRules(rules) {
          localStorage.setItem('teresen-user-rules', JSON.stringify(rules));
        }
        
        // 更新用户规则显示
        updateUserRules() {
          const userRules = this.getUserRules();
          const randomRulesList = document.getElementById('random-rules-list');

          
          if (randomRulesList) {

            let randomRulesHtml = '';

            
            if (userRules.length === 0) {
              randomRulesHtml = '<div class="empty-rules">暂无记录的规则，点击"添加规则"开始记录</div>';
            } else {
              userRules.forEach((rule, index) => {
                randomRulesHtml += `\n          <div class="rule-item-handwritten rule-item-editable" data-rule-index="${index}">\n            <span class="rule-number-handwritten">${index + 6}.</span>\n            <span class="rule-text-handwritten">${rule}</span>\n            <button class="rule-edit-btn" onclick="window.teresenDebug.editRule(${index})" title="编辑规则">✏️</button>\n            <button class="rule-delete-btn" onclick="window.teresenDebug.deleteRule(${index})" title="删除规则">🗑️</button>\n          </div>\n        `;
              });
            }
            
            randomRulesList.innerHTML = randomRulesHtml;

          }

        }

        
        // 添加新规则
        addRule() {
          const userRules = this.getUserRules();
          if (userRules.length >= 7) {
            alert('最多只能记录7条规则！');
            return;
          }
          
          const newRule = prompt('请输入发现的规则：');
          if (newRule && newRule.trim()) {
            userRules.push(newRule.trim());
            this.saveUserRules(userRules);
            this.updateUserRules();
          }
        }
        
        // 编辑规则
        editRule(index) {
          const userRules = this.getUserRules();
          if (index >= 0 && index < userRules.length) {
            const newRule = prompt('编辑规则：', userRules[index]);
            if (newRule !== null) {
              userRules[index] = newRule.trim();
              this.saveUserRules(userRules);
              this.updateUserRules();
            }
          }
        }
        
        // 删除规则
        deleteRule(index) {
          const userRules = this.getUserRules();
          if (index >= 0 && index < userRules.length) {
            if (confirm('确定要删除这条规则吗？')) {
              userRules.splice(index, 1);
              this.saveUserRules(userRules);
              this.updateUserRules();
            }
          }
        }
        
        // 清空所有规则
        clearAllRules() {
          if (confirm('确定要清空所有记录的规则吗？此操作不可恢复！')) {
            this.saveUserRules([]);
            this.updateUserRules();
          }
        }
        updateProgressBar(e, t, n, color) {

          const s = document.getElementById(e),

            o = document.getElementById(t);

          if (s) {

            const e = Math.min(100, Math.max(0, n));

            s.style.width = `${e}%`;

            s.className = 'progress-fill';



            // 应用颜色

            if (color) {

              s.style.background = color;

            } else {

              // 默认颜色逻辑

              e < 30 ? s.classList.add('danger') : e < 60 && s.classList.add('warning');

            }

          }

          o && (o.textContent = n.toString());

        }

        getVariable(e, t, n) {

          try {

            const s = t.split(/\.|\[|\]/).filter(e => '' !== e);

            let o = e;

            (console.group(`🔍 获取变量: ${t}`), console.log('📊 起始对象:', e));

            for (let e = 0; e < s.length; e++) {

              const t = s[e];

              if ((console.log(`🔍 访问键: ${t}`), !o || 'object' != typeof o))

                return (console.warn(`❌ 路径中断，返回默认值: ${n}`), console.groupEnd(), n);

              if (e + 1 < s.length && !isNaN(parseInt(s[e + 1]))) {

                if (!Array.isArray(o[t])) return (console.warn(`❌ 不是数组，返回默认值: ${n}`), console.groupEnd(), n);

                {

                  const n = parseInt(s[e + 1]);

                  ((o = o[t][n]), e++, console.log(`✅ 数组访问 [${n}]:`, o));

                }

              } else ((o = o[t]), console.log('✅ 找到值:', o));

            }

            const a = void 0 !== o ? o : n;

            return (console.log(`🎯 最终结果: ${a}`), console.groupEnd(), a);

          } catch (s) {

            return (console.error(`❌ 获取变量出错: ${t}`, s), console.groupEnd(), n);

          }

        }

        getTrainerStatusText(sanity, stamina) {

          if (sanity >= 80 && stamina >= 80) return '绝好调';

          if (sanity >= 60 && stamina >= 60) return '好调';

          if (sanity >= 40 && stamina >= 40) return '普通';

          if (sanity >= 20 && stamina >= 20) return '不调';

          return '绝不调';

        }

        getTrainerStatusClass(sanity, stamina) {

          if (sanity >= 80 && stamina >= 80) return 'status-excellent';

          if (sanity >= 60 && stamina >= 60) return 'status-good';

          if (sanity >= 40 && stamina >= 40) return 'status-normal';

          if (sanity >= 20 && stamina >= 20) return 'status-bad';

          return 'status-terrible';

        }

        getStaminaColor(stamina) {

          if (stamina >= 80) return 'linear-gradient(90deg, #10b981 0%, #34d399 100%)';

          if (stamina >= 60) return 'linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%)';

          if (stamina >= 40) return 'linear-gradient(90deg, #f97316 0%, #fb923c 100%)';

          if (stamina >= 20) return 'linear-gradient(90deg, #dc2626 0%, #ef4444 100%)';

          return 'linear-gradient(90deg, #7f1d1d 0%, #dc2626 100%)';

        }

        getSanityColor(sanity) {

          if (sanity >= 80) return 'linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%)';

          if (sanity >= 60) return 'linear-gradient(90deg, #8b5cf6 0%, #a78bfa 100%)';

          if (sanity >= 40) return 'linear-gradient(90deg, #ec4899 0%, #f472b6 100%)';

          if (sanity >= 20) return 'linear-gradient(90deg, #dc2626 0%, #ef4444 100%)';

          return 'linear-gradient(90deg, #7f1d1d 0%, #dc2626 100%)';

        }

        getUmaDescription(e, t, n) {

          return '被附身' === n

            ? '被某种力量控制着...'

            : '失踪' === n

              ? '不知去向...'

              : t >= 80

                ? '对你非常信任'

                : t >= 60

                  ? '对你比较友好'

                  : t >= 40

                    ? '对你有些戒备'

                    : t >= 20

                      ? '对你保持距离'

                      : '对你很陌生';

        }

        getUmaStatusClass(e) {

          switch (e) {

            case '正常':

            default:

              return 'normal';

            case '病娇':

              return 'yandere';

            case '被附身':

              return 'possessed';

            case '失踪':

              return 'missing';

          }

        }

        generateHeartIcons(e) {

          let t = '';

          console.log(`💖 生成心形图标，数量: ${e}`);

          const n = Math.max(1, Math.min(5, e));

          console.log(`💖 实际显示数量: ${n}`);

          for (let s = 0; s < n; s++) t += '<span class="heart">❤</span>';

          return (console.log(`💖 生成的心形HTML: ${t}`), t);

        }

        toggleItemDetails(e) {

          const t = document.getElementById(`item-details-${e}`),

            n = document.querySelector(`[data-item-index="${e}"] .item-toggle`);

          if (t && n) {

            if ('none' !== t.style.display) ((t.style.display = 'none'), (n.textContent = '▼'));

            else {

              const sound = document.getElementById('item-detail-sound');

              if (sound) {

                sound.currentTime = 0;

                sound.play().catch(err => console.log('音效播放失败:', err));

              }

              (t.style.display = 'block'),

              (n.textContent = '▲');

            }

          }

        }

        toggleRules(e) {

          const t = document.getElementById(`${e}-rules-content`),

            n = document.querySelector(`[onclick="window.teresenDebug.toggleRules('${e}')"] .rules-toggle`);

          if (t && n) {

            'none' !== t.style.display

              ? ((t.style.display = 'none'), (n.textContent = '▼'))

              : ((t.style.display = 'block'), (n.textContent = '▲'));

          }

        }

        toggleUmaSection() {

          const e = document.getElementById('uma-content'),

            t = document.querySelector('.uma-toggle');

          if (e && t) {

            'none' !== e.style.display

              ? ((e.style.display = 'none'), (t.textContent = '▼'))

              : ((e.style.display = 'block'), (t.textContent = '▲'));

          }

        }

        toggleProfile() {

          const e = document.getElementById('profile-basic'),

            t = document.getElementById('profile-detail');

          e &&

            t &&

            ('none' === t.style.display

              ? ((e.style.display = 'none'), (t.style.display = 'block'))

              : ((e.style.display = 'block'), (t.style.display = 'none')));

        }

        toggleJourney() {

          const e = document.getElementById('journey-basic'),

            t = document.getElementById('journey-detail');

          e &&

            t &&

            ('none' === t.style.display

              ? ((e.style.display = 'none'), (t.style.display = 'block'))

              : ((e.style.display = 'block'), (t.style.display = 'none')));

        }

        async handleSaveLoad() {

          try {

            console.log('💾 打开存档管理器...');

            this.openSaveManagerModal();

          } catch (e) {

            console.error('❌ 打开存档管理器失败:', e);

          }

        }

        toggleFullscreen() {

          const e = document.querySelector('.connected-panels'),

            t = document.getElementById('fullscreen-btn');

          e &&

            t &&

            (document.fullscreenElement

              ? document.exitFullscreen

                ? document.exitFullscreen()

                : document.webkitExitFullscreen

                  ? document.webkitExitFullscreen()

                  : document.mozCancelFullScreen

                    ? document.mozCancelFullScreen()

                    : document.msExitFullscreen && document.msExitFullscreen()

              : e.requestFullscreen

                ? e.requestFullscreen()

                : e.webkitRequestFullscreen

                  ? e.webkitRequestFullscreen()

                  : e.mozRequestFullScreen

                    ? e.mozRequestFullScreen()

                    : e.msRequestFullscreen && e.msRequestFullscreen());

        }

        handleFullscreenChange() {

          const e = document.querySelector('.connected-panels'),

            t = document.getElementById('fullscreen-btn');

          if (!e || !t) return;

          !!(

            document.fullscreenElement ||

            document.webkitFullscreenElement ||

            document.mozFullScreenElement ||

            document.msFullscreenElement

          )

            ? (e.classList.add('fullscreen-active'),

              (t.innerHTML =

                '\n        <svg class="icon" fill="currentColor" viewBox="0 0 20 20">\n          <path d="M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 11-1.414 1.414L5 6.414V8a1 1 0 01-2 0V4zm9 1a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-2 0V6.414l-2.293 2.293a1 1 0 11-1.414-1.414L13.586 5H12zm-9 7a1 1 0 012 0v1.586l2.293-2.293a1 1 0 111.414 1.414L6.414 15H8a1 1 0 010 2H4a1 1 0 01-1-1v-4zm13-1a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293a1 1 0 111.414-1.414L15 13.586V12a1 1 0 011-1z" />\n        </svg>\n        <span>退出全屏</span>\n      '),

              console.log('🖥️ 进入全屏模式'))

            : (e.classList.remove('fullscreen-active'),

              (t.innerHTML =

                '\n        <svg class="icon" fill="currentColor" viewBox="0 0 20 20">\n          <path d="M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 11-1.414 1.414L5 6.414V8a1 1 0 01-2 0V4zm9 1a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-2 0V6.414l-2.293 2.293a1 1 0 11-1.414-1.414L13.586 5H12zm-9 7a1 1 0 012 0v1.586l2.293-2.293a1 1 0 111.414 1.414L6.414 15H8a1 1 0 010 2H4a1 1 0 01-1-1v-4zm13-1a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293a1 1 0 111.414-1.414L15 13.586V12a1 1 0 011-1z" />\n        </svg>\n        <span>全屏</span>\n      '),

              console.log('🖥️ 退出全屏模式'));

        }

        async handleSave(e = 'local') {

          try {

            console.log(`💾 开始${'local' === e ? '本地' : '世界书'}存档...`);



            // 获取当前游戏状态

            const gameState = this.getAllVariables();

            const chatMessages = await getChatMessages(0);

            const currentMessage = chatMessages && chatMessages.length > 0 ? chatMessages[0].message : '';



            // 构建存档数据

            const saveData = {

              timestamp: Date.now(),

              saveName: `手动存档_${new Date().toLocaleString('zh-CN')}`,

              type: 'manual',

              data: {

                variables: gameState,

                message: currentMessage,

                chatHistory: await this.getChatHistory(),

                timestamp: Date.now(),

              },

            };



            if (e === 'local') {

              // 保存到本地

              localStorage.setItem('teresen-save', JSON.stringify(saveData));

              console.log('✅ 本地存档成功:', saveData);

              alert('本地存档成功！');

            } else {

              // 保存到世界书

              await this.saveToWorldbook(saveData);

              await this.saveJourneyToWorldbook();

              console.log('✅ 世界书存档成功');

              alert('世界书存档成功！');

            }



            // 关闭存档界面

            $('#load-modal').hide();

          } catch (error) {

            console.error('❌ 存档失败:', error);

            alert('存档失败！');

          }

        }

        async handleHistory() {

          try {

            // 播放人物历程音效
            const sound = document.getElementById('journey-history-sound');
            if (sound) {
              sound.currentTime = 0;
              sound.play().catch(e => console.log('播放人物历程音效失败:', e));
            }

            (console.log('📚 打开历史记录界面...'), $('#history-modal').show(), await this.updateHistoryModal());

          } catch (e) {

            console.error('❌ 打开历史记录界面失败:', e);

          }

        }

        handleDangerPeriod() {

          console.log('危险时段按钮被点击');

          
          // 播放危险时段翻页声音
          const sound = document.getElementById('danger-rules-sound');
          if (sound) {
            sound.currentTime = 0;
            sound.play().catch(e => console.log('音效播放失败:', e));
          }
          
          const e = this.getAllVariables(),

            t = this.getVariable(e, 'stat_data.世界.当前时间[0]', '06:00'),

            n = this.getTimeDangerLevel(t),

            s = this.getDangerLevelText(n),

            o = this.getDangerLevelDetails(n),

            a = document.createElement('div');

          ((a.className = 'danger-modal'),

            (a.innerHTML = `\n      <div class="danger-modal-content">\n        <div class="danger-modal-header">\n          <h3>【训练员时段生存指南】</h3>\n          <span class="danger-modal-close">&times;</span>\n        </div>\n        <div class="danger-modal-body">\n          <div class="danger-current-period">\n            <strong>当前时段：${s}</strong>\n          </div>\n          <div class="danger-details-content">\n            ${o}\n          </div>\n        </div>\n      </div>\n    `),

            document.body.appendChild(a));

          const l = a.querySelector('.danger-modal-close');

          (l &&

            l.addEventListener('click', () => {

              document.body.removeChild(a);

            }),

            a.addEventListener('click', e => {

              e.target === a && document.body.removeChild(a);

            }));

        }

        debugVariables() {

          console.log('🔍 调试变量按钮被点击');

          const e = this.getAllVariables();

          (console.log('📊 所有变量数据:', e),

            e && e.stat_data

              ? (console.log('✅ 找到stat_data结构'),

                console.log('🏃 训练员数据:', e.stat_data.训练员),

                console.log('🌍 世界数据:', e.stat_data.世界),

                console.log('🐎 马娘数据:', e.stat_data.马娘),

                e.stat_data.马娘 &&

                  (console.log('🔍 马娘数据详情:'),

                  Object.keys(e.stat_data.马娘).forEach(t => {

                    const n = e.stat_data.马娘[t];

                    (console.log(`🐎 ${t}:`, n),

                      n.好感度 && console.log(`  💖 ${t} 好感度:`, n.好感度),

                      n.独占度 && console.log(`  🔥 ${t} 独占度:`, n.独占度),

                      n.状态 && console.log(`  📊 ${t} 状态:`, n.状态));

                  })),

                e.stat_data.规则 && console.log('📜 规则数据:', e.stat_data.规则))

              : (console.warn('⚠️ 未找到stat_data结构'), console.log('🔍 完整返回结果:', e)),

            console.log('🎮 当前界面状态:'),

            console.log('  - 马娘容器:', document.getElementById('uma-status')),

            console.log('  - 时间显示:', document.getElementById('current-time')),

            console.log('  - 训练员状态:', document.getElementById('trainer-status')));

        }

        async handleActionSubmit() {

          const e = document.getElementById('action-input');

          if (!e || !e.value.trim()) return;

          const userMessage = e.value.trim();

          console.log('🎯 提交行动:', userMessage);



          try {

            // 1. 整合指令和用户输入

            let commandText = '';

            if (window.pendingActions && window.pendingActions.length > 0) {

              commandText += '[训练员道具行动指令]\n';
              commandText += '训练员准备执行以下道具相关行动：\n\n';
              window.pendingActions.forEach((cmd, index) => {

                let actionText = '';
                let actionDescription = '';
                switch (cmd.action) {
                  case 'use':
                    actionText = `使用道具 [${cmd.itemName}]`;
                    actionDescription = `训练员想要使用这个道具，请根据道具的效果和当前情况描述使用过程。`;
                    break;
                  case 'discard':
                    actionText = `丢弃道具 [${cmd.itemName}]`;
                    actionDescription = `训练员决定丢弃这个道具，请描述丢弃的过程和可能的影响。`;
                    break;
                  case 'gift':
                    actionText = `赠送道具 [${cmd.itemName}] 给 [${cmd.characterName || cmd.target}]`;
                    actionDescription = `训练员想要将这个道具赠送给目标角色，请描述赠送过程和对方的反应。`;
                    break;
                  case 'lock':
                    actionText = `锁定道具 [${cmd.itemName}]`;
                    actionDescription = `训练员想要锁定这个道具防止意外使用，请描述锁定过程。`;
                    break;
                  case 'skill':
                    const skillInfo = cmd.skillType ? `使用技能 [${cmd.skillType}]` : '使用技能';
                    const targetInfo = cmd.target === 'self' ? '对自己' : (cmd.characterName ? `对 ${cmd.characterName}` : '对目标');
                    actionText = `${skillInfo} ${targetInfo}`;
                    actionDescription = `训练员想要使用天赋技能，请根据技能类型和目标描述使用过程。`;
                    break;
                  default:
                    actionText = `执行操作 [${cmd.action}]`;
                    actionDescription = `训练员想要执行这个操作，请描述执行过程。`;
                }
                
                commandText += `行动${index + 1}: ${actionText}\n`;
                commandText += `说明: ${actionDescription}\n`;
                
                // 添加道具详细信息
                if (cmd.itemName && cmd.action !== 'skill') {
                  commandText += `道具名称: ${cmd.itemName}\n`;
                  if (cmd.itemData) {
                    commandText += `道具描述: ${cmd.itemData.描述 || '无描述'}\n`;
                    commandText += `道具效果: ${cmd.itemData.效果 || '无效果说明'}\n`;
                    commandText += `道具稀有度: ${cmd.itemData.稀有度 || '普通'}\n`;
                  }
                }
                
                // 添加技能详细信息
                if (cmd.action === 'skill' && cmd.skillType) {
                  commandText += `技能类型: ${cmd.skillType}\n`;
                  commandText += `大天赋: ${cmd.majorTalent || '未知'}\n`;
                  if (cmd.target) {
                    commandText += `使用目标: ${cmd.target === 'self' ? '自己' : cmd.characterName || '未指定'}\n`;
                  }
                }
                
                commandText += '\n';
              });
              
              commandText += '请根据以上指令详细描述训练员的行动过程，包括道具使用的具体效果、目标角色的反应、以及可能产生的影响。\n\n';

            }



            // 2. 构建合并内容

            let combinedContent = '';

            if (commandText) {

              combinedContent += commandText + '\n';

            }

            if (userMessage) {

              combinedContent += `<userinput>\n${userMessage}\n</userinput>`;

            }



            if (!combinedContent) {

              console.warn('⚠️ 没有内容可发送');

              return;

            }



            // 3. 保存用户输入，但不覆盖AI剧情内容

            // 我们只保存用户输入到变量中，等待AI回复后再更新消息

            this.lastUserInput = combinedContent;



            // 4. 用户输入后，等待AI回复



            // 5. 生成AI回复

            if ('undefined' != typeof TavernHelper && TavernHelper.generate) {

              const generateConfig = {

                injects: [

                  {

                    role: 'user',

                    content: combinedContent,

                    position: 'in_chat',

                    depth: 0,

                    should_scan: true,

                  },

                ],

                should_stream: true,

              };



              try {

                console.log('🚀 开始流式生成...');

                const aiResponse = await TavernHelper.generate(generateConfig);

                console.log('✅ AI生成完成:', aiResponse);



                // 6. 更新AI回复（参考项目模式）

                if ('function' == typeof getChatMessages) {

                  const chatMessages = await getChatMessages(0);

                  if (chatMessages && chatMessages.length > 0) {

                    const firstMessage = chatMessages[0];



                    // 保存当前的变量状态到消息的data字段

                    const currentVariables = this.getAllVariables();

                    firstMessage.data = currentVariables;



                    // 直接替换消息内容，只显示AI回复，不包含用户输入

                    firstMessage.message = aiResponse;



                    if ('undefined' != typeof TavernHelper && TavernHelper.setChatMessages) {

                      await TavernHelper.setChatMessages([firstMessage], { refresh: 'none' });

                      console.log('✅ 0层消息已更新为AI回复（参考项目模式，不刷新页面）');

                    }

                  }

                }



                // 7. 更新变量状态和界面
                let mvuSucceeded = false; // 移到外部，确保作用域正确

                // 诊断MVU环境
                this.debugMVUEnvironment();

                if ('function' == typeof window.eventEmit) {

                  const currentVariables = this.getAllVariables();

                  console.log('🔄 准备触发MVU更新事件...');

                  console.log('📊 当前变量数据:', currentVariables);

                  const updateScript = aiResponse;
                  const inputData = { 
                      old_variables: this.currentMvuState || currentVariables 
                  };
                  
                  try {
                      // 增加超时机制，防止 eventEmit 卡死
                      const mvuPromise = window.eventEmit('mag_invoke_mvu', updateScript, inputData);
                      const timeoutPromise = new Promise((_, reject) => 
                          setTimeout(() => reject(new Error('MVU event timeout')), 3000)
                      );
                      
                      await Promise.race([mvuPromise, timeoutPromise]);
                      console.log('✅ MVU调用成功，等待结果...');
                      
                      // 检查MVU是否返回新状态
                      if (inputData.new_variables) {
                          console.log('✅ MVU返回新状态:', inputData.new_variables);
                          this.currentMvuState = inputData.new_variables;
                          // 重新渲染UI
                          this.renderUI(this.currentMvuState.stat_data);
                          mvuSucceeded = true;
                      } else {
                          console.log('⚠️ MVU没有返回新状态');
                      }
                  } catch (error) {
                      console.error('❌ MVU调用失败:', error);
                  }

                  if (mvuSucceeded) {
                      console.log('✅ MVU更新成功，变量状态已更新');
                  } else {
                      console.log('⚠️ MVU更新失败，但继续执行后续逻辑');
                  }

                } else {

                  console.warn('⚠️ eventEmit函数不可用，无法触发MVU更新');

                  // 强制更新MVU数据

                  console.log('🔄 尝试强制更新MVU数据...');

                  try {

                    if (typeof window.mag_invoke_mvu === 'function') {

                      const currentVariables = this.getAllVariables();

                      window.mag_invoke_mvu(JSON.stringify(currentVariables));

                      console.log('✅ 通过window.mag_invoke_mvu强制更新成功');

                    } else {

                      console.warn('⚠️ window.mag_invoke_mvu函数也不可用');

                    }

                  } catch (error) {

                    console.error('❌ 强制更新MVU失败:', error);

                  }

                }



                // 8. 静默保存到第0层，实现同层游玩
                if (mvuSucceeded && this.currentMvuState) {
                    try {
                        let messages = await getChatMessages('0');
                        if (messages && messages.length > 0) {
                            const messageZero = messages[0];
                            
                            // 更新第0层消息，支持同层游玩
                            messageZero.message = aiResponse;
                            messageZero.data = this.currentMvuState;
                            
                            if ('undefined' != typeof TavernHelper && TavernHelper.setChatMessages) {
                                await TavernHelper.setChatMessages([messageZero], { refresh: 'none' });
                                console.log('✅ 已静默更新第0层消息，支持同层游玩');
                            }
                        } else {
                            console.warn('⚠️ 未找到第0层消息，无法更新');
                        }
                    } catch (e) {
                        console.warn('⚠️ 更新第0层消息失败:', e);
                    }
                }

                // 9. 清空指令队列

                if (window.pendingActions) {

                  window.pendingActions = [];

                  window.savePendingActions && window.savePendingActions();

                  window.updateActionIcons && window.updateActionIcons();

                }



                // 10. 自动存档AI回复

                try {

                  await this.autoSaveAfterAIResponse(aiResponse, combinedContent);

                } catch (saveError) {

                  console.warn('自动存档失败:', saveError);

                }



                // 11. 立即结束计时器

                this.endReplyTimer();

              } catch (error) {

                console.error('❌ AI生成失败:', error);

                this.endReplyTimer();

              } finally {
                // 最终修复：在所有操作完成后，主动、可靠地刷新UI，避免任何事件冲突
                try {
                    await this.updateDynamicData();
                    console.log('✅ 最终UI刷新完成');
                } catch (finalError) {
                    console.warn('⚠️ 最终UI刷新失败:', finalError);
                }
              }

            }



            // 界面已在AI回复后更新，这里不需要重复调用

          } catch (error) {

            console.error('❌ 交互失败:', error);

          } finally {

            // 参考项目模式：在所有操作完成后，主动、可靠地刷新UI

            await this.updateDynamicData();

            console.log('✅ 最终界面更新完成（参考项目模式）');

          }



          e.value = '';

        }

        setupRulesModal() {

          ($('#view-rules-btn').on('click', () => {

            console.log('🎯 查看规则按钮被点击！');

            const e = document.getElementById('rules-modal'),

              t = document.getElementById('danger-rules-sound');
            e && t

              ? (console.log('✅ 显示规则模态框'),

                t.play().catch(e => console.log('音效播放失败:', e)),

                (e.style.display = 'flex'),

                this.updateRulesModal())

              : console.error('❌ 模态框或音效元素未找到');

          }),

            $('#close-rules-btn').on('click', () => {

              $('#rules-modal').hide();

            }),

            $('#rules-modal').on('click', e => {

              e.target === e.currentTarget && $('#rules-modal').hide();

            }),

            // 音乐控制功能
            this.setupMusicControls(),
            
            // 规则记录功能事件绑定
            $('#add-rule-btn').on('click', () => {
              this.addRule();
            }),
            $('#clear-rules-btn').on('click', () => {
              this.clearAllRules();
            }));

        }















        setupConsoleCommands() {

          try {

            ((window.teresenDebug = {

              showAllVariables: () => this.showAllVariables(),

              showTrainerStatus: () => this.showTrainerStatus(),

              showUmaStatus: () => this.showUmaStatus(),

              showWorldInfo: () => this.showWorldInfo(),

              showRules: () => this.showRules(),

              help: () => this.showConsoleHelp(),

              toggleItemDetails: e => this.toggleItemDetails(e),

              toggleRules: e => this.toggleRules(e),

              toggleUmaSection: () => this.toggleUmaSection(),

              checkCrystals: () => this.checkCrystals(),

              // 新天赋系统

              showTalentsModal: () => this.showTalentsModal(),

              switchTalentPage: page => this.switchTalentPage(page),

              prevTalentPage: () => this.prevTalentPage(),

              nextTalentPage: () => this.nextTalentPage(),

              selectTalentOption: (level, optionIndex) => this.selectTalentOption(level, optionIndex),

              testMvuInjection: () => this.testMvuInjection(),

              checkMvuStatus: () => this.checkMvuStatus(),

              showItemPopup: (e, t) => this.showItemPopup(e, t),

              loadLocalSave: () => this.loadLocalSave(),

              loadWorldbookSave: e => this.loadWorldbookSave(e),

              loadAutoSave: e => this.loadAutoSave(e),

              triggerQTE: e => this.triggerQTE(e),

              updateQTESection: () => this.updateQTESection(),

              manualCheckQTE: () => this.manualCheckQTE(),

              startReplyTiming: () => this.startReplyTiming(),

              endReplyTimer: () => this.endReplyTimer(),

              debugSaves: () => this.debugSaves(),

              debugCommands: () => this.debugCommands(),

              debugAutoSaves: () => this.debugAutoSaves(),

              // 规则记录功能
              addRule: (index) => this.addRule(),
              editRule: (index) => this.editRule(index),
              deleteRule: (index) => this.deleteRule(index),
              clearAllRules: () => this.clearAllRules(),
              getUserRules: () => this.getUserRules(),
              
              // 马娘记名册功能
              openUmaRoster: () => this.openUmaRoster(),
              addUmaToRoster: (umaName) => this.addUmaToRoster(umaName),
              getUmaRoster: () => this.getUmaRoster(),
              
              // 状态判定动画系统
              checkStatusTriggers: () => this.checkStatusTriggers(),
              triggerStatusAnimation: (stamina, sanity) => this.triggerStatusAnimation(stamina, sanity),
              
              // 塔罗占卜系统通过TarotDivinationSystem类自动绑定，无需额外接口
              
              // 测试功能
              testTarotDivination: () => this.testTarotDivination(),
            }),

              console.log('🎮 特雷森学院怪谈调试命令已加载！'),

              console.log('💡 输入 teresenDebug.help() 查看所有可用命令'),

              console.log('🔍 调试对象:', window.teresenDebug));

          } catch (e) {

            console.error('❌ 设置控制台命令时出错:', e);

          }

        }



        showAllVariables() {

          const e = this.getAllVariables();

          (console.group('📊 所有变量信息'),

            console.log('完整变量对象:', e),

            e.stat_data

              ? (console.group('🏃 训练员信息'),

                console.table(e.stat_data.训练员),

                console.groupEnd(),

                console.group('🌍 世界信息'),

                console.table(e.stat_data.世界),

                console.groupEnd(),

                console.group('🐎 赛马娘信息'),

                console.table(e.stat_data.马娘),

                console.groupEnd(),

                e.stat_data.规则 && (console.group('📜 规则信息'), console.table(e.stat_data.规则), console.groupEnd()),

                e.stat_data.外神 && (console.group('👹 外神信息'), console.table(e.stat_data.外神), console.groupEnd()))

              : console.warn('⚠️ 未找到stat_data结构'),

            console.groupEnd());

        }

        showTrainerStatus() {

          var e;

          const t = this.getAllVariables();

          (console.group('🏃 训练员状态详情'),

            (null == (e = t.stat_data) ? void 0 : e.训练员)

              ? (t.stat_data.训练员,

                console.log('体力:', this.getVariable(t, 'stat_data.训练员.体力[0]', 'N/A')),

                console.log('理智:', this.getVariable(t, 'stat_data.训练员.理智[0]', 'N/A')),

                console.log('运气:', this.getVariable(t, 'stat_data.训练员.运气[0]', 'N/A')),

                console.log('位置:', this.getVariable(t, 'stat_data.训练员.位置[0]', 'N/A')),

                console.log('在校天数:', this.getVariable(t, 'stat_data.训练员.在校天数[0]', 'N/A')),

                console.log('物品栏:', this.getVariable(t, 'stat_data.训练员.物品栏[0]', 'N/A')))

              : console.warn('⚠️ 未找到训练员数据'),

            console.groupEnd());

        }

        showUmaStatus() {

          const e = this.getAllVariables();

          console.group('🐎 赛马娘状态详情');

          (['东海帝王', '爱如往昔', '特别周', '无声铃鹿', '福来', '爱丽速子'].forEach(t => {

            console.group(`${t} 状态`);

            const n = this.getVariable(e, `stat_data.马娘.${t}.好感度[0]`, 'N/A'),

              s = this.getVariable(e, `stat_data.马娘.${t}.状态[0]`, 'N/A');

            (console.log('好感度:', n),

              console.log('状态:', s),

              console.log('描述:', this.getUmaDescription(t, Number(n) || 0, s)),

              console.groupEnd());

          }),

            console.groupEnd());

        }

        showWorldInfo() {

          var e;

          const t = this.getAllVariables();

          (console.group('🌍 世界信息详情'),

            (null == (e = t.stat_data) ? void 0 : e.世界)

              ? (console.log('当前时间:', this.getVariable(t, 'stat_data.世界.当前时间[0]', 'N/A')),

                console.log('当前日期:', this.getVariable(t, 'stat_data.世界.当前日期[0]', 'N/A')),

                console.log('当前正文:', this.getVariable(t, 'stat_data.世界.当前正文[0]', 'N/A')),

                console.log('禁忌规则:', this.getVariable(t, 'stat_data.世界.禁忌规则[0]', 'N/A')))

              : console.warn('⚠️ 未找到世界数据'),

            console.groupEnd());

        }

        // 马娘记名册功能实现
        openUmaRoster() {
          if (window.umaRosterSystem) {
            window.umaRosterSystem.openUmaRoster();
          } else {
            console.error('马娘记名册系统未初始化');
          }
        }

        addUmaToRoster(umaName, details = {}) {
          if (window.umaRosterSystem) {
            return window.umaRosterSystem.addUmaToRoster(umaName, details);
          } else {
            console.error('马娘记名册系统未初始化');
            return false;
          }
        }

        getUmaRoster() {
          if (window.umaRosterSystem) {
            return window.umaRosterSystem.getUmaRoster();
          } else {
            console.error('马娘记名册系统未初始化');
            return {};
          }
        }

        showRules() {

          var e;

          const t = this.getAllVariables();

          if ((console.group('📜 规则信息详情'), null == (e = t.stat_data) ? void 0 : e.规则)) {

            console.group('固定规则');

            const e = this.getVariable(t, 'stat_data.规则.固定规则[0]', []);

            (Array.isArray(e) &&

              e.forEach((e, t) => {

                console.log(`${t + 1}. ${e}`);

              }),

              console.groupEnd(),

              console.group('随机规则'));

            const n = this.getVariable(t, 'stat_data.规则.随机规则[0]', []);

            (Array.isArray(n) &&

              n.forEach((e, t) => {

                console.log(`${t + 1}. ${e}`);

              }),

              console.groupEnd(),

              console.log('违反次数:', this.getVariable(t, 'stat_data.规则.违反次数[0]', 'N/A')));

          } else console.warn('⚠️ 未找到规则数据');

          console.groupEnd();

        }

        updateLocation() {}

        updateGachaCoin() {

          const e = this.getAllVariables(),

            t = this.getVariable(e, 'stat_data.训练员.扭蛋币[0]', 0),

            n = document.getElementById('gacha-coin-text');

          n && (n.textContent = `扭蛋币: ${t}`);

        }




        updateJourneyModal() {

          const e = this.getAllVariables(),

            t = this.getVariable(e, 'stat_data.训练员.历程', []),

            n = document.getElementById('journey-list-modal');

          if (n)

            if (Array.isArray(t) && t.length > 0) {

              let e = '';

              (t.forEach((t, n) => {

                e += `\n            <div class="journey-entry">\n              <div class="journey-header">\n                <span class="journey-day">第${t.天数 || n + 1}天</span>\n                <span class="journey-status ${t.状态 || 'normal'}">${t.状态 || '正常'}</span>\n              </div>\n              <div class="journey-event">${t.事件 || '未知事件'}</div>\n              <div class="journey-desc">${t.描述 || '暂无描述'}</div>\n            </div>\n          `;

              }),

                (n.innerHTML = e));

            } else n.innerHTML = '<div class="empty-inventory">暂无历程记录</div>';

        }

        setupLoadModal() {

          ($('#close-load-btn').on('click', () => {

            $('#load-modal').hide();

          }),

            $('#load-modal').on('click', e => {

              e.target === e.currentTarget && $('#load-modal').hide();

            }));

        }

        setupHistoryModal() {

          ($('#close-history-btn').on('click', () => {

            $('#history-modal').hide();

          }),

            $('#history-modal').on('click', e => {

              e.target === e.currentTarget && $('#history-modal').hide();

            }));

        }

        async updateLoadModal() {

          try {

            console.log('💾 更新存档界面...');



            const localSavesList = document.getElementById('local-saves-list');

            const worldbookSavesList = document.getElementById('worldbook-saves-list');



            // 1. 更新本地存档列表

            if (localSavesList) {

              let localSaveHtml = '';



              // 显示手动本地存档

              const localSave = localStorage.getItem('teresen-save');

              if (localSave) {

                try {

                  const saveData = JSON.parse(localSave);

                  localSaveHtml += `

                    <div class="save-item manual-save-item" onclick="window.teresenDebug.loadLocalSave()">

                      <div class="save-name">${saveData.saveName || '本地存档'}</div>

                      <div class="save-time">${new Date(saveData.timestamp).toLocaleString('zh-CN')}</div>

                      <div class="save-type">手动存档</div>

                    </div>

                  `;

                } catch (error) {

                  console.warn('解析本地存档失败:', error);

                }

              }



              // 显示自动存档

              const autoSaves = this.getAutoSaves();

              console.log('找到自动存档:', autoSaves.length, '个');

              if (autoSaves.length > 0) {

                autoSaves.forEach(save => {

                  // 提取<content></content>标签内的内容作为显示文本

                  let displayContent = '自动存档';

                  if (save.data.message_content) {

                    const contentMatch = save.data.message_content.match(/<content>(.*?)<\/content>/s);

                    if (contentMatch) {

                      displayContent =

                        contentMatch[1].trim().substring(0, 50) + (contentMatch[1].length > 50 ? '...' : '');

                    } else {

                      displayContent =

                        save.data.message_content.substring(0, 50) +

                        (save.data.message_content.length > 50 ? '...' : '');

                    }

                  }



                  localSaveHtml += `

                    <div class="save-item auto-save-item" onclick="window.teresenDebug.loadAutoSave('${save.key}')">

                      <div class="save-name">${save.data.save_name || '自动存档'}</div>

                      <div class="save-content">${displayContent}</div>

                      <div class="save-time">${new Date(save.data.timestamp).toLocaleString('zh-CN')}</div>

                      <div class="save-type">自动存档</div>

                    </div>

                  `;

                });

              }



              localSavesList.innerHTML = localSaveHtml || '<div class="empty-save">暂无本地存档</div>';

              console.log('本地存档列表已更新');

            }



            // 2. 更新世界书存档列表

            if (worldbookSavesList) {

              const worldbookEntries = await this.getWorldbookEntries();

              let worldbookHtml = '';



              if (worldbookEntries && worldbookEntries.length > 0) {

                worldbookEntries.forEach(entry => {

                  if (entry.title && entry.title.includes('存档')) {

                    worldbookHtml += `

                      <div class="save-item worldbook-save-item" onclick="window.teresenDebug.loadWorldbookSave('${entry.title}')">

                        <div class="save-name">${entry.title}</div>

                        <div class="save-time">${entry.content ? new Date(entry.content).toLocaleString('zh-CN') : '未知时间'}</div>

                        <div class="save-type">世界书存档</div>

                      </div>

                    `;

                  }

                });

              }



              worldbookSavesList.innerHTML = worldbookHtml || '<div class="empty-save">暂无世界书存档</div>';

              console.log('世界书存档列表已更新');

            }



            // 3. 设置存档按钮（只设置一次）

            this.setupSaveButtons();

          } catch (error) {

            console.error('❌ 更新存档界面失败:', error);

          }

        }



        // 设置存档按钮（避免重复创建）

        setupSaveButtons() {

          try {

            // 检查是否已经存在按钮

            const existingButtons = document.querySelectorAll('.save-button');

            if (existingButtons.length > 0) {

              console.log('存档按钮已存在，跳过创建');

              return;

            }



            const loadSection = document.querySelector('.load-section');

            if (!loadSection) {

              console.warn('未找到存档区域');

              return;

            }



            // 创建本地存档按钮

            const localSaveBtn = document.createElement('button');

            localSaveBtn.className = 'save-button subtle-hover';

            localSaveBtn.innerHTML = `

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6h-1v5.586l-2.293-2.293z" />

              </svg>

              <span>保存到本地</span>

            `;

            localSaveBtn.onclick = () => this.handleSave('local');



            // 创建世界书存档按钮

            const worldbookSaveBtn = document.createElement('button');

            worldbookSaveBtn.className = 'save-button subtle-hover';

            worldbookSaveBtn.innerHTML = `

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6h-1v5.586l-2.293-2.293z" />

              </svg>

              <span>保存到世界书</span>

            `;

            worldbookSaveBtn.onclick = () => this.handleSave('worldbook');



            // 创建按钮容器

            const buttonContainer = document.createElement('div');

            buttonContainer.style.cssText = 'margin-top: 1rem; display: flex; gap: 0.5rem;';

            buttonContainer.appendChild(localSaveBtn);

            buttonContainer.appendChild(worldbookSaveBtn);



            loadSection.appendChild(buttonContainer);

            console.log('存档按钮已创建');

          } catch (error) {

            console.error('设置存档按钮失败:', error);

          }

        }

        async updateHistoryModal() {

          try {

            const e = document.getElementById('current-journey-list');

            if (e) {

              const t = await this.getWorldbookEntries();

              let n = '';

              (t &&

                t.length > 0 &&

                t.forEach(e => {

                  if (e.title && e.title.includes('个人历程'))

                    try {

                      const t = JSON.parse(e.content || '[]');

                      Array.isArray(t) &&

                        t.forEach((e, t) => {

                          n += `\n                      <div class="journey-entry">\n                        <div class="journey-header">\n                          <span class="journey-day">第${e.天数 || t + 1}天</span>\n                          <span class="journey-status ${e.状态 || 'normal'}">${e.状态 || '正常'}</span>\n                        </div>\n                        <div class="journey-event">${e.事件 || '未知事件'}</div>\n                        <div class="journey-desc">${e.描述 || '暂无描述'}</div>\n                      </div>\n                    `;

                        });

                    } catch (t) {

                      console.warn('解析个人历程数据失败:', t);

                    }

                }),

                (e.innerHTML = n || '<div class="empty-journey">暂无人物历程</div>'));

            }

          } catch (e) {

            console.error('❌ 更新历史记录界面失败:', e);

          }

        }

        async saveToWorldbook(e) {

          try {

            if ('undefined' != typeof TavernHelper && TavernHelper.createLorebookEntries) {

              const t = {

                title: e.saveName,

                content: e.timestamp,

                category: '存档',

                keywords: ['存档', '特雷森', '训练员'],

                force_activation: !1,

                selective: !1,

                display_index: 0,

                probability: 100,

                exclude_recursion: !1,

                use_extra: !1,

                extra: JSON.stringify(e),

              };

              (await TavernHelper.createLorebookEntries([t]), console.log('✅ 存档已保存到世界书'));

            }

          } catch (t) {

            console.error('❌ 保存到世界书失败:', t);

          }

        }

        async saveJourneyToWorldbook() {

          try {

            const e = this.getAllVariables(),

              t = this.getVariable(e, 'stat_data.训练员.历程', []);

            if (

              Array.isArray(t) &&

              t.length > 0 &&

              'undefined' != typeof TavernHelper &&

              TavernHelper.createLorebookEntries

            ) {

              const e = {

                title: '个人历程',

                content: JSON.stringify(t),

                category: '历程',

                keywords: ['历程', '特雷森', '训练员', '个人历程'],

                force_activation: !1,

                selective: !1,

                display_index: 0,

                probability: 100,

                exclude_recursion: !1,

                use_extra: !1,

                extra: '',

              };

              (await TavernHelper.createLorebookEntries([e]), console.log('✅ 本世历程已保存到世界书'));

            }

          } catch (e) {

            console.error('❌ 保存本世历程到世界书失败:', e);

          }

        }

        async getWorldbookEntries() {

          try {

            return 'undefined' != typeof TavernHelper && TavernHelper.getLorebookEntries

              ? await TavernHelper.getLorebookEntries()

              : [];

          } catch (e) {

            return (console.error('❌ 获取世界书条目失败:', e), []);

          }

        }

        async loadLocalSave() {

          try {

            console.log('📂 加载本地存档...');

            const saveData = localStorage.getItem('teresen-save');

            if (!saveData) {

              throw new Error('本地存档不存在');

            }



            const save = JSON.parse(saveData);

            console.log('本地存档数据:', save);



            // 恢复游戏状态

            if (save.data && save.data.variables && 'function' == typeof eventEmit) {

              // 直接设置变量，不调用MVU
              this.currentMvuState = save.data.variables;
              this.renderUI(this.currentMvuState.stat_data);

              console.log('✅ 游戏状态已恢复');

            }



            // 恢复聊天历史

            if (

              save.data &&

              save.data.message &&

              'function' == typeof getChatMessages &&

              'undefined' != typeof TavernHelper &&

              TavernHelper.setChatMessages

            ) {

              const chatMessages = await getChatMessages(0);

              if (chatMessages && chatMessages.length > 0) {

                chatMessages[0].message = save.data.message;

                await TavernHelper.setChatMessages([chatMessages[0]], { refresh: 'none' });

                console.log('✅ 聊天历史已恢复');

              }

            }



            await this.updateInterface();

            $('#load-modal').hide();

            console.log('✅ 本地存档加载成功');

            alert('本地存档加载成功！');

          } catch (error) {

            console.error('❌ 读取本地存档失败:', error);

            alert('读取存档失败！');

          }

        }

        async loadWorldbookSave(e) {

          try {

            const t = (await this.getWorldbookEntries()).find(t => t.title === e);

            if (t && t.extra) {

              const e = JSON.parse(t.extra);

              (await this.loadSaveData(e), $('#load-modal').hide());

            }

          } catch (t) {

            (console.error('❌ 读取世界书存档失败:', t), alert('读取存档失败！'));

          }

        }

        async loadSaveData(e) {

          try {

            if (

              (e.variables &&

                'function' == typeof eventEmit &&

                (eventEmit('mag_invoke_mvu'), console.log('✅ MVU变量已更新')),

              e.message && 'function' == typeof getChatMessages)

            ) {

              const t = await getChatMessages(0);

              t &&

                t.length > 0 &&

                ((t[0].message = e.message),

                'undefined' != typeof TavernHelper &&

                  TavernHelper.setChatMessages &&

                  (await TavernHelper.setChatMessages([t[0]], { refresh: 'none' }), console.log('✅ 0层消息已更新')));

            }

            (await this.updateInterface(), console.log('✅ 存档加载成功'), alert('存档加载成功！'));

          } catch (t) {

            (console.error('❌ 加载存档数据失败:', t), alert('加载存档失败！'));

          }

        }



        // 新增：AI回复后自动存档

        async autoSaveAfterAIResponse(aiResponse, userInput) {

          try {

            console.log('💾 开始自动存档AI回复...');



            const currentVariables = this.getAllVariables();

            const chatMessages = await getChatMessages(0);

            const currentMessage = chatMessages && chatMessages.length > 0 ? chatMessages[0].message : '';



            const timestamp = Date.now();

            const saveData = {

              timestamp: timestamp,

              save_name: `自动存档_${new Date().toLocaleString('zh-CN')}`,

              mvu_data: currentVariables,

              message_content: currentMessage,

              type: 'auto',

            };



            // 使用时间戳作为key，保存多个自动存档

            const saveKey = `teresen-auto-save-${timestamp}`;

            localStorage.setItem(saveKey, JSON.stringify(saveData));



            // 同时保存最新的自动存档引用

            localStorage.setItem('teresen_auto_save', JSON.stringify(saveData));

            console.log('✅ 自动存档成功');



            // 显示自动存档通知

            this.showAutoSaveNotification();



            // 清理旧的自动存档（保留最新的10个）

            this.cleanupOldAutoSaves();



            // 保存最后发送的指令，用于重新生成

            this.lastSentPrompt = userInput;

            // 马娘AI检测功能已移除

          } catch (error) {

            console.error('❌ 自动存档失败:', error);

            throw error;

          }

        }



        // 清理旧的自动存档

        cleanupOldAutoSaves() {

          try {

            console.log('🧹 开始清理旧自动存档...');

            const autoSaveKeys = [];

            for (let i = 0; i < localStorage.length; i++) {

              const key = localStorage.key(i);

              if (key && key.startsWith('teresen-auto-save-')) {

                autoSaveKeys.push(key);

              }

            }



            console.log(`📊 找到 ${autoSaveKeys.length} 个自动存档`);



            // 只有当存档数量超过15个时才清理

            if (autoSaveKeys.length > 15) {

              // 按时间戳排序，保留最新的10个

              autoSaveKeys.sort().reverse();

              const keysToRemove = autoSaveKeys.slice(10);



              console.log(`🗑️ 需要清理 ${keysToRemove.length} 个旧存档`);

              keysToRemove.forEach(key => {

                localStorage.removeItem(key);

                console.log('🗑️ 清理旧自动存档:', key);

              });

            } else {

              console.log('✅ 自动存档数量正常，无需清理');

            }

          } catch (error) {

            console.warn('清理旧自动存档失败:', error);

          }

        }



        // 显示自动存档通知

        showAutoSaveNotification() {

          try {

            // 创建通知元素

            const notification = document.createElement('div');

            notification.id = 'auto-save-notification';

            notification.innerHTML = '💾 E宝已为您自动存档';

            notification.style.cssText = `

              position: fixed;

              top: 20px;

              right: 20px;

              background: rgba(34, 197, 94, 0.9);

              color: white;

              padding: 8px 16px;

              border-radius: 6px;

              font-size: 12px;

              font-weight: bold;

              z-index: 10000;

              opacity: 0;

              transform: translateX(100%);

              transition: all 0.3s ease;

              pointer-events: none;

            `;



            document.body.appendChild(notification);



            // 显示动画

            setTimeout(() => {

              notification.style.opacity = '1';

              notification.style.transform = 'translateX(0)';

            }, 100);



            // 3秒后隐藏

            setTimeout(() => {

              notification.style.opacity = '0';

              notification.style.transform = 'translateX(100%)';

              setTimeout(() => {

                if (notification.parentNode) {

                  notification.parentNode.removeChild(notification);

                }

              }, 300);

            }, 3000);

          } catch (error) {

            console.warn('显示自动存档通知失败:', error);

          }

        }



        // 检测AI回复中的马娘名字
        detectUmaInAIResponse(aiResponse) {
          try {
            console.log('🔍 开始检测AI回复中的马娘名字...');
            
            // 马娘名字列表
            const umaNames = [
              '东海帝王', '爱如往昔', '特别周', '无声铃鹿', '福来', '爱丽速子',
              '目白光明', '目白麦昆', '目白善信', '目白多伯', '目白赖恩',
              '小栗帽', '玉藻十字', '超级小海湾', '樱花进王', '胜利奖券',
              '成田白仁', '琵琶晨光', '重炮', '曼城茶座', '好歌剧',
              '爱丽数码', '空中神宫', '星云天空', '草上飞', '神鹰',
              '名将怒涛', '目白雷恩', '目白阿尔丹', '目白高峰',
              '大和赤骥', '伏特加', '大拓太阳神', '黄金船', '黄金城市',
              '中山庆典', '中山光辉', '中山骑士', '中山英雄',
              '美浦波旁', '米浴', '春丽', '乌拉拉', '待兼福来',
              '待兼诗歌剧', '待兼史宾沙', '待兼史宾沙二世',
              '待兼史宾沙三世', '待兼史宾沙四世', '待兼史宾沙五世'
            ];
            
            // 检测AI回复中是否包含马娘名字
            const detectedUmas = [];
            umaNames.forEach(umaName => {
              if (aiResponse.includes(umaName)) {
                detectedUmas.push(umaName);
                console.log(`🐎 检测到马娘: ${umaName}`);
              }
            });
            
            // 将检测到的马娘添加到记名册
            if (detectedUmas.length > 0) {
              detectedUmas.forEach(umaName => {
                if (window.teresenDebug && window.teresenDebug.addUmaToRoster) {
                  window.teresenDebug.addUmaToRoster(umaName, {
                    notes: `在AI回复中检测到: ${new Date().toLocaleString('zh-CN')}`
                  });
                }
              });
              console.log(`📖 已将 ${detectedUmas.length} 个马娘添加到记名册`);
            } else {
              console.log('🔍 未检测到马娘名字');
            }
            
          } catch (error) {
            console.error('检测马娘名字失败:', error);
          }
        }

        // 获取聊天历史

        async getChatHistory() {

          try {

            if ('function' == typeof getChatMessages) {

              const messages = await getChatMessages(0);

              return messages || [];

            }

            return [];

          } catch (error) {

            console.warn('获取聊天历史失败:', error);

            return [];

          }

        }



        // 前端检测QTE功能

        updateQTESection() {

          try {

            // 前端检测QTE触发条件

            const shouldShowQTE = this.detectQTECondition();



            const qteSection = document.getElementById('qte-section');

            if (!qteSection) {

              console.warn('❌ 找不到QTE区域元素');

              return;

            }



            if (shouldShowQTE) {

              // 显示QTE区域

              qteSection.style.display = 'block';



              // 更新描述文本

              const description = qteSection.querySelector('.qte-description');

              if (description) {

                description.textContent = '你被马娘束缚了！选择你的行动...';

              }



              console.log('🎮 QTE区域已显示（前端检测）');

            } else {

              // 隐藏QTE区域

              qteSection.style.display = 'none';

              console.log('🎮 QTE区域已隐藏');

            }

          } catch (error) {

            console.error('❌ 更新QTE区域失败:', error);

          }

        }



        // 检测QTE触发条件

        detectQTECondition() {

          try {

            // 检查AI回复内容

            const aiText = this.getLastAIText();

            console.log('🔍 获取到的AI文本:', aiText ? aiText.substring(0, 100) + '...' : '空文本');



            if (aiText && this.containsBindingKeywords(aiText)) {

              console.log('🔍 检测到束缚关键词，触发QTE');

              return true;

            } else {

              console.log('🔍 未检测到束缚关键词，不触发QTE');

            }



            return false;

          } catch (error) {

            console.error('❌ 检测QTE条件失败:', error);

            return false;

          }

        }



        // 获取最后一条AI回复文本

        getLastAIText() {

          try {

            // 方法1：通过TavernHelper API

            if (typeof TavernHelper !== 'undefined' && TavernHelper.getChatMessages) {

              const messages = TavernHelper.getChatMessages();

              const aiMessages = messages.filter(msg => msg.role === 'assistant');

              const lastMessage = aiMessages[aiMessages.length - 1];

              if (lastMessage && lastMessage.content) {

                console.log('🔍 获取AI文本成功，长度:', lastMessage.content.length);

                return lastMessage.content;

              }

            }



            // 方法2：通过DOM元素查找

            const aiResponseElements = document.querySelectorAll('.mes_text, .mes_text_ai, .ai-response');

            if (aiResponseElements.length > 0) {

              const lastElement = aiResponseElements[aiResponseElements.length - 1];

              const text = lastElement.textContent || lastElement.innerText || '';

              console.log('🔍 获取AI文本成功，长度:', text.length);

              return text;

            }



            // 方法3：通过聊天容器查找

            const chatContainer = document.querySelector('#chat_container, .chat-container');

            if (chatContainer) {

              const aiMessages = chatContainer.querySelectorAll('.mes_text, .mes_text_ai');

              if (aiMessages.length > 0) {

                const lastMessage = aiMessages[aiMessages.length - 1];

                const text = lastMessage.textContent || lastMessage.innerText || '';

                console.log('🔍 获取AI文本成功，长度:', text.length);

                return text;

              }

            }



            console.log('🔍 获取AI文本失败');

            return '';

          } catch (error) {

            console.warn('获取AI文本失败:', error);

            return '';

          }

        }



        // 手动检测QTE（用于调试）

        manualCheckQTE() {

          console.log('🔍 手动检测QTE...');

          this.checkQTEFromCurrentContent();

        }



        // 直接从当前页面内容检测QTE

        checkQTEFromCurrentContent() {

          try {

            // 获取当前页面的AI回复内容

            const aiContent =

              $('#chat_container .mes_text_ai').last().text() ||

              $('#chat_container .mes_text').last().text() ||

              $('.ai-response').last().text() ||

              '';



            console.log('🔍 当前AI内容长度:', aiContent.length);



            if (aiContent && this.containsBindingKeywords(aiContent)) {

              console.log('🔍 检测到束缚关键词，显示QTE');

              $('#qte-section').show();

              $('#qte-section .qte-description').text('你被马娘束缚了！选择你的行动...');

            } else {

              console.log('🔍 未检测到束缚关键词，隐藏QTE');

              $('#qte-section').hide();

            }

          } catch (error) {

            console.error('❌ 检测QTE失败:', error);

          }

        }



        // 检查是否包含束缚关键词

        containsBindingKeywords(text) {

          const keywords = [

            // 基础束缚词汇

            '束缚',

            '抱住',

            '抓住',

            '搂住',

            '紧抱',

            '困住',

            '压制',

            '笼罩',

            '禁锢',

            '锁住',

            '侵占',

            '强硬',

            '堵住',

            '围住',

            '圈住',

            '缠住',

            '绑住',

            '按住',

            '压住',

            '扣住',

            '夹住',

            '卡住',

            '卡在',

            '陷在',

            '困在',



            // 直接针对训练员的词汇

            '把你压在',

            '不容反抗',

            '无法挣脱',

            '把你困住',

            '把你压制',

            '紧紧抱住',

            '把你抱住',

            '搂住你',

            '抓住你',

            '困住你',

            '压制你',

            '把你锁住',

            '把你侵占',

            '把你围住',

            '把你圈住',

            '把你缠住',

            '把你绑住',

            '把你按住',

            '把你压住',

            '把你扣住',

            '把你夹住',



            // 动作描述词汇

            '扑向你',

            '扑倒你',

            '扑在你',

            '压在你',

            '压向你',

            '压住你',

            '抱住你',

            '搂住你',

            '抓住你',

            '困住你',

            '压制你',

            '锁住你',

            '侵占你',

            '围住你',

            '圈住你',

            '缠住你',

            '绑住你',

            '按住你',

            '扣住你',

            '夹住你',

            '卡住你',

            '陷住你',

            '困住你',

            '压住你',



            // 状态描述词汇

            '动弹不得',

            '无法移动',

            '无法挣脱',

            '无法反抗',

            '无法逃脱',

            '无法摆脱',

            '无法离开',

            '无法脱身',

            '无法脱逃',

            '无法脱困',

            '无法脱出',

            '无法脱开',

            '无法脱掉',

            '无法脱下',

            '无法脱下',



            // 强度描述词汇

            '死死',

            '紧紧',

            '牢牢',

            '牢牢地',

            '死死地',

            '紧紧地',

            '死死抱住',

            '紧紧抱住',

            '牢牢抱住',

            '死死抓住',

            '紧紧抓住',

            '牢牢抓住',

            '死死困住',

            '紧紧困住',

            '牢牢困住',

            '死死压制',

            '紧紧压制',

            '牢牢压制',

            '死死锁住',

            '紧紧锁住',

            '牢牢锁住',



            // 情感色彩词汇

            '不容反抗',

            '不容拒绝',

            '不容逃脱',

            '不容离开',

            '不容脱身',

            '强迫',

            '强制',

            '强迫你',

            '强制你',

            '逼迫',

            '逼迫你',

            '威胁',

            '威胁你',

            '恐吓',

            '恐吓你',

            '威逼',

            '威逼你',



            // 特殊场景词汇

            '壁咚',

            '壁咚你',

            '把你壁咚',

            '壁咚在墙上',

            '把你壁咚在墙上',

            '推倒',

            '推倒你',

            '把你推倒',

            '推倒在',

            '把你推倒在',

            '压倒',

            '压倒你',

            '把你压倒',

            '压倒在地上',

            '把你压倒在地上',



            // 马娘特有词汇

            '马娘的力量',

            '赛马娘的力量',

            '马娘的力气',

            '赛马娘的力气',

            '马娘的拥抱',

            '赛马娘的拥抱',

            '马娘的怀抱',

            '赛马娘的怀抱',

            '马娘的束缚',

            '赛马娘的束缚',

            '马娘的压制',

            '赛马娘的压制',



            // 身体部位词汇

            '把你压在身下',

            '把你压在下面',

            '把你压在身下',

            '把你压在身下',

            '把你抱在怀里',

            '把你搂在怀里',

            '把你困在怀里',

            '把你锁在怀里',

            '把你压在墙上',

            '把你困在墙上',

            '把你锁在墙上',

            '把你压在门上',

            '把你困在门上',

            '把你锁在门上',

            '把你压在床上',

            '把你困在床上',

            '把你锁在床上',

            '把你压在沙发上',

            '把你困在沙发上',

            '把你锁在沙发上',



            // 时间持续词汇

            '一直',

            '一直抱着',

            '一直搂着',

            '一直抓着',

            '一直困着',

            '一直压着',

            '一直锁着',

            '一直按着',

            '一直扣着',

            '一直夹着',

            '持续',

            '持续抱着',

            '持续搂着',

            '持续抓着',

            '持续困着',

            '持续压着',

            '持续锁着',

            '持续按着',

            '持续扣着',

            '持续夹着',



            // 程度副词

            '完全',

            '完全束缚',

            '完全抱住',

            '完全抓住',

            '完全困住',

            '完全压制',

            '完全锁住',

            '完全侵占',

            '完全围住',

            '完全圈住',

            '彻底',

            '彻底束缚',

            '彻底抱住',

            '彻底抓住',

            '彻底困住',

            '彻底压制',

            '彻底锁住',

            '彻底侵占',

            '彻底围住',

            '彻底圈住',



            // 否定性词汇

            '不让你',

            '不让你动',

            '不让你走',

            '不让你离开',

            '不让你逃脱',

            '不让你挣脱',

            '不让你反抗',

            '不让你拒绝',

            '不让你脱身',

            '阻止你',

            '阻止你动',

            '阻止你走',

            '阻止你离开',

            '阻止你逃脱',

            '阻止你挣脱',

            '阻止你反抗',

            '阻止你拒绝',

            '阻止你脱身',



            // 命令性词汇

            '不许动',

            '不许走',

            '不许离开',

            '不许逃脱',

            '不许挣脱',

            '不许反抗',

            '不许拒绝',

            '不许脱身',

            '不准动',

            '不准走',

            '不准离开',

            '不准逃脱',

            '不准挣脱',

            '不准反抗',

            '不准拒绝',

            '不准脱身',

            '不能动',

            '不能走',

            '不能离开',

            '不能逃脱',

            '不能挣脱',

            '不能反抗',

            '不能拒绝',

            '不能脱身',

          ];



          // 检测匹配的关键词

          const matchedKeywords = keywords.filter(keyword => text.includes(keyword));

          if (matchedKeywords.length > 0) {

            console.log('🔍 匹配到的关键词:', matchedKeywords);

            return true;

          } else {

            console.log('🔍 未匹配到任何关键词');

            return false;

          }

        }



        // 触发QTE动作

        // 触发趣味QTE

        // 触发趣味QTE（使用jQuery）

        async triggerQTE(action) {

          try {

            console.log(`🎮 触发趣味QTE: ${action}`);



            let qteCommand = '';



            if (action === 'struggle') {

              // 奋力挣扎

              qteCommand = `奋力挣扎，尝试挣脱束缚`;

            } else if (action === 'submit') {

              // 不反抗

              qteCommand = `选择不反抗，接受现状`;

            }



            if (qteCommand) {

              // 将QTE命令填入输入框

              $('#action-input').val(qteCommand);

              console.log('✅ 趣味QTE命令已填入输入框:', qteCommand);

            }



            // 隐藏QTE区域

            this.checkQTEFromCurrentContent();

          } catch (error) {

            console.error('❌ 触发趣味QTE失败:', error);

          }

        }



        // 获取自动存档列表

        getAutoSaves() {

          const autoSaves = [];

          try {

            console.log('🔍 开始获取自动存档列表...');

            for (let i = 0; i < localStorage.length; i++) {

              const key = localStorage.key(i);

              if (key && key.startsWith('teresen-auto-save-')) {

                const data = localStorage.getItem(key);

                if (data) {

                  try {

                    const saveData = JSON.parse(data);

                    autoSaves.push({

                      key: key,

                      data: saveData,

                    });

                    console.log(

                      `📁 找到自动存档: ${key}, 时间: ${new Date(saveData.timestamp).toLocaleString('zh-CN')}`,

                    );

                  } catch (parseError) {

                    console.warn(`❌ 解析自动存档失败: ${key}`, parseError);

                  }

                }

              }

            }

            // 按时间戳排序，最新的在前

            autoSaves.sort((a, b) => b.data.timestamp - a.data.timestamp);

            console.log(`📊 总共找到 ${autoSaves.length} 个自动存档`);

            // 返回最近10个

            const result = autoSaves.slice(0, 10);

            console.log(`📋 返回最近 ${result.length} 个自动存档`);

            return result;

          } catch (error) {

            console.warn('获取自动存档列表失败:', error);

            return [];

          }

        }



        // 加载自动存档

        async loadAutoSave(saveKey) {

          try {

            console.log('📂 加载自动存档:', saveKey);

            const saveData = localStorage.getItem(saveKey);

            if (!saveData) {

              throw new Error('自动存档不存在');

            }



            const save = JSON.parse(saveData);



            // 恢复聊天历史

            if (save.data.chatHistory && save.data.chatHistory.length > 0) {

              const lastMessage = save.data.chatHistory[save.data.chatHistory.length - 1];

              if (

                'function' == typeof getChatMessages &&

                'undefined' != typeof TavernHelper &&

                TavernHelper.setChatMessages

              ) {

                await TavernHelper.setChatMessages([lastMessage], { refresh: 'none' });

                console.log('✅ 聊天历史已恢复');

              }

            }



            // 恢复游戏状态

            if (save.data.gameState && 'function' == typeof eventEmit) {

              // 直接设置变量，不调用MVU
              this.currentMvuState = save.data.gameState;
              this.renderUI(this.currentMvuState.stat_data);

              console.log('✅ 游戏状态已恢复');

            }



            await this.updateInterface();

            $('#load-modal').hide();

            console.log('✅ 自动存档加载成功');

            alert('自动存档加载成功！');

          } catch (error) {

            console.error('❌ 加载自动存档失败:', error);

            alert('加载自动存档失败！');

          }

        }



        // 调试存档功能

        debugSaves() {

          console.log('🔍 调试存档功能...');



          // 检查所有localStorage中的存档

          const allSaves = [];

          for (let i = 0; i < localStorage.length; i++) {

            const key = localStorage.key(i);

            if (key && (key === 'teresen-save' || key.startsWith('teresen-auto-save-'))) {

              try {

                const data = localStorage.getItem(key);

                const save = JSON.parse(data);

                allSaves.push({

                  key: key,

                  save: save,

                });

              } catch (error) {

                console.warn('解析存档失败:', key, error);

              }

            }

          }



          console.log('📊 所有存档:', allSaves);



          // 显示存档统计

          const manualSaves = allSaves.filter(s => s.key === 'teresen-save');

          const autoSaves = allSaves.filter(s => s.key.startsWith('teresen-auto-save-'));



          console.log('📋 存档统计:');

          console.log('  手动存档:', manualSaves.length, '个');

          console.log('  自动存档:', autoSaves.length, '个');



          // 显示每个存档的详细信息

          allSaves.forEach((saveInfo, index) => {

            console.group(`存档 ${index + 1}: ${saveInfo.key}`);

            console.log('存档数据:', saveInfo.save);

            if (saveInfo.save.data) {

              console.log('存档时间:', new Date(saveInfo.save.timestamp).toLocaleString('zh-CN'));

              console.log('存档名称:', saveInfo.save.saveName);

              console.log('存档类型:', saveInfo.save.type);

            }

            console.groupEnd();

          });



          // 测试自动存档列表功能

          const autoSavesList = this.getAutoSaves();

          console.log('🔧 自动存档列表功能测试:', autoSavesList);

        }



        // 调试指令交互系统

        debugCommands() {

          console.log('⚡ 调试指令交互系统...');



          // 检查输入框

          const actionInput = document.getElementById('action-input');

          console.log('指令输入框:', actionInput);



          // 检查发送按钮

          const sendBtn = document.querySelector('.send-button, #send-btn, button[onclick*="handleActionSubmit"]');

          console.log('发送按钮:', sendBtn);



          // 检查最后发送的指令

          console.log('最后发送的指令:', this.lastSentPrompt);



          // 检查聊天历史

          const chatContainer = document.getElementById('chat_container');

          console.log('聊天容器:', chatContainer);

        }



        // 调试自动存档系统

        debugAutoSaves() {

          console.log('💾 调试自动存档系统...');



          // 检查所有localStorage中的自动存档

          const allAutoSaves = [];

          for (let i = 0; i < localStorage.length; i++) {

            const key = localStorage.key(i);

            if (key && key.startsWith('teresen-auto-save-')) {

              try {

                const data = localStorage.getItem(key);

                const saveData = JSON.parse(data);

                allAutoSaves.push({

                  key: key,

                  timestamp: saveData.timestamp,

                  time: new Date(saveData.timestamp).toLocaleString('zh-CN'),

                  saveName: saveData.saveName,

                });

              } catch (error) {

                console.warn(`解析存档失败: ${key}`, error);

              }

            }

          }



          // 按时间排序

          allAutoSaves.sort((a, b) => b.timestamp - a.timestamp);



          console.log('📊 所有自动存档:');

          allAutoSaves.forEach((save, index) => {

            console.log(`${index + 1}. ${save.key} - ${save.time} - ${save.saveName}`);

          });



          console.log(`📈 总计: ${allAutoSaves.length} 个自动存档`);



          // 测试getAutoSaves方法

          const recentSaves = this.getAutoSaves();

          console.log('📋 getAutoSaves返回:', recentSaves.length, '个');

        }



        // 新增：简单存档系统

        async saveGame(slotId = 'slot_1') {

          try {

            const saveName = prompt('请输入存档名称:');

            if (!saveName) return;



            const currentVariables = this.getAllVariables();

            const chatMessages = await getChatMessages(0);

            const currentMessage = chatMessages && chatMessages.length > 0 ? chatMessages[0].message : '';



            const saveData = {

              timestamp: Date.now(),

              save_name: saveName,

              mvu_data: currentVariables,

              message_content: currentMessage,

              type: 'manual',

            };



            localStorage.setItem(`teresen_save_${slotId}`, JSON.stringify(saveData));

            alert('存档成功！');

          } catch (error) {

            console.error('存档失败:', error);

            alert('存档失败！');

          }

        }



        async loadGame(slotId = 'slot_1') {

          try {

            const savedData = localStorage.getItem(`teresen_save_${slotId}`);

            if (!savedData) {

              alert('存档不存在！');

              return;

            }



            const saveData = JSON.parse(savedData);



            // 恢复变量状态

            if (saveData.mvu_data) {

              // 直接设置变量，不调用MVU
              this.currentMvuState = saveData.mvu_data;
              this.renderUI(this.currentMvuState.stat_data);

            }



            // 恢复聊天消息

            if (saveData.message_content) {

              const chatMessages = await getChatMessages(0);

              if (chatMessages && chatMessages.length > 0) {

                const firstMessage = chatMessages[0];

                firstMessage.message = saveData.message_content;

                firstMessage.data = saveData.mvu_data;

                await TavernHelper.setChatMessages([firstMessage], { refresh: 'none' });

              }

            }



            // 更新界面

            await this.updateDynamicData();



            alert('读档成功！');

          } catch (error) {

            console.error('读档失败:', error);

            alert('读档失败！');

          }

        }



        // 新天赋系统函数

        showTalentsModal() {

          // 播放天赋管理声音
          const sound = document.getElementById('talent-sound');
          if (sound) {
            sound.currentTime = 0;
            sound.play().catch(e => console.log('音效播放失败:', e));
          }
          
          const modal = document.getElementById('talents-modal');

          if (modal) {

            modal.style.display = 'flex';

            modal.style.justifyContent = 'center';

            modal.style.alignItems = 'center';

            // 初始化翻页系统

            this.currentTalentPage = 0;

            this.updatePageIndicator();

            this.updatePageButtons();

            this.updateTalentsModal();

            

            // 添加键盘事件监听

            this.addKeyboardListeners();

          }

        }



        updateTalentsModal() {

          this.updateCurrentTalents();

          this.updateTalentOptions();

          this.updateUpgradeHistory();

          this.updateCurrentPageOptions();

        }



        updateCurrentTalents() {

          const container = document.getElementById('current-talents-list');

          if (!container) return;



          try {

            let majorTalent = '无';

            let crystals = 0;

            let acquiredTalents = [];



            // 从MVU变量读取数据

            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {

              const mvuData = Mvu.getMvuData({ type: 'chat' });

              majorTalent = Mvu.getMvuVariable(mvuData, '训练员.天赋.大天赋.name[0]', { default_value: '无' });

              crystals = Mvu.getMvuVariable(mvuData, '训练员.畸形情感结晶[0]', { default_value: 0 });



              // 读取已获得的天赋

              const levels = ['萌芽', '生长', '畸变', '权柄', '深渊'];

              levels.forEach(level => {

                const talent = Mvu.getMvuVariable(mvuData, `训练员.天赋.小天赋.${level}[0]`, { default_value: null });

                if (talent) {

                  acquiredTalents.push({

                    level: level,

                    title: talent

                  });

                }

              });

            } else {

              // 降级到原有方法

              const variables = this.getAllVariables();

              majorTalent = this.getVariable(variables, 'stat_data.训练员.天赋.大天赋.name[0]', '无');

              crystals = this.getVariable(variables, 'stat_data.训练员.畸形情感结晶[0]', 0);

            }



            // 获取大天赋描述词

            const talentInfo = this.getMajorTalentDescription(majorTalent);

            

            let html = `

              <div style="max-width: 800px; margin: 0 auto;">

                <!-- 大天赋信息卡片 -->

                <div style="background: linear-gradient(135deg, rgba(139, 69, 19, 0.1), rgba(139, 69, 19, 0.05)); border: 2px solid rgba(139, 69, 19, 0.3); border-radius: 16px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);">

                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    
                    <h4 style="color: #8b4513; font-size: 18px; font-weight: bold; display: flex; align-items: center; gap: 8px;">

                      <span style="font-size: 20px;">🎭</span>

                      ${talentInfo.name}

                    </h4>

                    <!-- 结晶显示 -->
                    <div style="background: linear-gradient(135deg, rgba(168, 85, 247, 0.12), rgba(168, 85, 247, 0.06)); border: 1px solid rgba(168, 85, 247, 0.4); border-radius: 8px; padding: 8px 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">
                      <div style="display: flex; align-items: center; gap: 4px;">
                        <span style="font-size: 12px;">💎</span>
                        <span style="color: #a855f7; font-size: 12px; font-weight: 600;">结晶</span>
                        <span style="color: #a855f7; font-size: 14px; font-weight: bold;">${crystals}</span>
                      </div>
                    </div>

                  </div>

                  <div style="color: #8b4513; font-size: 14px; line-height: 1.6; margin-bottom: 16px; text-align: center; font-style: italic;">

                    ${talentInfo.description}

                  </div>

                  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">

                    <div style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.08), rgba(34, 197, 94, 0.03)); border: 2px solid rgba(34, 197, 94, 0.4); border-radius: 12px; padding: 16px; position: relative; overflow: hidden;">

                      <!-- 扭曲的装饰线条 -->

                      <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, rgba(34, 197, 94, 0.6), transparent);"></div>

                      <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, rgba(34, 197, 94, 0.6), transparent);"></div>

                      

                      <div style="color: #15803d; font-size: 14px; font-weight: 700; margin-bottom: 8px; text-shadow: 0 1px 2px rgba(34, 197, 94, 0.3); letter-spacing: 0.5px;">力量之源</div>

                      <div style="color: #1a1a1a; font-size: 13px; line-height: 1.6; font-weight: 500; text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);">${talentInfo.positive}</div>

                    </div>

                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.08), rgba(239, 68, 68, 0.03)); border: 2px solid rgba(239, 68, 68, 0.4); border-radius: 12px; padding: 16px; position: relative; overflow: hidden;">

                      <!-- 扭曲的装饰线条 -->

                      <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, rgba(239, 68, 68, 0.6), transparent);"></div>

                      <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, rgba(239, 68, 68, 0.6), transparent);"></div>

                      

                      <div style="color: #dc2626; font-size: 14px; font-weight: 700; margin-bottom: 8px; text-shadow: 0 1px 2px rgba(239, 68, 68, 0.3); letter-spacing: 0.5px;">代价之痕</div>

                      <div style="color: #1a1a1a; font-size: 13px; line-height: 1.6; font-weight: 500; text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);">${talentInfo.negative}</div>

                    </div>

                  </div>

                </div>



              </div>

            `;



            // 显示已获得的天赋

            if (acquiredTalents.length > 0) {

              html += `

                <div style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(34, 197, 94, 0.05)); border: 2px solid rgba(34, 197, 94, 0.3); border-radius: 16px; padding: 20px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);">

                  <h4 style="color: #22c55e; font-size: 18px; font-weight: bold; margin-bottom: 16px; display: flex; align-items: center; gap: 8px; text-align: center; justify-content: center;">

                    <span style="font-size: 20px;">🌟</span>

                    已获得天赋

                  </h4>

                  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px;">

              `;

              acquiredTalents.forEach(talent => {

                html += `

                  <div style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.08)); border: 2px solid rgba(34, 197, 94, 0.4); border-radius: 12px; padding: 16px; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1); transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(0,0,0,0.1)'">

                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">

                      <span style="color: #22c55e; font-size: 14px; font-weight: bold; background: rgba(34, 197, 94, 0.25); padding: 6px 10px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">${talent.level}</span>

                      <span style="color: #22c55e; font-size: 12px; opacity: 0.9; font-weight: 500;">✨ 已激活</span>

                    </div>

                    <div style="color: #2d1b1b; font-size: 14px; line-height: 1.5; font-weight: 500;">${talent.title}</div>

                  </div>

                `;

              });

              html += `

                  </div>

                </div>

              `;

            } else {

              html += `

                <div style="background: linear-gradient(135deg, rgba(139, 69, 19, 0.08), rgba(139, 69, 19, 0.04)); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 16px; padding: 40px; text-align: center; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); position: relative; overflow: hidden;">



                  

                  <div style="font-size: 36px; margin-bottom: 16px; opacity: 0.8; filter: drop-shadow(0 2px 4px rgba(139, 69, 19, 0.3));">📖</div>

                  <div style="color: #8b4513; font-size: 16px; font-weight: 600; margin-bottom: 8px; text-shadow: 0 1px 2px rgba(139, 69, 19, 0.2);">天赋之书</div>

                  <div style="color: #666666; font-size: 14px; font-style: italic; margin-bottom: 8px; opacity: 0.8;">暂无已获得天赋</div>

                  <div style="color: #8b4513; font-size: 13px; opacity: 0.7;">请翻页查看可升级的天赋选项</div>

                </div>

              `;

            }



            container.innerHTML = html;

          } catch (error) {

            console.error('更新当前天赋显示失败:', error);

            container.innerHTML = '<div style="text-align: center; color: #666666; font-style: italic; padding: 50px;">加载失败</div>';

          }

        }



        updateTalentOptions() {

          const levels = ['seed', 'growth', 'mutation', 'authority', 'abyss'];

          levels.forEach(level => {

            this.updateTalentLevelOptions(level);

          });

        }



        updateTalentLevelOptions(level) {

          const container = document.getElementById(`${level}-options`);

          if (!container) return;



          const levelData = this.getTalentData(level);

          if (!levelData) return;



          // 检查前置条件：上一层是否已注入天赋

          const isLevelUnlocked = this.isLevelUnlocked(level);

          

          if (!isLevelUnlocked) {

            // 如果层级未解锁，显示锁定状态

            const previousLevel = this.getPreviousLevel(level);

            const previousLevelChinese = this.getLevelChineseName(previousLevel);

            container.innerHTML = `

              <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; text-align: center; background: linear-gradient(135deg, rgba(107, 114, 128, 0.1), rgba(107, 114, 128, 0.05)); border: 2px dashed rgba(107, 114, 128, 0.3); border-radius: 12px;">

                <div style="font-size: 48px; margin-bottom: 16px;">🔒</div>

                <h4 style="color: #6b7280; font-size: 16px; font-weight: bold; margin-bottom: 8px;">层级未解锁</h4>

                <p style="color: #9ca3af; font-size: 14px; line-height: 1.5; margin: 0;">需要先完成 <span style="color: #8b4513; font-weight: bold;">${previousLevelChinese}</span> 层级的天赋选择</p>

                <p style="color: #9ca3af; font-size: 12px; margin-top: 8px; font-style: italic;">请返回上一页选择天赋</p>

              </div>

            `;

            return;

          }



          let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';

          levelData.options.forEach((option, index) => {

            const isAcquired = this.isTalentAcquired(level, index);

            const cost = this.getTalentCost(level);

            html += `

              <div style="background: ${isAcquired ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.08))' : 'linear-gradient(135deg, rgba(139, 69, 19, 0.12), rgba(139, 69, 19, 0.06))'}; border: 2px solid ${isAcquired ? 'rgba(34, 197, 94, 0.4)' : 'rgba(139, 69, 19, 0.3)'}; border-radius: 10px; padding: 14px; cursor: pointer; transition: all 0.3s; box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 20px rgba(0,0,0,0.2)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 12px rgba(0,0,0,0.15)'" onclick="window.teresenDebug.selectTalentOption('${level}', ${index})">

                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">

                  <h4 style="color: ${isAcquired ? '#22c55e' : '#8b4513'}; font-size: 15px; font-weight: bold; margin: 0; flex: 1; text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${option.title}</h4>

                  <span style="color: ${isAcquired ? '#22c55e' : '#8b4513'}; font-size: 11px; font-weight: bold; background: ${isAcquired ? 'rgba(34, 197, 94, 0.25)' : 'rgba(139, 69, 19, 0.2)'}; padding: 5px 10px; border-radius: 8px; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">${isAcquired ? '✅ 已获得' : '💎 ' + cost}</span>

                </div>

                <p style="color: #2d1b1b; font-size: 13px; line-height: 1.5; margin: 0 0 10px 0; font-weight: 500;">${option.description}</p>

                <div style="background: ${isAcquired ? 'rgba(34, 197, 94, 0.1)' : 'rgba(139, 69, 19, 0.08)'}; border: 1px solid ${isAcquired ? 'rgba(34, 197, 94, 0.3)' : 'rgba(139, 69, 19, 0.2)'}; border-radius: 8px; padding: 8px 10px; text-align: center;">

                  <span style="color: ${isAcquired ? '#22c55e' : '#8b4513'}; font-size: 12px; font-weight: bold; text-shadow: 0 1px 1px rgba(255,255,255,0.5);">${option.effects}</span>

                </div>

              </div>

            `;

          });

          html += '</div>';



          container.innerHTML = html;

        }



        // 根据页面索引获取对应的层级

        getLevelByPageIndex(pageIndex) {

          const levelMap = {

            0: null, // 当前天赋页面

            1: 'seed',

            2: 'growth', 

            3: 'mutation',

            4: 'authority',

            5: 'abyss',

            6: null // 升级记录页面

          };

          return levelMap[pageIndex];

        }



        // 获取天赋消耗

        getTalentCost(level) {

          const costMap = {

            'seed': 3,

            'growth': 12,

            'mutation': 25,

            'authority': 40,

            'abyss': 70

          };

          return costMap[level] || 0;

        }



        // 更新当前页面的选项

        updateCurrentPageOptions() {

          const level = this.getLevelByPageIndex(this.currentTalentPage);

          if (level) {

            this.updateTalentLevelOptions(level);

          }

        }



        getTalentData(level) {

          // 获取当前选择的大天赋方向

          let majorTalent = '强化系（占有之爱）';

          try {

            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {

              const mvuData = Mvu.getMvuData({ type: 'chat' });

              majorTalent = Mvu.getMvuVariable(mvuData, '训练员.天赋.大天赋.name[0]', { default_value: '强化系（占有之爱）' });

            }

          } catch (error) {

            console.warn('获取大天赋失败，使用默认值:', error);

          }



          // 根据大天赋方向返回对应的天赋数据

          const talentData = {

            seed: {

              prompt: "你只是在绝境中，无意识地抓住了求生的稻草。这份力量微弱、不受控制，是你在这别样世界中发出的第一声微弱的啼哭。",

              options: this.getTalentOptionsByMajor(majorTalent, 'seed')

            },

            growth: {

              prompt: "你开始理解并有意识地运用这份力量，将其作为解决问题的工具。你从被动的受害者，转变为一个能在棋盘上谨慎落子的参与者。",

              options: this.getTalentOptionsByMajor(majorTalent, 'growth')

            },

            mutation: {

              prompt: "力量开始反过来影响你的心智和行为。你获得了更强大的能力，但也感受到了其背后那令人战栗的甜美与疯狂。",

              options: this.getTalentOptionsByMajor(majorTalent, 'mutation')

            },

            authority: {

              prompt: "在经历了内心的挣扎后，你做出了选择。你不再视其为诅咒，而是开始享受这份力量，并主动将其锻造成属于自己的'权柄'。",

              options: this.getTalentOptionsByMajor(majorTalent, 'authority')

            },

            abyss: {

              prompt: "你走到了这条路的终点。你与所选的'不凡之爱'彻底融为一体，成为了一个新的'概念'、一个新的'规则怪谈'。",

              options: this.getTalentOptionsByMajor(majorTalent, 'abyss')

            }

          };



          return talentData[level];

        }



        isTalentAcquired(level, optionIndex) {

          try {

            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {

              const mvuData = Mvu.getMvuData({ type: 'chat' });

              const levelChineseName = this.getLevelChineseName(level);

              const currentTalent = Mvu.getMvuVariable(mvuData, `训练员.天赋.小天赋.${levelChineseName}[0]`, { default_value: null });

              

              if (currentTalent) {

                const levelData = this.getTalentData(level);

                if (levelData && levelData.options[optionIndex]) {

                  // 现在注入的是描述，所以比较描述内容

                  return currentTalent === levelData.options[optionIndex].description;

                }

              }

            }

            return false;

          } catch (error) {

            console.error('检查天赋状态失败:', error);

            return false;

          }

        }



        async selectTalentOption(level, optionIndex) {

          try {

            console.log('🔍 开始天赋选择流程...');

            

            const levelData = this.getTalentData(level);

            if (!levelData || !levelData.options[optionIndex]) {

              console.error('❌ 天赋数据不存在:', { level, optionIndex });

              return;

            }



            const option = levelData.options[optionIndex];

            console.log('📋 选择的天赋:', option);

            

            // 检查MVU API是否可用

            if (typeof Mvu === 'undefined') {

              console.error('❌ MVU对象未定义');

              alert('MVU系统未加载，请刷新页面重试');

              return;

            }

            

            if (!Mvu.getMvuData || !Mvu.setMvuVariable || !Mvu.replaceMvuData) {

              console.error('❌ MVU API函数不存在:', {

                getMvuData: !!Mvu.getMvuData,

                setMvuVariable: !!Mvu.setMvuVariable,

                replaceMvuData: !!Mvu.replaceMvuData

              });

              alert('MVU API不完整，请刷新页面重试');

              return;

            }



            // 获取MVU数据

            const mvuData = Mvu.getMvuData({ type: 'chat' });

            console.log('📊 MVU数据获取成功:', mvuData ? '是' : '否');

            

            // 检查层级是否已有选择

            const levelChineseName = this.getLevelChineseName(level);

            const currentTalent = Mvu.getMvuVariable(mvuData, `训练员.天赋.小天赋.${levelChineseName}[0]`, { default_value: null });

            console.log('🔍 当前层级天赋:', { levelChineseName, currentTalent });

            

            if (currentTalent && currentTalent !== '') {

              alert(`该层级已有选择：${currentTalent}\n每个层级只能选择一个天赋！`);

              return;

            }



            // 检查结晶是否足够

            const cost = this.getTalentCost(level);

            const currentCrystals = Mvu.getMvuVariable(mvuData, '训练员.畸形情感结晶[0]', { default_value: 0 });

            console.log('💎 结晶检查:', { cost, currentCrystals });

            

            if (currentCrystals < cost) {

              alert(`结晶不足！需要 ${cost} 个结晶，当前只有 ${currentCrystals} 个`);

              return;

            }



            // 确认选择

            const confirmed = confirm(`确定要获得天赋 "${option.title}" 吗？\n\n描述: ${option.description}\n\n效果: ${option.effects}\n\n消耗: ${cost} 个结晶`);

            if (!confirmed) return;



            console.log('✅ 用户确认选择，开始注入...');

            

            // 扣除结晶

            const newCrystals = currentCrystals - cost;

            console.log('💰 扣除结晶:', { currentCrystals, cost, newCrystals });

            

            await Mvu.setMvuVariable(mvuData, '训练员.畸形情感结晶[0]', newCrystals, {

              reason: '天赋消耗',

              is_recursive: true,

            });

            console.log('✅ 结晶扣除成功');

            

            // 注入天赋选择到MVU变量 - 注入天赋描述

            const talentPath = `训练员.天赋.小天赋.${levelChineseName}[0]`;

            console.log('🎯 注入天赋路径:', talentPath);

            

            // 注入天赋的描述内容

            await Mvu.setMvuVariable(mvuData, talentPath, option.description, {

              reason: `天赋升级: ${level}层级`,

              is_recursive: true,

            });

            console.log('✅ 天赋注入成功，注入描述:', option.description);



            // 保存更新后的数据

            await Mvu.replaceMvuData(mvuData, { type: 'chat' });

            console.log('✅ MVU数据保存成功');



            console.log(`🎉 天赋注入完成: ${talentPath} = ${option.title}，消耗 ${cost} 个结晶`);

            

            // 更新显示

            this.updateTalentsModal();

            
            // 检查是否需要更新技能系统（特别是萌芽天赋解锁时）
            if (window.skillSystem && level === 'seed') {
              console.log('🎯 萌芽天赋解锁，更新技能系统...');
              window.skillSystem.checkSkillUnlock();
            }
            

            alert(`恭喜获得天赋: ${option.title}！\n消耗了 ${cost} 个结晶，剩余 ${newCrystals} 个`);

          } catch (error) {

            console.error('❌ 天赋注入失败:', error);

            console.error('错误详情:', {

              message: error.message,

              stack: error.stack,

              level,

              optionIndex

            });

            alert(`天赋注入失败: ${error.message}\n请检查控制台获取详细信息`);

          }

        }



        getLevelChineseName(level) {

          const levelMap = {

            'seed': '萌芽',

            'growth': '生长', 

            'mutation': '畸变',

            'authority': '权柄',

            'abyss': '深渊'

          };

          return levelMap[level] || level;

        }



        // 获取上一层级

        getPreviousLevel(level) {

          const levelOrder = ['seed', 'growth', 'mutation', 'authority', 'abyss'];

          const currentIndex = levelOrder.indexOf(level);

          if (currentIndex <= 0) return null; // 第一层没有前置条件

          return levelOrder[currentIndex - 1];

        }



        // 检查层级是否已解锁

        isLevelUnlocked(level) {

          // 第一层（萌芽）总是解锁的

          if (level === 'seed') return true;

          

          // 检查上一层级是否已注入天赋

          const previousLevel = this.getPreviousLevel(level);

          if (!previousLevel) return true;

          

          try {

            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {

              const mvuData = Mvu.getMvuData({ type: 'chat' });

              const previousLevelChinese = this.getLevelChineseName(previousLevel);

              const previousTalent = Mvu.getMvuVariable(mvuData, `训练员.天赋.小天赋.${previousLevelChinese}[0]`, { default_value: null });

              

              // 如果上一层级有天赋注入，则当前层级解锁

              return previousTalent && previousTalent !== '';

            }

            return false;

          } catch (error) {

            console.error('检查层级解锁状态失败:', error);

            return false;

          }

        }



        // 根据大天赋方向获取对应的天赋选项

        getTalentOptionsByMajor(majorTalent, level) {

          const talentOptions = {

            '强化系（占有之爱）': {

              seed: [

                { title: "防御延伸", description: "你对'爱人'的占有欲，使其在你身边时也能获得你防御力提升效果的25%。", effects: "防御力+25%" },

                { title: "规则延伸", description: "当你与'爱人'共同解读规则时，看穿漏洞的几率小幅提升。", effects: "规则洞察+15%" },

                { title: "锁链延伸", description: "无形锁链的感知范围扩大，能让你模糊感应到'爱人'的大致方位。", effects: "感知范围+20%" }

              ],

              growth: [

                { title: "防御强化", description: "提升防御力的持续时间增加50%，但结束后'伤痕'带来的痛苦会加倍。", effects: "持续时间+50%" },

                { title: "规则强化", description: "你可以主动消耗精神，强制看破一则简单规则的漏洞，但视野会暂时变得更狭窄。", effects: "规则洞察+30%" },

                { title: "锁链强化", description: "你可以消耗体力，具现化一道短暂的实体锁链，用于绊倒目标或拉取轻量物体。", effects: "锁链具现化" }

              ],

              mutation: [

                { title: "防御畸变", description: "防御力提升变为被动触发，但只有当你或'爱人'受到伤害时才会生效，且你会渴望这种触发。", effects: "被动防御" },

                { title: "规则畸变", description: "你开始能看到人际关系中的'规则漏洞'，让你更容易操纵他人，但你对他人的信任感永久降低。", effects: "社交洞察" },

                { title: "锁链畸变", description: "锁链会不自觉地缠绕在你和'爱人'身上，若距离过远，双方都会感到束缚的刺痛（反噬自身）。", effects: "锁链束缚" }

              ],

              authority: [

                { title: "防御权柄", description: "你可以宣告一个半径5米的'独占领域'，领域内你的防御力提升效果对所有敌人产生排斥力。", effects: "独占领域" },

                { title: "规则权柄", description: "你可以指定一个已被看穿的规则漏洞，并暂时将其'关闭'，阻止其他人利用。", effects: "规则封锁" },

                { title: "锁链权柄", description: "你可以将无形锁链'锚定'在一个目标身上，使其所有行动检定受到负面影响，直到其脱离你的感知范围。", effects: "锁链锚定" }

              ],

              abyss: [

                { title: "防御深渊", description: "你的身体与'爱人'的命运绑定，只要她存活，你的物理防御就不会被彻底击溃，代价是你将失去独立的'自我'意识。", effects: "命运绑定" },

                { title: "规则深渊", description: "你成为规则的一部分，可以重写一条你已完全看透的简单规则，代价是你的存在本身也被这条新规则永久束缚。", effects: "规则重写" },

                { title: "锁链深渊", description: "你与'爱人'被永恒的锁链连接，共享生命与力量，但也永远无法分离，成为一个共生的整体。", effects: "永恒锁链" }

              ]

            },

            '变化系（谎言之爱）': {

              seed: [

                { title: "规则延伸", description: "当你阅读规则时，有几率看到一句被'谎言'额外标记出的、最容易被修改的词句。", effects: "规则标记" },

                { title: "情感延伸", description: "你撒的第一个无伤大雅的谎言，会让你散发出微弱的、令人安心的气息。", effects: "安心气息" },

                { title: "影子延伸", description: "你的影子在光线最暗时会轻微晃动，仿佛在模仿一个不存在的动作。", effects: "影子晃动" }

              ],

              growth: [

                { title: "规则强化", description: "你可以指定规则描述中的一个词，用一个同义词进行临时替换，持续1分钟。", effects: "规则替换" },

                { title: "情感强化", description: "你可以将一个简单的谎言（如'我很好'）具象化，注入目标体内，使其暂时忽略你的负面状态。", effects: "谎言具象" },

                { title: "影子强化", description: "你可以命令你的影子做出一个简单的、无实体的动作（如挥手），以吸引注意力。", effects: "影子控制" }

              ],

              mutation: [

                { title: "规则畸变", description: "你修改规则时，有几率导致该规则的另一部分变得更加严苛（规则不稳定反噬）。", effects: "规则反噬" },

                { title: "情感畸变", description: "如果你具象化的情感谎言被识破，其麻痹效果会立刻转变为刺痛目标的精神毒药。", effects: "谎言毒药" },

                { title: "影子畸变", description: "影子承受伤害后，你本人会在24小时内随机出现一处与影子受伤部位对应的淤青（伤害叠加前兆）。", effects: "伤害反馈" }

              ],

              authority: [

                { title: "规则权柄", description: "你可以编造一句全新的、看似合理的规则，并将其临时添加进现有的规则文本中。", effects: "规则编造" },

                { title: "情感权柄", description: "你可以编造一种复杂的'复合情感'（如'喜悦的悲伤'），麻痹对手更高阶的逻辑判断。", effects: "复合情感" },

                { title: "影子权柄", description: "你可以创造一个能离开你身体、持续10秒的虚假影子，用于承受一次指向性攻击。", effects: "虚假影子" }

              ],

              abyss: [

                { title: "规则深渊", description: "你成为了'行走的谎言'，你说出的话在短时间内会被他人下意识地当作'规则'来遵守，代价是你自己也无法分辨真实与虚假。", effects: "行走谎言" },

                { title: "情感深渊", description: "你编造的情感可以永久地改变一个人的性格基石，代价是你说出的所有谎言最终都会在你身上特殊具现化为新的危险。", effects: "性格重塑" },

                { title: "影子深渊", description: "你可以与你的影子互换位置，让其承受所有伤害，但影子最终爆发时，所有累积伤害将一次性返还给你。", effects: "影子互换" }

              ]

            },

            '放出系（牺牲之爱）': {

              seed: [

                { title: "情绪延伸", description: "当你感到强烈的悲伤时，周围的敌意目标会感受到轻微的迷惑，攻击精准度小幅下降。", effects: "悲伤迷惑" },

                { title: "献祭延伸", description: "你最珍视的一段记忆，其轮廓会变得模糊，作为代价，你对规则的修改抗性微量提升。", effects: "记忆模糊" },

                { title: "分身延伸", description: "你能感觉到一个与你相貌相似的'幻影'存在于某处，但无法与之交流或控制。", effects: "幻影感知" }

              ],

              growth: [

                { title: "情绪释放", description: "你可以主动释放一段痛苦的情绪，令一个指定目标暂时（约5秒）丧失攻击性，代价是该段情绪对应的记忆会产生裂痕。", effects: "情绪释放" },

                { title: "生命献祭", description: "你可以消耗少量生命力（表现为一道无法愈合的小伤口），来'擦除'规则文本中的一个非关键词。", effects: "生命献祭" },

                { title: "分身具现", description: "你可以消耗大量体力，将'幻影'短暂地在指定位置具现化1秒，用于格挡或迷惑。", effects: "分身具现" }

              ],

              mutation: [

                { title: "情绪畸变", description: "你释放的情绪开始带有腐蚀性，敌人失去攻击性的同时，其理智也会被轻微侵蚀，但你的精神力上限会因此永久降低。", effects: "情绪腐蚀" },

                { title: "规则畸变", description: "你消耗记忆修改过的规则，在失效后会以更难理解的形式回归，增加其破解难度。", effects: "规则回归" },

                { title: "分身畸变", description: "你的分身开始拥有微弱的自我意识，有时会做出违背你命令的细微动作，其承受的痛苦会轻微反馈到你身上。", effects: "分身意识" }

              ],

              authority: [

                { title: "情绪权柄", description: "你可以将'绝望'这种情绪赋予一片区域，所有进入该区域的敌人都将受到持续的意志削弱。", effects: "绝望领域" },

                { title: "记忆权柄", description: "你可以彻底献祭一段完整的记忆，以此为代价，强行修改一条简单规则的核心逻辑。", effects: "记忆献祭" },

                { title: "分身权柄", description: "你可以具现化一个能持续存在1分钟的分身，并赋予其一个明确的指令，但分身被摧毁时，你会承受其所受伤害的50%。", effects: "持久分身" }

              ],

              abyss: [

                { title: "情绪深渊", description: "你成为了'牺牲'的化身，你的存在本身就会让周围的生命体丧失斗争欲望，代价是你自身的情感也随之完全消亡。", effects: "牺牲化身" },

                { title: "规则深渊", description: "你可以将自己的一部分生命力永久注入一条规则，使其为你所用，但你的存在也与该规则绑定，规则被破解时你会遭受重创。", effects: "规则绑定" },

                { title: "分身深渊", description: "你可以创造一个与你完全相同的分身，共享感官与生命，但分身死亡时，你也会一同死亡。", effects: "生命共享" }

              ]

            },

            '操作系（控制之爱）': {

              seed: [

                { title: "暗示延伸", description: "你能被动地感知到周围人群中，谁的意志最薄弱，更容易接受心理暗示。", effects: "意志感知" },

                { title: "操控延伸", description: "你能模糊地感应到附近是否存在刚刚失去战斗意志、适合被操控的残兵。", effects: "残兵感知" },

                { title: "吸收延伸", description: "你能分辨出NPC对你散发的'爱意'的强弱，但这种感知让你觉得冰冷。", effects: "爱意感知" }

              ],

              growth: [

                { title: "暗示强化", description: "你可以对一个NPC植入一个简单的词语暗示，例如'遗忘'或'信任'。", effects: "词语暗示" },

                { title: "操控强化", description: "你可以操控一个刚被你击败的小型敌人为你战斗，持续时间一分钟。", effects: "敌人操控" },

                { title: "吸收强化", description: "你可以吸收一名NPC自愿给予的'爱意'，小幅强化你的一项身体能力。", effects: "爱意吸收" }

              ],

              mutation: [

                { title: "暗示畸变", description: "你植入的暗示效果增强，但作为代价，你自身的情感会变得麻木。", effects: "暗示增强" },

                { title: "操控畸变", description: "被操控的敌人若意识到自己被操纵，会立刻挣脱控制并对你发动一次性的强烈反击。", effects: "操控反噬" },

                { title: "吸收畸变", description: "吸收的'爱意'会在你身上留下一个无法消除的特殊印记，成为你的一个弱点。", effects: "爱意印记" }

              ],

              authority: [

                { title: "暗示权柄", description: "你可以对NPC下达一句完整的、非自杀性的指令，只要其意志力低于你。", effects: "完整指令" },

                { title: "操控权柄", description: "你可以同时操控两名被击败的敌人，但期间你必须保持专注，无法移动或攻击。", effects: "双重操控" },

                { title: "吸收权柄", description: "你可以强行吸收NPC的'爱意'，并根据其特质获得一项临时的特殊能力。", effects: "强制吸收" }

              ],

              abyss: [

                { title: "暗示深渊", description: "你的存在本身就成为一种心理暗示，弱者会不自觉地服从你，但你也将彻底失去所有个人情感。", effects: "存在暗示" },

                { title: "操控深渊", description: "你可以将意识完全注入一个强大的敌人体内进行操控，但若其被摧毁，你的精神也会遭受重创。", effects: "意识注入" },

                { title: "吸收深渊", description: "你一次性吸收大量'爱意'获得强大力量，但这份爱会立刻转化为致命的恨意，成为锁定你的诅咒。", effects: "爱意诅咒" }

              ]

            },

            '具现化系（理想之爱）': {

              seed: [

                { title: "盔甲延伸", description: "当你幻想'被保护'时，你的皮肤会短暂地泛起一层微不可见的钻石光泽。", effects: "钻石光泽" },

                { title: "戒指延伸", description: "当你对某人产生强烈的'承诺'幻想时，你的指尖会感到些微冰凉的束缚感。", effects: "承诺束缚" },

                { title: "NPC延伸", description: "在你极度孤独时，你会听到一个模糊而完美的、只存在于你脑海中的声音在安慰你。", effects: "完美声音" }

              ],

              growth: [

                { title: "盔甲具现", description: "你可以消耗精神力，在你身体的某个部位具现化一块轻型盔甲，用于格挡一次攻击。", effects: "轻型盔甲" },

                { title: "戒指具现", description: "你可以具现化一枚虚幻的戒指戴在手上，它能让你在进行说服或交涉时，言语更具分量。", effects: "虚幻戒指" },

                { title: "NPC具现", description: "你可以短暂具现化一个完美的、半透明的NPC幻影，用于吸引敌人的注意力。", effects: "完美幻影" }

              ],

              mutation: [

                { title: "盔甲畸变", description: "具现化的盔甲开始对你产生'爱意'，只有当你也对其报以'爱意'时，它才会为你吸收伤害。", effects: "盔甲爱意" },

                { title: "戒指畸变", description: "如果你违背了戴上戒指时许下的承诺，戒指会化为一道真实的枷锁，束缚你的手腕。", effects: "承诺枷锁" },

                { title: "NPC畸变", description: "具现化的完美NPC开始消耗你真实的'爱意'来维持形态，并会嫉妒你与其他真实人类的交往。", effects: "NPC嫉妒" }

              ],

              authority: [

                { title: "盔甲权柄", description: "你可以具现化一套覆盖全身的盔甲，但盔甲会随着时间的推移而不断变重，最终限制你的行动。", effects: "全身盔甲" },

                { title: "戒指权柄", description: "你可以具现化一枚拥有强大力量的戒指，但它的力量完全取决于你对'理想之爱'的信念强度。", effects: "力量戒指" },

                { title: "NPC权柄", description: "你可以具现化一个拥有实体和简单自主能力的完美NPC，他会无条件帮助你，但无法理解任何真实的情感。", effects: "实体NPC" }

              ],

              abyss: [

                { title: "盔甲深渊", description: "具现化的盔甲与你的血肉彻底融合，为你提供永恒的保护，代价是你也成为了这副盔甲的囚徒，永远无法脱下。", effects: "血肉融合" },

                { title: "戒指深渊", description: "你将自己的灵魂与戒指绑定，获得了修改现实的力量，但你自身的存在也变得如幻想般虚无，逐渐被世界遗忘。", effects: "灵魂绑定" },

                { title: "NPC深渊", description: "你具现化的完美NPC取代了你在现实中的位置，而你则成为了他幻想中的一部分，活在他为你构建的理想世界里。", effects: "位置互换" }

              ]

            },

            '特质系（扭曲之爱）': {

              seed: [

                { title: "契约萌芽", description: "你能听到空间裂缝中传来的、低沉的'规则怪谈'的呓语，它们在引诱你签订契约。", effects: "怪谈呓语" },

                { title: "共鸣萌芽", description: "当你与一个NPC产生强烈情绪交集时，你能短暂地（约1秒）感受到对方此刻最核心的情绪。", effects: "情绪共鸣" },

                { title: "混合萌芽", description: "你对所有'爱意'的感知都带有一种不和谐的独特感，仿佛它们是某种更危险事物的伪装。", effects: "独特感知" }

              ],

              growth: [

                { title: "契约签订", description: "你可以献祭自己的一项感官（如嗅觉、色觉）作为代价，与一个低阶规则怪谈签订临时契约，获得一次性的、微小的现实别样能力。", effects: "感官献祭" },

                { title: "共鸣复制", description: "你可以主动与一名NPC进行情绪共鸣，随机复制其一项最基础的非战斗能力，持续5分钟。", effects: "能力复制" },

                { title: "情感交易", description: "你可以将一份真实的'爱意'作为商品，与其他存在交易，换取一个无法预测效果的'祝福'或'诅咒'。", effects: "爱意交易" }

              ],

              mutation: [

                { title: "契约畸变", description: "契约的力量开始侵蚀你的认知，你看到的现实世界会随机出现符合怪谈逻辑的、无害的幻觉。", effects: "认知侵蚀" },

                { title: "共鸣畸变", description: "共鸣结束时，你不仅要承受对方的所有痛苦，其最强烈的一种负面情绪还会在你心中残留一小时。", effects: "痛苦残留" },

                { title: "代价异化", description: "你为获得力量而付出的'代价'（如失去的感官），会以一种独特的形式在你身体周围重现，形成一个可见的、令人不安的光环。", effects: "代价光环" }

              ],

              authority: [

                { title: "契约权柄", description: "你可以指定一个强大的规则怪谈，通过献祭一项永久的身体能力（如奔跑能力），换取一次瞬间逆转局势的巨大力量。", effects: "能力献祭" },

                { title: "共鸣权柄", description: "你可以指定复制NPC的一项强大能力，但作为代价，你的人格会暂时被对方的性格特质所覆盖。", effects: "人格覆盖" },

                { title: "不凡规则", description: "你可以将两种不相关的'爱意'能力进行混合，创造出一个全新的、效果强大但完全不可控的一次性技能。", effects: "能力混合" }

              ],

              abyss: [

                { title: "契约深渊", description: "你将自己作为最终的祭品，与一个规则怪谈本身融为一体，成为新的怪谈，拥有制定规则的力量，但彻底失去人性。", effects: "怪谈融合" },

                { title: "共鸣深渊", description: "你可以与一个目标进行永久的情绪共鸣，完全复制其所有能力与记忆，但你的'自我'也将被对方完全同化，成为其影子。", effects: "完全同化" },

                { title: "混沌化身", description: "你成为了'独特之爱'的化身，能够随意组合所有爱意能力，但每一次使用都会让你的存在本身变得更加混乱和不可名状，最终走向彻底的熵增与消散。", effects: "混沌化身" }

              ]

            }

          };



          return talentOptions[majorTalent]?.[level] || talentOptions['强化系（占有之爱）'][level];

        }



        // 大天赋描述词映射

        getMajorTalentDescription(majorTalent) {

          const descriptions = {

            '强化系（占有之爱）': {

              name: '强化系（占有之爱）',

              description: '通过独占和控制来强化自身。力量源于对某物的强烈占有欲。',

              positive: '能够看穿规则漏洞，找到隐藏弱点；短时间内大幅提升防御力；具现化无形锁链锁定目标。',

              negative: '能力越强，对"爱人"的依赖和束缚越深，最终失去自我；视野变得狭窄；每次使用留下"伤痕"；锁链会反噬自身。'

            },

            '变化系（谎言之爱）': {

              name: '变化系（谎言之爱）',

              description: '将谎言和欺骗转化为现实。力量是不稳定的，随着欺骗而改变。',

              positive: '暂时修改规则描述使其有利；将谎言具象化为麻痹敌人的情感；创造虚假"影子"承受伤害。',

              negative: '所说的一切谎言都会扭曲具现化成为新的危险；规则变得不稳定可能反噬；谎言被识破时情感变为致命毒药；影子承受的伤害会叠加爆发。'

            },

            '放出系（牺牲之爱）': {

              name: '放出系（牺牲之爱）',

              description: '通过自我牺牲来影响他人或环境。力量是无私的，却以自己的"失去"为代价。',

              positive: '释放情绪使敌人失去攻击性；消耗生命或记忆修改规则；具现化分身执行任务。',

              negative: '每一次牺牲都会永久削弱自身；精神力上限永久降低；修改的规则会以更强形态回归；分身被摧毁时一同死亡。'

            },

            '操作系（控制之爱）': {

              name: '操作系（控制之爱）',

              description: '通过精神控制和情感操纵来奴役他人。力量源于对他人的绝对控制。',

              positive: '给NPC施加心理暗示使其服从；操控被击败的敌人为你战斗；吸收NPC"爱意"获得特殊能力。',

              negative: '控制的越多自身情感越麻木；NPC意识到被操纵时引发强烈反噬；必须专注操控无法使用其他能力；吸收的"爱意"留下扭曲印记成为弱点。'

            },

            '具现化系（理想之爱）': {

              name: '具现化系（理想之爱）',

              description: '将想象中的完美之爱具现化为实物。力量来源于对完美的幻想。',

              positive: '具现化轻型盔甲吸收伤害；具现化戒指获得强大力量；具现化完美NPC无条件帮助。',

              negative: '具现化物品只对"爱意"反应并逐渐取代现实；盔甲逐渐变重限制行动；违背承诺戒指化为枷锁；完美NPC消耗大量"爱"且无法理解真实情感。'

            },

            '特质系（扭曲之爱）': {

              name: '特质系（扭曲之爱）',

              description: '拥有独一无二的、超越常规的扭曲能力。力量是不可预知的，通常是以上五种爱意的混合或变异。',

              positive: '与强大规则怪谈签订契约获得瞬间巨大力量；与NPC情绪共鸣复制其能力。',

              negative: '能力伴随最不可控的风险和最深的异化；必须以某部分为代价；共鸣结束时承受所有痛苦。'

            }

          };

          return descriptions[majorTalent] || descriptions['强化系（占有之爱）'];

        }



        // 获取当前选择的大天赋方向

        getCurrentMajorTalent() {

          try {

            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {

              const mvuData = Mvu.getMvuData({ type: 'chat' });

              return Mvu.getMvuVariable(mvuData, '训练员.天赋.大天赋.name[0]', { default_value: '强化系（占有之爱）' });

            }

          } catch (error) {

            console.warn('获取大天赋失败，使用默认值:', error);

          }

          return '强化系（占有之爱）';

        }



        updateUpgradeHistory() {

          const container = document.getElementById('upgrade-history');

          if (!container) return;



          try {

            let acquiredTalents = [];



            // 从MVU变量读取已获得的天赋

            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {

              const mvuData = Mvu.getMvuData({ type: 'chat' });

              const levels = ['萌芽', '生长', '畸变', '权柄', '深渊'];

              

              levels.forEach(level => {

                const talent = Mvu.getMvuVariable(mvuData, `训练员.天赋.小天赋.${level}[0]`, { default_value: null });

                if (talent) {

                  acquiredTalents.push({

                    level: level,

                    title: talent

                  });

                }

              });

            }



            if (acquiredTalents.length === 0) {

              container.innerHTML = '<div style="text-align: center; color: #666666; font-style: italic; padding: 50px;">暂无升级记录</div>';

              return;

            }



            let html = '';

            acquiredTalents.forEach((talent, index) => {

              html += `

                <div style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(34, 197, 94, 0.05)); border: 2px solid rgba(34, 197, 94, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 10px;">

                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">

                    <span style="color: #22c55e; font-size: 16px; font-weight: bold;">${talent.level} - ${talent.title}</span>

                  </div>

                </div>

              `;

            });



            container.innerHTML = html;

          } catch (error) {

            console.error('更新升级记录失败:', error);

            container.innerHTML = '<div style="text-align: center; color: #666666; font-style: italic; padding: 50px;">加载失败</div>';

          }

        }



        // 当前页面索引

        currentTalentPage = 0;

        

        // 页面标题数组

        talentPageTitles = [

          '📖 当前天赋',

          '🌱 萌芽',

          '🌿 生长', 

          '🌀 畸变',

          '👑 权柄',

          '🌌 深渊',

          '📚 升级记录'

        ];



        switchTalentPage(page) {

          // 播放翻页声音
          const sound = document.getElementById('page-flip-sound');
          if (sound) {
            sound.currentTime = 0;
            sound.play().catch(e => console.log('翻页音效播放失败:', e));
          }
          
          // 隐藏所有页面

          const pages = document.querySelectorAll('.book-page');

          pages.forEach(p => p.style.display = 'none');



          // 移除所有按钮的active状态

          const buttons = document.querySelectorAll('.page-btn');

          buttons.forEach(btn => {

            btn.classList.remove('active');

            btn.style.background = 'rgba(139, 69, 19, 0.3)';

            btn.style.border = '2px solid rgba(139, 69, 19, 0.5)';

            btn.style.color = '#8b4513';

          });



          // 显示选中的页面

          const targetPage = document.getElementById(`page-${page}-content`);

          if (targetPage) {

            targetPage.style.display = 'block';

          }



          // 激活选中的按钮

          const targetBtn = document.getElementById(`page-${page}`);

          if (targetBtn) {

            targetBtn.classList.add('active');

            targetBtn.style.background = 'linear-gradient(135deg, #8b4513, #a0522d)';

            targetBtn.style.border = '2px solid #8b4513';

            targetBtn.style.color = '#ffffff';

          }

        }



        // 翻页到指定页面

        goToTalentPage(pageIndex) {

          if (pageIndex < 0 || pageIndex >= this.talentPageTitles.length) return;

          
          // 播放翻页声音
          const sound = document.getElementById('page-flip-sound');
          if (sound) {
            sound.currentTime = 0;
            sound.play().catch(e => console.log('翻页音效播放失败:', e));
          }
          

          this.currentTalentPage = pageIndex;

          

          // 更新容器位置

          const container = document.getElementById('book-pages-container');

          if (container) {

            container.style.transform = `translateX(-${pageIndex * 100}%)`;

          }

          

          // 更新页面指示器

          this.updatePageIndicator();

          

          // 更新按钮状态

          this.updatePageButtons();

          

          // 更新当前页面的选项

          this.updateCurrentPageOptions();

        }



        // 上一页

        prevTalentPage() {

          if (this.currentTalentPage > 0) {

            // 播放翻页声音
            const sound = document.getElementById('page-flip-sound');
            if (sound) {
              sound.currentTime = 0;
              sound.play().catch(e => console.log('翻页音效播放失败:', e));
            }
            this.goToTalentPage(this.currentTalentPage - 1);

          }

        }



        // 下一页

        nextTalentPage() {

          if (this.currentTalentPage < this.talentPageTitles.length - 1) {

            const nextPage = this.currentTalentPage + 1;

            const nextLevel = this.getLevelByPageIndex(nextPage);

            

            // 检查下一层级是否已解锁

            if (nextLevel && !this.isLevelUnlocked(nextLevel)) {

              const previousLevel = this.getPreviousLevel(nextLevel);

              const previousLevelChinese = this.getLevelChineseName(previousLevel);

              alert(`无法访问该层级！\n\n需要先完成 ${previousLevelChinese} 层级的天赋选择。\n\n请返回上一页选择天赋。`);

              return;

            }

            

            // 播放翻页声音
            const sound = document.getElementById('page-flip-sound');
            if (sound) {
              sound.currentTime = 0;
              sound.play().catch(e => console.log('翻页音效播放失败:', e));
            }
            this.goToTalentPage(nextPage);

          }

        }



        // 更新页面指示器

        updatePageIndicator() {

          const titleElement = document.getElementById('current-page-title');

          const numberElement = document.getElementById('page-number');

          

          if (titleElement) {

            titleElement.textContent = this.talentPageTitles[this.currentTalentPage];

          }

          

          if (numberElement) {

            numberElement.textContent = `第 ${this.currentTalentPage + 1} 页 / 共 ${this.talentPageTitles.length} 页`;

          }

        }



        // 更新翻页按钮状态

        updatePageButtons() {

          const prevBtn = document.getElementById('prev-page-btn');

          const nextBtn = document.getElementById('next-page-btn');

          

          if (prevBtn) {

            prevBtn.disabled = this.currentTalentPage === 0;

            prevBtn.style.opacity = this.currentTalentPage === 0 ? '0.5' : '1';

          }

          

          if (nextBtn) {

            const nextPage = this.currentTalentPage + 1;

            const nextLevel = this.getLevelByPageIndex(nextPage);

            

            // 检查下一层级是否已解锁

            const isNextLevelUnlocked = !nextLevel || this.isLevelUnlocked(nextLevel);

            const isLastPage = this.currentTalentPage === this.talentPageTitles.length - 1;

            

            nextBtn.disabled = isLastPage || !isNextLevelUnlocked;

            nextBtn.style.opacity = (isLastPage || !isNextLevelUnlocked) ? '0.5' : '1';

            

            // 如果下一层级未解锁，添加提示

            if (!isLastPage && !isNextLevelUnlocked) {

              nextBtn.title = `需要先完成 ${this.getLevelChineseName(this.getPreviousLevel(nextLevel))} 层级`;

            } else {

              nextBtn.title = '';

            }

          }

        }



        // 添加键盘事件监听

        addKeyboardListeners() {

          this.keyboardHandler = (e) => {

            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {

              e.preventDefault();

              this.prevTalentPage();

            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {

              e.preventDefault();

              this.nextTalentPage();

            } else if (e.key === 'Escape') {

              e.preventDefault();

              this.closeTalentsModal();

            }

          };

          

          document.addEventListener('keydown', this.keyboardHandler);

        }



        // 移除键盘事件监听

        removeKeyboardListeners() {

          if (this.keyboardHandler) {

            document.removeEventListener('keydown', this.keyboardHandler);

            this.keyboardHandler = null;

          }

        }



        // 关闭天赋模态框

        closeTalentsModal() {

          const modal = document.getElementById('talents-modal');

          if (modal) {

            modal.style.display = 'none';

            modal.style.justifyContent = '';

            modal.style.alignItems = '';

            this.removeKeyboardListeners();

          }

        }



        // 测试MVU注入功能

        async testMvuInjection() {

          try {

            console.log('🧪 测试MVU注入功能...');

            

            if (typeof Mvu !== 'undefined' && Mvu.setMvuVariable) {

              const mvuData = Mvu.getMvuData({ type: 'chat' });

              

              // 测试注入一个天赋

              await Mvu.setMvuVariable(mvuData, '训练员.天赋.小天赋.萌芽[0]', '测试天赋', {

                reason: '测试注入',

                is_recursive: true,

              });



              await Mvu.replaceMvuData(mvuData, { type: 'chat' });

              

              console.log('✅ MVU注入测试成功！');

              alert('MVU注入测试成功！请检查天赋界面');

            } else {

              console.warn('⚠️ MVU API 不可用');

              alert('MVU API 不可用');

            }

          } catch (error) {

            console.error('❌ MVU注入测试失败:', error);

            alert('MVU注入测试失败: ' + error.message);

          }

        }



        // 检查MVU状态

        checkMvuStatus() {

          console.log('🔍 检查MVU状态...');

          

          // 检查MVU对象

          console.log('📊 MVU对象:', typeof Mvu);

          if (typeof Mvu !== 'undefined') {

            console.log('✅ MVU对象存在');

            console.log('📋 MVU函数:', {

              getMvuData: typeof Mvu.getMvuData,

              setMvuVariable: typeof Mvu.setMvuVariable,

              replaceMvuData: typeof Mvu.replaceMvuData,

              getMvuVariable: typeof Mvu.getMvuVariable

            });

          } else {

            console.error('❌ MVU对象不存在');

          }



          // 尝试获取MVU数据

          try {

            const mvuData = Mvu.getMvuData({ type: 'chat' });

            console.log('📊 MVU数据获取:', mvuData ? '成功' : '失败');

            console.log('📋 MVU数据内容:', mvuData);

          } catch (error) {

            console.error('❌ MVU数据获取失败:', error);

          }



          // 检查当前结晶数量

          try {

            const mvuData = Mvu.getMvuData({ type: 'chat' });

            const crystals = Mvu.getMvuVariable(mvuData, '训练员.畸形情感结晶[0]', { default_value: 0 });

            console.log('💎 当前结晶数量:', crystals);

          } catch (error) {

            console.error('❌ 结晶数量获取失败:', error);

          }



          alert('MVU状态检查完成，请查看控制台');

        }



        // 新增：重新生成AI回答

        async rerollAIResponse() {

          try {

            if (!this.lastSentPrompt) {

              alert('没有找到上一条指令！');

              return;

            }



            // 加载自动存档

            const autoSaveData = localStorage.getItem('teresen_auto_save');

            if (autoSaveData) {

              const saveData = JSON.parse(autoSaveData);

              if (saveData.mvu_data) {

                // 直接设置变量，不调用MVU
                this.currentMvuState = saveData.mvu_data;
                this.renderUI(this.currentMvuState.stat_data);

              }

            }



            // 重新发送上一条指令

            const actionInput = document.getElementById('action-input');

            if (actionInput) {

              actionInput.value = this.lastSentPrompt;

              await this.handleActionSubmit();

            }



            alert('正在重新生成AI回答...');

          } catch (error) {

            console.error('重新生成失败:', error);

            alert('重新生成失败！');

          }

        }



        // 新增：完整的存档管理器模态框

        openSaveManagerModal() {

          const modalId = 'saveManagerModal';

          if (document.getElementById(modalId)) {

            return; // 已打开

          }



          const html = `

              <div id="${modalId}" class="rules-modal" style="display: flex;">

                <div class="rules-modal-content" style="max-width: 900px; width: 95%; max-height: 80vh;">

                  <div class="rules-modal-header">

                    <h2 class="rules-title">特雷森学院 · 存档管理</h2>

                    <button class="close-rules-btn" id="closeSaveManager">×</button>

                  </div>

                  <div class="rules-modal-body">

                    <div class="save-manager-toolbar" style="margin-bottom: 20px; display: flex; gap: 10px; padding: 15px; background: rgba(139, 105, 20, 0.1); border: 1px solid rgba(139, 105, 20, 0.3); border-radius: 6px;">

                      <button class="save-button" id="createSaveNow" style="background: linear-gradient(135deg, #2d1b1b, #3d2b2b); border: 1px solid #8b0000; color: #e8d5d5; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 6px;">

                        <span style="font-size: 16px;">💾</span>

                        <span>立即存档</span>

                      </button>

                      <button class="save-button" id="refreshSaveList" style="background: linear-gradient(135deg, #2d1b1b, #3d2b2b); border: 1px solid #8b0000; color: #e8d5d5; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 6px;">

                        <span style="font-size: 16px;">🔄</span>

                        <span>刷新列表</span>

                      </button>

                      <button class="save-button" id="rerollAIResponse" style="background: linear-gradient(135deg, #2d1b1b, #3d2b2b); border: 1px solid #8b0000; color: #e8d5d5; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 6px;">

                        <span style="font-size: 16px;">🎲</span>

                        <span>重新生成AI回答</span>

                      </button>

                    </div>

                    <div class="save-manager-sections" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">

                      <div class="save-manager-section" style="background: rgba(139, 105, 20, 0.05); border: 1px solid rgba(139, 105, 20, 0.2); border-radius: 6px; padding: 15px;">

                        <h3 class="rules-section-title">🔄 自动存档</h3>

                        <div id="auto-save-container" class="save-manager-list" style="max-height: 300px; overflow-y: auto; border: 1px solid rgba(139, 105, 20, 0.3); border-radius: 6px; padding: 10px; background: rgba(139, 105, 20, 0.05);"></div>

                      </div>

                      <div class="save-manager-section" style="background: rgba(139, 105, 20, 0.05); border: 1px solid rgba(139, 105, 20, 0.2); border-radius: 6px; padding: 15px;">

                        <h3 class="rules-section-title">💾 手动存档</h3>

                        <div id="manual-save-container" class="save-manager-list" style="max-height: 300px; overflow-y: auto; border: 1px solid rgba(139, 105, 20, 0.3); border-radius: 6px; padding: 10px; background: rgba(139, 105, 20, 0.05);"></div>

                      </div>

                    </div>

                  </div>

                </div>

              </div>

            `;



          document.body.insertAdjacentHTML('beforeend', html);



          // 绑定关闭事件

          document.getElementById('closeSaveManager').addEventListener('click', () => {

            document.getElementById(modalId).remove();

          });



          // 点击背景关闭

          document.getElementById(modalId).addEventListener('click', e => {

            if (e.target.id === modalId) {

              document.getElementById(modalId).remove();

            }

          });



          // 绑定按钮事件

          document.getElementById('createSaveNow').addEventListener('click', async () => {

            await this.createSaveWithPrompt();

            this.loadSaveList();

          });



          document.getElementById('refreshSaveList').addEventListener('click', () => {

            this.loadSaveList();

          });



          document.getElementById('rerollAIResponse').addEventListener('click', async () => {

            await this.performReroll();

            document.getElementById(modalId).remove();

          });



          // 加载存档列表

          this.loadSaveList();

        }



        // 新增：创建存档（带提示）

        async createSaveWithPrompt() {

          const saveName = prompt('请输入存档名称:');

          if (!saveName) return;



          try {

            const currentVariables = this.getAllVariables();

            const chatMessages = await getChatMessages(0);

            const currentMessage = chatMessages && chatMessages.length > 0 ? chatMessages[0].message : '';



            const saveData = {

              timestamp: Date.now(),

              save_name: saveName,

              mvu_data: currentVariables,

              message_content: currentMessage,

              type: 'manual',

            };



            // 生成唯一ID

            const saveId = `save_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            localStorage.setItem(`teresen_${saveId}`, JSON.stringify(saveData));



            alert('存档成功！');

          } catch (error) {

            console.error('存档失败:', error);

            alert('存档失败！');

          }

        }



        // 新增：加载存档列表

        loadSaveList() {

          this.loadAutoSaveList();

          this.loadManualSaveList();

        }



        // 新增：加载自动存档列表

        loadAutoSaveList() {

          const container = document.getElementById('auto-save-container');

          if (!container) return;



          // 获取所有自动存档

          const autoSaves = [];

          for (let i = 0; i < localStorage.length; i++) {

            const key = localStorage.key(i);

            if (key && key.startsWith('teresen-auto-save-')) {

              try {

                const saveData = JSON.parse(localStorage.getItem(key));

                autoSaves.push({ key, data: saveData });

              } catch (e) {

                console.warn('解析自动存档失败:', key, e);

              }

            }

          }



          // 按时间排序，最新的在前

          autoSaves.sort((a, b) => b.data.timestamp - a.data.timestamp);



          // 只显示最近5个

          const recentSaves = autoSaves.slice(0, 5);



          let html = '';

          if (recentSaves.length > 0) {

            html = recentSaves

              .map((save, index) => {

                const date = new Date(save.data.timestamp).toLocaleString('zh-CN');

                const summary = this._getDisplayText(save.data.message_content)

                  .replace(/[\n\r]+/g, ' ')

                  .trim();



                return `

                <div class="save-manager-item save-manager-auto-item" style="background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 6px; padding: 12px; margin-bottom: 8px; transition: all 0.2s;">

                  <div class="save-manager-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">

                    <div class="save-manager-title" style="display: flex; align-items: center; gap: 8px;">

                      <span style="color: #22c55e; font-size: 16px;">🔄</span>

                      <span style="font-weight: bold; color: #ffffff; font-size: 14px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">自动存档 #${index + 1}</span>

                    </div>

                    <div class="save-manager-time" style="color: #ffffff; font-size: 11px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${date}</div>

                  </div>

                  <div class="save-manager-content" style="margin-bottom: 10px;">

                    <div class="save-manager-summary" style="color: #ffffff; font-size: 12px; line-height: 1.4; background: rgba(0,0,0,0.4); padding: 8px; border-radius: 4px; max-height: 60px; overflow: hidden; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">

                      ${summary ? summary : '无正文记录'}

                    </div>

                  </div>

                  <div class="save-manager-actions" style="display: flex; gap: 6px; justify-content: flex-end;">

                    <button class="save-button" onclick="n.loadAutoSave('${save.key}')" style="background: linear-gradient(135deg, #22c55e, #16a34a); border: 1px solid #22c55e; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">

                      <span style="font-size: 14px;">📖</span>

                      <span>读档</span>

                    </button>

                    <button class="save-button" onclick="n.viewSaveDetails('${save.key}')" style="background: linear-gradient(135deg, #3b82f6, #2563eb); border: 1px solid #3b82f6; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">

                      <span style="font-size: 14px;">👁️</span>

                      <span>详情</span>

                    </button>

                  </div>

                </div>

              `;

              })

              .join('');

          } else {

            html =

              '<div class="save-manager-empty" style="text-align: center; color: #8b4513; padding: 1rem; font-size: 0.875rem; font-style: italic;">暂无自动存档</div>';

          }



          container.innerHTML = html;

        }



        // 新增：加载手动存档列表

        loadManualSaveList() {

          const container = document.getElementById('manual-save-container');

          if (!container) return;



          const saves = [];

          for (let i = 0; i < localStorage.length; i++) {

            const key = localStorage.key(i);

            if (key && key.startsWith('teresen_save_')) {

              try {

                const saveData = JSON.parse(localStorage.getItem(key));

                saves.push({ key, data: saveData });

              } catch (e) {

                console.warn('解析存档失败:', key, e);

              }

            }

          }



          // 按时间排序

          saves.sort((a, b) => b.data.timestamp - a.data.timestamp);



          let html = '';

          if (saves.length > 0) {

            html = saves

              .map(save => {

                const date = new Date(save.data.timestamp).toLocaleString('zh-CN');

                const summary = this._getDisplayText(save.data.message_content)

                  .replace(/[\n\r]+/g, ' ')

                  .trim();



                return `

                <div class="save-manager-item save-manager-manual-item" style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 6px; padding: 12px; margin-bottom: 8px; transition: all 0.2s;">

                  <div class="save-manager-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">

                    <div class="save-manager-title" style="display: flex; align-items: center; gap: 8px;">

                      <span style="color: #3b82f6; font-size: 16px;">💾</span>

                      <span style="font-weight: bold; color: #ffffff; font-size: 14px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${save.data.save_name}</span>

                    </div>

                    <div class="save-manager-time" style="color: #ffffff; font-size: 11px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${date}</div>

                  </div>

                  <div class="save-manager-content" style="margin-bottom: 10px;">

                    <div class="save-manager-summary" style="color: #ffffff; font-size: 12px; line-height: 1.4; background: rgba(0,0,0,0.4); padding: 8px; border-radius: 4px; max-height: 60px; overflow: hidden; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">

                      ${summary ? summary : '无正文记录'}

                    </div>

                  </div>

                  <div class="save-manager-actions" style="display: flex; gap: 6px; justify-content: flex-end; flex-wrap: wrap;">

                    <button class="save-button" onclick="n.loadManualSave('${save.key}')" style="background: linear-gradient(135deg, #22c55e, #16a34a); border: 1px solid #22c55e; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">

                      <span style="font-size: 14px;">📖</span>

                      <span>读档</span>

                    </button>

                    <button class="save-button" onclick="n.renameSave('${save.key}', '${save.data.save_name}')" style="background: linear-gradient(135deg, #f59e0b, #d97706); border: 1px solid #f59e0b; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">

                      <span style="font-size: 14px;">✏️</span>

                      <span>重命名</span>

                    </button>

                    <button class="save-button" onclick="n.viewSaveDetails('manual', '${save.key}')" style="background: linear-gradient(135deg, #3b82f6, #2563eb); border: 1px solid #3b82f6; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">

                      <span style="font-size: 14px;">👁️</span>

                      <span>详情</span>

                    </button>

                    <button class="save-button" onclick="n.deleteManualSave('${save.key}')" style="background: linear-gradient(135deg, #ef4444, #dc2626); border: 1px solid #ef4444; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">

                      <span style="font-size: 14px;">🗑️</span>

                      <span>删除</span>

                    </button>

                  </div>

                </div>

              `;

              })

              .join('');

          } else {

            html =

              '<div class="save-manager-empty" style="text-align: center; color: #8b4513; padding: 1rem; font-size: 0.875rem; font-style: italic;">暂无手动存档</div>';

          }



          container.innerHTML = html;

        }



        // 新增：加载自动存档

        async loadAutoSave() {

          try {

            const autoSaveData = localStorage.getItem('teresen_auto_save');

            if (!autoSaveData) {

              alert('没有自动存档！');

              return;

            }



            const saveData = JSON.parse(autoSaveData);

            await this.restoreSaveData(saveData);

            alert('自动存档加载成功！');

            document.getElementById('saveManagerModal').remove();

          } catch (error) {

            console.error('加载自动存档失败:', error);

            alert('加载自动存档失败！');

          }

        }



        // 新增：加载手动存档

        async loadManualSave(saveKey) {

          try {

            const savedData = localStorage.getItem(saveKey);

            if (!savedData) {

              alert('存档不存在！');

              return;

            }



            const saveData = JSON.parse(savedData);

            await this.restoreSaveData(saveData);

            alert('手动存档加载成功！');

            document.getElementById('saveManagerModal').remove();

          } catch (error) {

            console.error('加载手动存档失败:', error);

            alert('加载手动存档失败！');

          }

        }



        // 新增：删除手动存档

        deleteManualSave(saveKey) {

          if (!confirm('确定要删除这个存档吗？')) return;



          try {

            localStorage.removeItem(saveKey);

            alert('删除成功！');

            this.loadManualSaveList();

          } catch (error) {

            console.error('删除失败:', error);

            alert('删除失败！');

          }

        }



        // 新增：恢复存档数据的通用方法

        async restoreSaveData(saveData) {

          // 恢复变量状态

          if (saveData.mvu_data) {

                          // 直接设置变量，不调用MVU
              this.currentMvuState = saveData.mvu_data;
              this.renderUI(this.currentMvuState.stat_data);

          }



          // 恢复聊天消息

          if (saveData.message_content) {

            const chatMessages = await getChatMessages(0);

            if (chatMessages && chatMessages.length > 0) {

              const firstMessage = chatMessages[0];

              firstMessage.message = saveData.message_content;

              firstMessage.data = saveData.mvu_data;

              await TavernHelper.setChatMessages([firstMessage], { refresh: 'none' });

            }

          }



          // 更新界面

          await this.updateDynamicData();

        }



        // 新增：查看存档详情

        async viewSaveDetails(type, saveKey = null) {

          try {

            let saveData;

            if (type === 'auto') {

              const autoSaveData = localStorage.getItem('teresen_auto_save');

              if (!autoSaveData) {

                alert('没有自动存档！');

                return;

              }

              saveData = JSON.parse(autoSaveData);

            } else {

              const savedData = localStorage.getItem(saveKey);

              if (!savedData) {

                alert('存档不存在！');

                return;

              }

              saveData = JSON.parse(savedData);

            }



            const date = new Date(saveData.timestamp).toLocaleString('zh-CN');

            const summary = this._getDisplayText(saveData.message_content);



            const detailsHtml = `

              <div style="max-width: 600px; max-height: 400px; overflow-y: auto; background: #2d1b1b; border: 2px solid #8b4513; border-radius: 8px; padding: 20px; color: #e0e0e0;">

                <h3 style="color: #e0e0e0; margin-bottom: 15px; text-align: center; border-bottom: 1px solid #8b4513; padding-bottom: 10px;">📋 存档详情</h3>

                <div style="background: rgba(139, 69, 19, 0.2); padding: 15px; border-radius: 6px; margin-bottom: 15px; border: 1px solid rgba(139, 69, 19, 0.5);">

                  <div style="margin-bottom: 10px;">

                    <strong style="color: #e0e0e0;">📝 存档名称:</strong> 

                    <span style="color: #c0c0c0;">${saveData.save_name || '自动存档'}</span>

                  </div>

                  <div style="margin-bottom: 10px;">

                    <strong style="color: #e0e0e0;">🕐 保存时间:</strong> 

                    <span style="color: #c0c0c0;">${date}</span>

                  </div>

                  <div style="margin-bottom: 10px;">

                    <strong style="color: #e0e0e0;">🏷️ 存档类型:</strong> 

                    <span style="color: #c0c0c0;">${type === 'auto' ? '自动存档' : '手动存档'}</span>

                  </div>

                </div>

                <div style="background: rgba(139, 69, 19, 0.2); padding: 15px; border-radius: 6px; border: 1px solid rgba(139, 69, 19, 0.5);">

                  <strong style="color: #e0e0e0; display: block; margin-bottom: 10px;">💬 对话内容:</strong>

                  <div style="color: #c0c0c0; line-height: 1.6; white-space: pre-wrap; max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-size: 13px;">${summary || '无内容'}</div>

                </div>

              </div>

            `;



            // 创建一个模态框来显示详情，而不是用alert

            const detailModalId = 'saveDetailModal';

            if (document.getElementById(detailModalId)) {

              document.getElementById(detailModalId).remove();

            }



            const detailModalHtml = `

              <div id="${detailModalId}" class="rules-modal" style="display: flex; z-index: 10001;">

                <div class="rules-modal-content" style="max-width: 700px; width: 90%; max-height: 80vh; overflow-y: auto;">

                  <div class="rules-modal-header">

                    <h2 class="rules-title">存档详情</h2>

                    <button class="close-rules-btn" onclick="document.getElementById('${detailModalId}').remove()">×</button>

                  </div>

                  <div class="rules-modal-body">

                    ${detailsHtml}

                  </div>

                </div>

              </div>

            `;



            document.body.insertAdjacentHTML('beforeend', detailModalHtml);



            // 点击背景关闭

            document.getElementById(detailModalId).addEventListener('click', e => {

              if (e.target.id === detailModalId) {

                document.getElementById(detailModalId).remove();

              }

            });

          } catch (error) {

            console.error('查看存档详情失败:', error);

            alert('查看存档详情失败！');

          }

        }



        // 新增：重命名存档

        async renameSave(saveKey, currentName) {

          try {

            const newName = prompt('请输入新的存档名称:', currentName);

            if (!newName || newName === currentName) return;



            const savedData = localStorage.getItem(saveKey);

            if (!savedData) {

              alert('存档不存在！');

              return;

            }



            const saveData = JSON.parse(savedData);

            saveData.save_name = newName;



            localStorage.setItem(saveKey, JSON.stringify(saveData));

            alert('重命名成功！');



            // 刷新列表

            this.loadSaveList();

          } catch (error) {

            console.error('重命名存档失败:', error);

            alert('重命名失败！');

          }

        }



        // 新增：获取显示文本的辅助方法

        _getDisplayText(text) {

          if (!text) return '';



          // 移除HTML标签

          let cleanText = text.replace(/<[^>]*>/g, '');



          // 移除多余的空白字符

          cleanText = cleanText.replace(/\s+/g, ' ').trim();



          // 限制长度

          if (cleanText.length > 200) {

            cleanText = cleanText.substring(0, 200) + '...';

          }



          return cleanText;

        }



        // 新增：重新生成AI回答

        async performReroll() {

          try {

            // 加载自动存档

            const autoSaveData = localStorage.getItem('teresen_auto_save');

            if (!autoSaveData) {

              alert('没有自动存档，无法重新生成！');

              return;

            }



            const saveData = JSON.parse(autoSaveData);



            // 恢复存档状态

            await this.restoreSaveData(saveData);



            // 获取上次的提示词

            const lastPrompt = this.lastSentPrompt;

            if (!lastPrompt) {

              alert('没有找到上次的提示词！');

              return;

            }



            // 设置输入框的值

            const actionInput = document.getElementById('action-input');

            if (actionInput) {

              actionInput.value = lastPrompt;

            }



            // 重新提交

            await this.handleActionSubmit();



            alert('重新生成成功！');

          } catch (error) {

            console.error('重新生成失败:', error);

            alert('重新生成失败！');

          }

        }

      })();

      if ('undefined' != typeof eventOn && void 0 !== window.tavern_events) {

        const e = window.tavern_events;

        eventOn(e.APP_READY, () => {

          (console.log('🎯 酒馆环境就绪，开始初始化特雷森界面...'), n.init());

        });

      } else

        (console.warn('⚠️ 酒馆事件API不可用，使用传统初始化方式'),

          setTimeout(() => {

            n.init();

          }, 2e3));

    </script>

    <style>

      /* 新增：状态判定动画和塔罗buff系统样式 */
      
      /* 状态动画容器 */
      .status-animation-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.5s ease;
      }

      .status-animation-container.show {
        opacity: 1;
      }

      .status-animation {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #d4af37;
        border-radius: 1rem;
        padding: 2rem;
        text-align: center;
        color: white;
        box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
        max-width: 500px;
        transform: scale(0.8);
        transition: transform 0.5s ease;
      }

      .status-animation-container.show .status-animation {
        transform: scale(1);
      }

      .status-title {
        font-size: 2rem;
        font-weight: bold;
        color: #d4af37;
        margin-bottom: 1rem;
        text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
      }

      .status-content {
        margin-bottom: 1rem;
      }





      .status-message {
        font-size: 1rem;
        color: #e5e7eb;
        margin-top: 1rem;
        font-style: italic;
      }

      .status-hint {
        font-size: 0.9rem;
        color: #d4af37;
        margin-top: 0.5rem;
        font-style: italic;
        opacity: 0.8;
      }

      /* 不同状态类型的特殊样式 */
      .status-animation-container.critical .status-animation {
        border-color: #dc2626;
        box-shadow: 0 0 40px rgba(220, 38, 38, 0.6);
        animation: criticalShake 0.5s ease-in-out infinite;
      }

      .status-animation-container.stamina .status-animation {
        border-color: #ef4444;
        box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
      }

      .status-animation-container.sanity .status-animation {
        border-color: #8b5cf6;
        box-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
      }

      @keyframes criticalShake {
        0%, 100% { transform: scale(1) rotate(0deg); }
        25% { transform: scale(1.02) rotate(-1deg); }
        75% { transform: scale(1.02) rotate(1deg); }
      }

      /* Buff通知样式 */
      .buff-notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #d4af37;
        border-radius: 1rem;
        padding: 1.5rem;
        color: white;
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        z-index: 10000;
        max-width: 350px;
        transform: translateX(100%);
        transition: transform 0.5s ease;
      }

      .buff-notification.show {
        transform: translateX(0);
      }

      .buff-title {
        font-size: 1.2rem;
        font-weight: bold;
        color: #d4af37;
        margin-bottom: 1rem;
        text-align: center;
      }

      .buff-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .buff-item {
        padding: 0.5rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .buff-item.courage { border-left: 3px solid #ef4444; }
      .buff-item.skill { border-left: 3px solid #3b82f6; }
      .buff-item.intuition { border-left: 3px solid #8b5cf6; }
      .buff-item.fertility { border-left: 3px solid #10b981; }
      .buff-item.authority { border-left: 3px solid #f59e0b; }
      .buff-item.harmony { border-left: 3px solid #06b6d4; }
      .buff-item.victory { border-left: 3px solid #dc2626; }
      .buff-item.strength { border-left: 3px solid #ea580c; }
      .buff-item.wisdom { border-left: 3px solid #7c3aed; }
      .buff-item.fortune { border-left: 3px solid #fbbf24; }

      .buff-name {
        display: block;
        font-weight: bold;
        color: #d4af37;
        margin-bottom: 0.25rem;
      }

      .buff-effect {
        display: block;
        font-size: 0.9rem;
        color: #e5e7eb;
        margin-bottom: 0.25rem;
      }

      .buff-duration {
        display: block;
        font-size: 0.8rem;
        color: #9ca3af;
      }



      .tarot-result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #d4af37;
        padding-bottom: 1rem;
      }

      .tarot-result-header h2 {
        color: #d4af37;
        margin: 0;
      }

      .tarot-result-header button {
        background: none;
        border: none;
        color: #d4af37;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 0.5rem;
        transition: background-color 0.2s;
      }

      .tarot-result-header button:hover {
        background: rgba(212, 175, 55, 0.2);
      }

      .tarot-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
      }

      .tarot-card {
        background: linear-gradient(135deg, #2d3748, #4a5568);
        border: 1px solid #d4af37;
        border-radius: 0.5rem;
        padding: 1rem;
        text-align: center;
        transition: transform 0.2s;
      }

      .tarot-card:hover {
        transform: translateY(-5px);
      }

      .tarot-card.reversed {
        border-color: #ef4444;
      }

      .card-name {
        font-size: 1.1rem;
        font-weight: bold;
        color: #d4af37;
        margin-bottom: 0.5rem;
      }

      .card-meaning {
        font-size: 0.9rem;
        color: #e5e7eb;
        margin-bottom: 0.5rem;
        line-height: 1.4;
      }

      .card-position {
        font-size: 0.8rem;
        color: #9ca3af;
        font-style: italic;
      }

      .tarot-advice {
        background: rgba(212, 175, 55, 0.1);
        border: 1px solid #d4af37;
        border-radius: 0.5rem;
        padding: 1rem;
      }

      .tarot-advice h3 {
        color: #d4af37;
        margin: 0 0 0.5rem 0;
      }

      .tarot-advice p {
        color: #e5e7eb;
        margin: 0;
        line-height: 1.5;
      }

      /* 塔罗buff弹窗 */
      .tarot-buffs-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .tarot-buffs-modal.show {
        opacity: 1;
      }

      .tarot-buffs-content {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #d4af37;
        border-radius: 1rem;
        padding: 2rem;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        transform: scale(0.8);
        transition: transform 0.3s ease;
      }

      .tarot-buffs-modal.show .tarot-buffs-content {
        transform: scale(1);
      }

      .tarot-buffs-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #d4af37;
        padding-bottom: 1rem;
      }

      .tarot-buffs-header h2 {
        color: #d4af37;
        margin: 0;
      }

      .tarot-buffs-header button {
        background: none;
        border: none;
        color: #d4af37;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 0.5rem;
        transition: background-color 0.2s;
      }

      .tarot-buffs-header button:hover {
        background: rgba(212, 175, 55, 0.2);
      }

      .tarot-buffs-body {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .tarot-buffs-body .buff-item {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 0.5rem;
        padding: 1rem;
      }

      .buff-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
      }

      .buff-remaining {
        font-size: 0.8rem;
        color: #9ca3af;
        font-style: italic;
      }

      .buff-source {
        font-size: 0.8rem;
        color: #6b7280;
        font-style: italic;
        margin-top: 0.5rem;
      }

      /*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */

      @layer properties {

        @supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or

          ((-moz-orient: inline) and (not (color: rgb(from red r g b)))) {

          *,

          :before,

          :after,

          ::backdrop {

            --tw-rotate-x: initial;

            --tw-rotate-y: initial;

            --tw-rotate-z: initial;

            --tw-skew-x: initial;

            --tw-skew-y: initial;

            --tw-border-style: solid;

            --tw-shadow: 0 0 #0000;

            --tw-shadow-color: initial;

            --tw-shadow-alpha: 100%;

            --tw-inset-shadow: 0 0 #0000;

            --tw-inset-shadow-color: initial;

            --tw-inset-shadow-alpha: 100%;

            --tw-ring-color: initial;

            --tw-ring-shadow: 0 0 #0000;

            --tw-inset-ring-color: initial;

            --tw-inset-ring-shadow: 0 0 #0000;

            --tw-ring-inset: initial;

            --tw-ring-offset-width: 0px;

            --tw-ring-offset-color: #fff;

            --tw-ring-offset-shadow: 0 0 #0000;

            --tw-outline-style: solid;

            --tw-backdrop-blur: initial;

            --tw-backdrop-brightness: initial;

            --tw-backdrop-contrast: initial;

            --tw-backdrop-grayscale: initial;

            --tw-backdrop-hue-rotate: initial;

            --tw-backdrop-invert: initial;

            --tw-backdrop-opacity: initial;

            --tw-backdrop-saturate: initial;

            --tw-backdrop-sepia: initial;

          }

        }

      }

      .absolute {

        position: absolute;

      }

      .fixed {

        position: fixed;

      }

      .block {

        display: block;

      }

      .flex {

        display: flex;

      }

      .hidden {

        display: none;

      }

      .flex-shrink {

        flex-shrink: 1;

      }

      .transform {

        transform: var(--tw-rotate-x,) var(--tw-rotate-y,) var(--tw-rotate-z,) var(--tw-skew-x,) var(--tw-skew-y,);

      }

      .resize {

        resize: both;

      }

      .flex-wrap {

        flex-wrap: wrap;

      }

      .border {

        border-style: var(--tw-border-style);

        border-width: 1px;

      }

      .ring {

        --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width))

          var(--tw-ring-color, currentcolor);

        box-shadow:

          var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow),

          var(--tw-shadow);

      }

      .outline {

        outline-style: var(--tw-outline-style);

        outline-width: 1px;

      }

      .backdrop-filter {

        backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,)

          var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,)

          var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);

      }

      .transition {

        transition-property:

          color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from,

          --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter,

          backdrop-filter, display, visibility, content-visibility, overlay, pointer-events;

        transition-timing-function: var(--tw-ease, ease);

        transition-duration: var(--tw-duration, 0s);

      }

      @layer base {

        html {

          font-family:

            Noto Sans SC,

            Georgia,

            Times New Roman,

            serif;

        }

        body {

          color: #2d2d2d;

          background: linear-gradient(135deg, #f8f2e6 0%, #f2e8d8 25%, #ecddc7 50%, #e6d3b6 75%, #e0c8a5 100%) fixed;

          margin: 0;

          padding: 0;

          font-family:

            Georgia,

            Times New Roman,

            serif;

        }

      }

      @layer components {

        .leather-journal {

          background: linear-gradient(145deg, #faf6f0 0%, #f5f0e8 50%, #f0eae0 100%);

          border: 2px solid #8b6914;

          min-height: 600px;

          position: relative;

          box-shadow:

            inset 0 0 20px #8b691433,

            0 4px 8px #0000004d;

        }

        .leather-journal:before {

          content: '';

          pointer-events: none;

          background-image:

            radial-gradient(circle at 15% 25%, #8b691414 1px, #0000 2px),

            radial-gradient(circle at 85% 75%, #6543210f 1px, #0000 2px),

            radial-gradient(circle at 45% 60%, #a086590a 1px, #0000 2px);

          background-size:

            40px 40px,

            60px 60px,

            80px 80px;

          position: absolute;

          top: 0;

          right: 0;

          bottom: 0;

          left: 0;

        }

        .connected-panels {

          z-index: 2;

          border-radius: 8px;

          grid-template-rows: auto 1fr auto;

          grid-template-columns: 250px 1fr 200px;

          gap: 0;

          width: 100%;

          max-width: 1600px;

          height: 575px;

          margin: auto;

          transition: all 0.3s;

          display: grid;

          position: relative;

          overflow: hidden;

          box-shadow: 0 8px 16px #00000080;

        }

        .connected-panels.fullscreen-active {

          z-index: 9999;

          border-radius: 0;

          width: 100vw;

          max-width: none;

          height: 100vh;

          margin: 0;

          position: fixed;

          top: 0;

          left: 0;

        }

        .connected-panels.fullscreen-active .panel-content {

          z-index: 10000;

        }

        .connected-panels.fullscreen-active .save-section {

          z-index: 10001;

          position: relative;

        }

        .connected-panels.fullscreen-active ~ .rules-modal {

          z-index: 10002;

        }

        .connected-panels.fullscreen-active ~ .rules-modal .rules-modal-content {

          z-index: 10003;

        }

        .connected-panels.fullscreen-active ~ .danger-modal,

        .connected-panels.fullscreen-active ~ #load-modal,

        .connected-panels.fullscreen-active ~ #rules-modal,

        .connected-panels.fullscreen-active ~ #command-modal {

          z-index: 10002;

        }

        .danger-modal,

        #load-modal,

        #rules-modal {

          z-index: 10000;

        }

        .parchment-page {

          color: #2d2d2d;

          background-color: #fdfbf7;

          border: 1px solid #8b6914;

          flex-direction: column;

          display: flex;

          position: relative;

          box-shadow: inset 0 0 20px #8b69141a;

        }

        .parchment-page:before {

          content: '';

          pointer-events: none;

          background-image:

            radial-gradient(circle at 20% 30%, #8b69140d 2px, #0000 4px),

            radial-gradient(circle at 80% 70%, #a086590a 1px, #0000 3px);

          background-size:

            60px 60px,

            40px 40px;

          position: absolute;

          top: 0;

          right: 0;

          bottom: 0;

          left: 0;

        }

        .left-panel {

          grid-area: 1/1/3;

          width: 100%;

          height: 100%;

          overflow: hidden auto;

        }

        .center-panel {

          flex-direction: column;

          grid-area: 1/2/3;

          width: 100%;

          height: 100%;

          display: flex;

          overflow: hidden auto;

        }

        .right-panel {

          flex-direction: column;

          grid-area: 1/3/3;

          gap: 0.75rem;

          width: 100%;

          height: 100%;

          display: flex;

          overflow: hidden auto;

        }

        .panel-content {

          z-index: 1;

          flex-direction: column;

          height: 100%;

          padding: 0.75rem;

          font-size: 1rem;

          display: flex;

          position: relative;

          overflow-y: auto;

        }

        .panel-divider {

          background: linear-gradient(#8b6914, #a0865a, #8b6914);

          width: 3px;

          height: 100%;

          position: relative;

          box-shadow:

            inset 0 0 4px #0000004d,

            0 0 8px #8b691433;

        }

        .panel-divider:before {

          content: '';

          background: linear-gradient(#0000 0%, #ffffff1a 50%, #0000 100%);

          position: absolute;

          top: 0;

          right: 0;

          bottom: 0;

          left: 0;

        }

        .panel-divider:after {

          content: '';

          background: radial-gradient(circle, #a0865a, #8b6914);

          border-radius: 50%;

          width: 8px;

          height: 8px;

          position: absolute;

          top: 50%;

          left: 50%;

          transform: translate(-50%, -50%);

          box-shadow: 0 0 4px #0000004d;

        }

        .section-header {

          border-bottom: 1px solid #8b69144d;

          align-items: center;

          gap: 0.5rem;

          margin-bottom: 0.75rem;

          padding-bottom: 0.375rem;

          display: flex;

        }

        .section-header h3 {

          color: #2d2d2d;

          margin: 0;

          font-size: 0.9rem;

          font-weight: 600;

        }

        .icon {

          color: #8b4513;

          width: 1rem;

          height: 1rem;

        }

        .roster-btn {

          cursor: pointer;

          background: 0 0;

          border: none;

          border-radius: 0.25rem;

          margin-left: auto;

          padding: 0.25rem;

          font-size: 1rem;

          color: #8b4513;

          transition: all 0.2s ease;

        }

        .roster-btn:hover {

          background-color: #8b69141a;

          transform: scale(1.1);

        }

        /* 马娘记名册弹窗样式 */
        .roster-modal {
          z-index: 1000;
          backdrop-filter: blur(4px);
          background: #000000b3;
          justify-content: center;
          align-items: center;
          width: 100%;
          height: 100%;
          display: flex;
          position: fixed;
          top: 0;
          left: 0;
        }

        .roster-content {
          background: linear-gradient(135deg, #fdfbf7 0%, #f5f0e8 100%);
          border: 3px solid #8b6914;
          border-radius: 1rem;
          max-width: 600px;
          max-height: 80vh;
          width: 90%;
          overflow: hidden;
          box-shadow: 0 20px 40px #0000004d;
          position: relative;
        }

        .roster-content:before {
          content: '';
          pointer-events: none;
          background-image: radial-gradient(circle at 20% 30%, #8b69140d 2px, #0000 4px), radial-gradient(circle at 80% 70%, #a086590a 1px, #0000 3px);
          background-size: 60px 60px, 40px 40px;
          position: absolute;
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
        }

        .roster-header {
          background: linear-gradient(135deg, #8b6914, #a0865a);
          color: #fdfbf7;
          padding: 1rem 1.5rem;
          display: flex;
          justify-content: space-between;
          align-items: center;
          border-bottom: 2px solid #654321;
        }

        .roster-header h2 {
          margin: 0;
          font-size: 1.2rem;
          font-weight: 600;
        }

        .roster-close-btn {
          background: none;
          border: none;
          color: white;
          font-size: 1.5rem;
          cursor: pointer;
          padding: 0;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          transition: background-color 0.2s;
        }

        .roster-close-btn:hover {
          background-color: rgba(255, 255, 255, 0.2);
        }

        .roster-body {
          max-height: 60vh;
          padding: 1.5rem;
          overflow-y: auto;
        }

        .empty-roster {
          text-align: center;
          color: #8b4513;
          font-style: italic;
          padding: 2rem;
        }

        .roster-list {
          display: flex;
          flex-direction: column;
          gap: 1rem;
        }

        .roster-item {
          background: white;
          border: 1px solid #d4af37;
          border-radius: 6px;
          padding: 1rem;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .roster-item-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.5rem;
          border-bottom: 1px solid #f0f0f0;
          padding-bottom: 0.5rem;
        }

        .roster-item-header h3 {
          margin: 0;
          color: #8b4513;
          font-size: 1.1rem;
          font-weight: 600;
        }

        .encounter-count {
          background: #8b4513;
          color: white;
          padding: 0.25rem 0.5rem;
          border-radius: 12px;
          font-size: 0.8rem;
          font-weight: 500;
        }

        .roster-item-details {
          display: flex;
          flex-direction: column;
          gap: 0.5rem;
        }

        .roster-detail {
          color: #2d2d2d;
          font-size: 0.9rem;
          line-height: 1.4;
        }

        .roster-detail strong {
          color: #8b4513;
          font-weight: 600;
        }

        .expand-btn {

          cursor: pointer;

          background: 0 0;

          border: none;

          border-radius: 0.25rem;

          margin-left: auto;

          padding: 0.25rem;

          transition: background-color 0.2s;

        }

        .expand-btn:hover {

          background-color: #8b69141a;

        }

        .save-section {

          gap: 0.5rem;

          margin-bottom: 1.5rem;

          display: flex;

        }

        .save-section .save-button {

          flex: 1;

          min-width: 0;

          padding: 0.375rem;

          font-size: 0.7rem;

        }

        .save-button {

          color: #e8d5d5;

          cursor: pointer;

          text-shadow: 0 1px 2px #00000080;

          background: linear-gradient(135deg, #2d1b1b, #3d2b2b);

          border: 1px solid #8b0000;

          border-radius: 0.25rem;

          justify-content: center;

          align-items: center;

          gap: 0.5rem;

          width: 100%;

          padding: 0.5rem;

          font-size: 0.75rem;

          font-weight: 500;

          transition: all 0.2s;

          display: flex;

          position: relative;

          box-shadow:

            inset 0 1px #ffffff1a,

            0 2px 4px #0006;

        }

        .save-button:before {

          content: '';

          opacity: 0;

          background: linear-gradient(135deg, #8b00001a, #0000);

          transition: opacity 0.2s;

          position: absolute;

          top: 0;

          right: 0;

          bottom: 0;

          left: 0;

        }

        .save-button:hover:before {

          opacity: 1;

        }

        .save-button:hover {

          color: #f0e0e0;

          background: linear-gradient(135deg, #3d2b2b, #4d3b3b);

          border-color: #a00000;

          box-shadow:

            inset 0 1px #ffffff26,

            0 3px 6px #00000080;

        }

        .save-button:active {

          background: linear-gradient(135deg, #1d0b0b, #2d1b1b);

          box-shadow:

            inset 0 2px 4px #0009,

            0 1px 2px #0000004d;

        }

        .status-section {

          margin-bottom: 1rem;

        }

        .status-item {

          margin-bottom: 0.5rem;

        }

        .status-header {

          justify-content: space-between;

          align-items: center;

          margin-bottom: 0.25rem;

          display: flex;

        }

        .status-label {

          color: #2d2d2d;

          font-size: 0.75rem;

          font-weight: 500;

        }

        .status-value {

          color: #8b4513;

          font-size: 0.75rem;

          font-weight: 600;

        }

        .progress-bar {

          background-color: #8b691433;

          border-radius: 9999px;

          height: 0.5rem;

          position: relative;

          overflow: hidden;

        }

        .progress-fill {

          background: linear-gradient(90deg, #059669 0%, #10b981 100%);

          border-radius: 9999px;

          height: 100%;

          transition: width 0.5s;

        }

        .progress-fill.danger {

          background: linear-gradient(90deg, #dc2626 0%, #ef4444 100%);

          animation: 3s ease-in-out infinite subtle-pulse;

        }

        .progress-fill.warning {

          background: linear-gradient(90deg, #d97706 0%, #f59e0b 100%);

        }



        .profile-section,

        .journey-section,

        .inventory-section {

          margin-bottom: 1rem;

        }

        .profile-basic,

        .journey-basic {

          font-size: 0.75rem;

        }

        .profile-item,

        .detail-item {

          justify-content: space-between;

          margin-bottom: 0.25rem;

          display: flex;

        }

        .label {

          color: #6b7280;

          font-weight: 400;

        }

        .value {

          color: #2d2d2d;

          font-weight: 500;

        }

        .status-excellent {

          color: #059669;

          font-weight: 600;

          text-shadow: 0 0 5px rgba(5, 150, 105, 0.3);

        }

        .status-good {

          color: #d97706;

          font-weight: 600;

          text-shadow: 0 0 5px rgba(217, 119, 6, 0.3);

        }

        .status-normal {

          color: #6b7280;

          font-weight: 500;

        }

        .status-bad {

          color: #dc2626;

          font-weight: 600;

          text-shadow: 0 0 5px rgba(220, 38, 38, 0.3);

        }

        .status-terrible {

          color: #7f1d1d;

          font-weight: 700;

          text-shadow: 0 0 8px rgba(127, 29, 29, 0.5);

          animation: 2s ease-in-out infinite subtle-pulse;

        }

        .profile-detail,

        .journey-detail {

          font-size: 0.75rem;

        }

        .detail-card {

          background-color: #8b69141a;

          border: 1px solid #8b6914;

          border-radius: 0.375rem;

          margin-bottom: 0.75rem;

          padding: 0.75rem;

        }

        .anomaly-card {

          background: linear-gradient(45deg, #8b00001a, #8b000033);

          border: 1px solid #8b0000;

          border-radius: 0.375rem;

          padding: 0.75rem;

        }

        .anomaly-card h4 {

          margin: 0 0 0.5rem;

          font-size: 0.875rem;

        }

        .anomaly-list {

          flex-direction: column;

          gap: 0.25rem;

          display: flex;

        }

        .anomaly-item {

          font-size: 0.75rem;

        }

        .profile-link,

        .journey-link {

          color: #8b4513;

          cursor: pointer;

          font-size: 0.75rem;

        }

        .journey-list {

          flex-direction: column;

          gap: 0.5rem;

          max-height: 200px;

          display: flex;

          overflow-y: auto;

        }

        .journey-entry {

          background-color: #8b69141a;

          border-left: 2px solid #8b6914;

          border-radius: 0.25rem;

          padding: 0.5rem;

        }

        .journey-header {

          justify-content: space-between;

          align-items: flex-start;

          margin-bottom: 0.25rem;

          display: flex;

        }

        .journey-day {

          color: #2d2d2d;

          font-weight: 600;

        }

        .journey-status {

          border-radius: 0.125rem;

          padding: 0.125rem 0.25rem;

          font-size: 0.625rem;

          font-weight: 600;

        }

        .journey-status.normal {

          color: #059669;

          background-color: #05966933;

        }

        .journey-status.confused {

          color: #d97706;

          background-color: #d9770633;

        }

        .journey-event {

          color: #8b4513;

          margin-bottom: 0.125rem;

          font-weight: 500;

        }

        .journey-desc {

          color: #654321;

          font-size: 0.625rem;

        }

        .sanity-change {

          margin-top: 0.25rem;

          font-size: 0.625rem;

        }

        .inventory-container {

          max-height: 200px;

          overflow-y: auto;

        }

        .empty-inventory,

        .empty-rules,

        .loading-uma {

          text-align: center;

          color: #8b4513;

          padding: 1rem;

          font-size: 0.75rem;

        }

        .story-container {

          flex: 1;

          padding: 1.5rem;

          overflow-y: auto;

        }

        .story-content {

          color: #2d2d2d;

          white-space: pre-wrap;

          font-family:

            Georgia,

            Times New Roman,

            serif;

          font-size: 1rem;

          line-height: 1.8;

        }

        .story-text {

          margin: 0;

        }

        .input-section {

          background-color: #fdfbf7;

          background-image:

            repeating-linear-gradient(0deg, #0000, #0000 23px, #8b691433 24px 25px, #0000 26px),

            linear-gradient(90deg, #0000 40px, #8b69144d 41px 42px, #0000 43px);

          background-size:

            100% 24px,

            100% 100%;

          border-top: 2px solid #8b6914;

          padding: 1rem;

        }

        .input-header {

          justify-content: space-between;

          align-items: center;

          margin-bottom: 0.75rem;

          display: flex;

        }

        .time-display {

          color: #8b4513;

          align-items: center;

          gap: 0.5rem;

          font-size: 0.75rem;

          font-weight: 600;

          display: flex;

        }

        .danger-level {

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          min-width: -moz-fit-content;

          min-width: fit-content;

          padding: 0.25rem 0.75rem;

          font-size: 0.8rem;

          font-weight: 600;

          display: inline-flex;

        }

        .danger-details {

          color: #78350f;

          white-space: pre-line;

          background: #fef3c7e6;

          border: 1px solid #f59e0b;

          border-radius: 0.5rem;

          margin-top: 0.5rem;

          padding: 1rem;

          font-size: 0.8rem;

          line-height: 1.6;

        }

        .danger-modal {

          z-index: 1000;

          backdrop-filter: blur(4px);

          background: #000000b3;

          justify-content: center;

          align-items: center;

          width: 100%;

          height: 100%;

          display: flex;

          position: fixed;

          top: 0;

          left: 0;

        }

        .danger-modal-content {

          background: linear-gradient(135deg, #fdfbf7 0%, #f5f0e8 100%);

          border: 3px solid #8b6914;

          border-radius: 1rem;

          width: 90%;

          max-width: 600px;

          max-height: 80vh;

          position: relative;

          overflow: hidden;

          box-shadow: 0 20px 40px #0000004d;

        }

        .danger-modal-content:before {

          content: '';

          pointer-events: none;

          background-image:

            radial-gradient(circle at 20% 30%, #8b69140d 2px, #0000 4px),

            radial-gradient(circle at 80% 70%, #a086590a 1px, #0000 3px);

          background-size:

            60px 60px,

            40px 40px;

          position: absolute;

          top: 0;

          right: 0;

          bottom: 0;

          left: 0;

        }

        .danger-modal-header {

          color: #fdfbf7;

          background: linear-gradient(135deg, #8b6914, #a0865a);

          border-bottom: 2px solid #654321;

          justify-content: space-between;

          align-items: center;

          padding: 1rem 1.5rem;

          display: flex;

        }

        .danger-modal-header h3 {

          text-shadow: 0 2px 4px #0000004d;

          margin: 0;

          font-family:

            Brush Script MT,

            cursive;

          font-size: 1.5rem;

          font-weight: 700;

          transform: rotate(-1deg);

        }

        .danger-modal-close {

          color: #fdfbf7;

          cursor: pointer;

          background: 0 0;

          border: none;

          border-radius: 0.25rem;

          padding: 0.25rem 0.5rem;

          font-size: 1.5rem;

          transition: all 0.2s;

        }

        .danger-modal-close:hover {

          background: #fff3;

        }

        .danger-modal-body {

          max-height: 60vh;

          padding: 1.5rem;

          overflow-y: auto;

        }

        .danger-current-period {

          text-align: center;

          color: #8b4513;

          background: #8b69141a;

          border: 2px solid #8b6914;

          border-radius: 0.5rem;

          margin-bottom: 1.5rem;

          padding: 1rem;

          font-family:

            Brush Script MT,

            cursive;

          font-size: 1.1rem;

          font-weight: 600;

        }

        .danger-details-content {

          color: #654321;

          white-space: pre-line;

          background: #fff6;

          border: 1px solid #8b691433;

          border-radius: 0.75rem;

          padding: 1.5rem;

          font-family:

            Georgia,

            Times New Roman,

            serif;

          font-size: 0.9rem;

          line-height: 1.8;

          box-shadow: inset 0 2px 4px #0000001a;

        }

        .danger-details-content strong {

          color: #8b4513;

          font-weight: 600;

        }

        .danger-details-content .danger-stars {

          color: #d4af37;

          margin: 0.5rem 0;

          font-size: 1.1rem;

        }

        .danger-details-content .danger-suggestion {

          background: #8b69141a;

          border-left: 3px solid #8b6914;

          border-radius: 0.25rem;

          margin: 0.75rem 0;

          padding: 0.75rem;

        }

        .danger-level.safe {

          color: #059669;

          background: linear-gradient(135deg, #0596691a, #10b9811a);

          border: 1px solid #059669;

        }

        .danger-level.low {

          color: #d97706;

          background: linear-gradient(135deg, #d977061a, #f59e0b1a);

          border: 1px solid #d97706;

        }

        .danger-level.medium {

          color: #ea580c;

          background: linear-gradient(135deg, #ea580c1a, #fb923c1a);

          border: 1px solid #ea580c;

        }

        .danger-level.high {

          color: #dc2626;

          background: linear-gradient(135deg, #dc26261a, #ef44441a);

          border: 1px solid #dc2626;

        }

        .danger-level.extreme {

          color: #1f2937;

          background: linear-gradient(135deg, #1f29371a, #3741511a);

          border: 1px solid #1f2937;

        }

        .danger-button {

          color: #8b0000;

          cursor: pointer;

          background-color: #8b00001a;

          border: 1px solid #8b0000;

          border-radius: 0.375rem;

          padding: 0.5rem 1rem;

          font-size: 0.75rem;

          font-weight: 600;

          transition: all 0.2s;

        }

        .danger-button:hover {

          background-color: #8b000033;

        }

        .input-container {

          background-color: #8b69141a;

          border: 1px solid #8b6914;

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          padding: 0.75rem;

          display: flex;

        }

        .input-prompt {

          color: #8b4513;

          font-size: 1.125rem;

          font-weight: 700;

        }

        .action-input {

          color: #2d2d2d;

          resize: vertical;

          background: 0 0;

          border: none;

          outline: none;

          flex: 1;

          min-height: 60px;

          max-height: 120px;

          font-family:

            Georgia,

            Times New Roman,

            serif;

          font-size: 0.875rem;

          font-weight: 500;

          line-height: 1.5;

        }

        .input-controls {

          align-items: center;

          gap: 0.5rem;

          margin-top: 0.5rem;

          display: flex;

        }

        .send-button {

          color: #fdfbf7;

          cursor: pointer;

          background: linear-gradient(135deg, #8b6914, sienna);

          border: none;

          border-radius: 0.375rem;

          padding: 0.5rem 1rem;

          font-size: 0.875rem;

          font-weight: 600;

          transition: all 0.2s;

          box-shadow: 0 2px 4px #0003;

        }

        .send-button:hover {

          background: linear-gradient(135deg, sienna, #8b6914);

          transform: translateY(-1px);

          box-shadow: 0 4px 8px #0000004d;

        }

        .send-button:active {

          transform: translateY(0);

          box-shadow: 0 2px 4px #0003;

        }

        .action-input::placeholder {

          color: #8b4513;

        }

        .rules-section,

        .uma-section {

          margin-bottom: 1rem;

        }

        .uma-section-header {

          cursor: pointer;

          background: #8b69140d;

          border-bottom: 1px solid #8b6914;

          border-radius: 0.25rem;

          justify-content: space-between;

          align-items: center;

          margin-bottom: 0.5rem;

          padding: 0.5rem;

          display: flex;

        }

        .uma-section-header:hover {

          background-color: #8b69141a;

          border-radius: 0.25rem;

        }

        .uma-section-title {

          color: #2d2d2d;

          font-size: 0.875rem;

          font-weight: 600;

        }

        .uma-toggle {

          color: #8b6914;

          font-size: 0.75rem;

          transition: transform 0.2s;

        }

        .uma-content {

          max-height: 300px;

          margin-top: 0.5rem;

          overflow: hidden auto;

        }

        .rules-list,

        .uma-list {

          flex-direction: column;

          gap: 0.5rem;

          display: flex;

        }

        .rule-item {

          background: #fff9;

          border-left: 3px solid #d4af37;

          border-radius: 0.5rem;

          margin-bottom: 0.5rem;

          padding: 0.5rem;

          font-size: 0.75rem;

          line-height: 1.3;

          transition: all 0.3s;

          box-shadow: 0 2px 4px #0000001a;

        }

        .rule-item:hover {

          box-shadow: 0 4px 8px #00000026;

        }

        .rule-item.dangerous-rule {

          background: linear-gradient(135deg, #8b00001a, #8b000033);

          border-left: 3px solid #8b0000;

          box-shadow: 0 2px 8px #8b000033;

        }

        .rule-item.dangerous-rule:hover {

          box-shadow: 0 4px 12px #8b00004d;

        }

        .rule-number {

          color: #8b6914;

          text-shadow: 0 1px 2px #0000001a;

          margin-right: 0.75rem;

          font-size: 0.9rem;

          font-weight: 700;

        }

        .rule-text {

          color: #2d2d2d;

          font-weight: 500;

          line-height: 1.3;

        }

        .dangerous-rule .rule-number {

          color: #8b0000;

          text-shadow: 0 1px 3px #8b00004d;

        }

        .dangerous-rule .rule-text {

          color: #8b0000;

          text-shadow: 0 0 2px #8b000033;

        }

        .fixed-rule {

          background: linear-gradient(135deg, #8b69141a, #d4af371a);

          border-left: 3px solid #8b6914;

          border-radius: 0.5rem;

          margin-bottom: 0.5rem;

          padding: 0.5rem;

          font-size: 0.75rem;

          line-height: 1.3;

          transition: all 0.3s;

          box-shadow: 0 2px 4px #0000001a;

        }

        .fixed-rule:hover {

          background: linear-gradient(135deg, #8b691426, #d4af3726);

          box-shadow: 0 4px 8px #00000026;

        }

        .fixed-rule .rule-number {

          color: #8b6914;

          text-shadow: 0 1px 2px #0000001a;

          margin-right: 0.75rem;

          font-size: 0.9rem;

          font-weight: 700;

        }

        .fixed-rule .rule-text {

          color: #2d2d2d;

          font-weight: 500;

          line-height: 1.3;

        }

        .view-rules-button {

          color: #e8d5d5;

          cursor: pointer;

          text-shadow: 0 1px 2px #00000080;

          background: linear-gradient(135deg, #2d1b1b, #3d2b2b);

          border: 1px solid #8b0000;

          border-radius: 0.25rem;

          justify-content: center;

          align-items: center;

          gap: 0.5rem;

          width: 100%;

          padding: 0.5rem;

          font-size: 0.75rem;

          font-weight: 500;

          transition: all 0.2s;

          display: flex;

          position: relative;

          box-shadow:

            inset 0 1px #ffffff1a,

            0 2px 4px #0006;

        }

        .view-rules-button:before {

          content: '';

          opacity: 0;

          background: linear-gradient(135deg, #8b00001a, #0000);

          transition: opacity 0.2s;

          position: absolute;

          top: 0;

          right: 0;

          bottom: 0;

          left: 0;

        }

        .view-rules-button:hover:before {

          opacity: 1;

        }

        .view-rules-button:hover {

          color: #f0e0e0;

          background: linear-gradient(135deg, #3d2b2b, #4d3b3b);

          border-color: #a00000;

          box-shadow:

            inset 0 1px #ffffff26,

            0 3px 6px #00000080;

        }

        .view-rules-button:active {

          background: linear-gradient(135deg, #1d0b0b, #2d1b1b);

          box-shadow:

            inset 0 2px 4px #0009,

            0 1px 2px #0000004d;

        }

        .rules-modal {

          z-index: 1000;

          backdrop-filter: blur(4px);

          background: #000000b3;

          justify-content: center;

          align-items: center;

          width: 100%;

          height: 100%;

          display: flex;

          position: fixed;

          top: 0;

          left: 0;

        }

        .rules-modal-content {

          background: linear-gradient(135deg, #fdfbf7 0%, #f5f0e8 100%);

          border: 3px solid #8b6914;

          border-radius: 1rem;

          width: 90%;

          max-width: 600px;

          max-height: 80vh;

          position: relative;

          overflow: hidden;

          box-shadow: 0 20px 40px #0000004d;

        }







        /* 自定义滚动条样式 */

        #talents-modal .current-talents::-webkit-scrollbar,

        #talents-modal .upgrade-options::-webkit-scrollbar {

          width: 8px;

        }



        #talents-modal .current-talents::-webkit-scrollbar-track,

        #talents-modal .upgrade-options::-webkit-scrollbar-track {

          background: rgba(139, 69, 19, 0.1);

          border-radius: 4px;

        }



        #talents-modal .current-talents::-webkit-scrollbar-thumb,

        #talents-modal .upgrade-options::-webkit-scrollbar-thumb {

          background: rgba(139, 69, 19, 0.3);

          border-radius: 4px;

        }



        #talents-modal .current-talents::-webkit-scrollbar-thumb:hover,

        #talents-modal .upgrade-options::-webkit-scrollbar-thumb:hover {

          background: rgba(139, 69, 19, 0.5);

        }



        /* 全局滚动条样式 - 针对那些灰色的滚动条 */

        ::-webkit-scrollbar {

          width: 4px;

        }



        ::-webkit-scrollbar-track {

          background: rgba(240, 240, 240, 0.3);

          border-radius: 2px;

        }



        ::-webkit-scrollbar-thumb {

          background: rgba(180, 180, 180, 0.4);

          border-radius: 2px;

        }



        ::-webkit-scrollbar-thumb:hover {

          background: rgba(160, 160, 160, 0.6);

        }

        .rules-modal-content:before {

          content: '';

          pointer-events: none;

          background-image:

            radial-gradient(circle at 20% 30%, #8b69140d 2px, #0000 4px),

            radial-gradient(circle at 80% 70%, #a086590a 1px, #0000 3px);

          background-size:

            60px 60px,

            40px 40px;

          position: absolute;

          top: 0;

          right: 0;

          bottom: 0;

          left: 0;

        }

        .rules-modal-header {

          color: #fdfbf7;

          background: linear-gradient(135deg, #8b6914, #a0865a);

          border-bottom: 2px solid #654321;

          justify-content: space-between;

          align-items: center;

          padding: 1rem 1.5rem;

          display: flex;

        }

        .rules-title {

          text-shadow: 0 2px 4px #0000004d;

          margin: 0;

          font-family:

            Brush Script MT,

            cursive;

          font-size: 1.5rem;

          font-weight: 700;

          transform: rotate(-1deg);

        }

        .close-rules-btn {

          color: #fdfbf7;

          cursor: pointer;

          background: 0 0;

          border: none;

          border-radius: 0.25rem;

          padding: 0.25rem 0.5rem;

          font-size: 1.5rem;

          transition: all 0.2s;

        }

        .close-rules-btn:hover {

          background: #fff3;

        }

        .rules-modal-body {

          max-height: 60vh;

          padding: 1.5rem;

          overflow-y: auto;

        }

        .book-tab:hover {

          transform: translateY(-3px) !important;

          box-shadow: 0 -4px 16px rgba(139, 105, 20, 0.4) !important;

        }

        .book-page-content {

          position: relative;

          overflow: hidden;

        }

        .book-page-content::before {

          content: '';

          position: absolute;

          top: 0;

          left: 0;

          right: 0;

          height: 1px;

          background: linear-gradient(90deg, transparent, rgba(139, 105, 20, 0.3), transparent);

        }

        .book-page-content::after {

          content: '';

          position: absolute;

          bottom: 0;

          left: 0;

          right: 0;

          height: 1px;

          background: linear-gradient(90deg, transparent, rgba(139, 105, 20, 0.3), transparent);

        }

        .rules-section-fixed,

        .rules-section-random {

          margin-bottom: 2rem;

        }

        .rules-section-title {

          color: #8b4513;

          border-bottom: 2px solid #d4af37;

          margin-bottom: 1rem;

          padding-bottom: 0.5rem;

          font-family:

            Brush Script MT,

            cursive;

          font-size: 1.2rem;

          font-weight: 700;

          transform: rotate(1deg);

        }

        .rules-list-handwritten {

          color: #2d2d2d;

          text-shadow: 0 1px 1px #fffc;

          font-family:

            Segoe Script,

            Brush Script MT,

            Georgia,

            serif;

          font-size: 0.95rem;

          font-weight: 500;

          line-height: 1.7;

        }

        .rule-item-handwritten {

          background: #fff9;

          border-left: 3px solid #d4af37;

          border-radius: 0.25rem;

          gap: 0.75rem;

          margin-bottom: 0.75rem;

          padding: 0.5rem;

          transition: all 0.3s;

          display: flex;

        }

        .rule-item-handwritten:hover {

          background: #fffc;

          transform: translate(4px);

        }

        .rule-number-handwritten {

          color: #8b6914;

          min-width: 1.5rem;

          font-size: 1rem;

          font-weight: 700;

        }

        .rule-text-handwritten {

          flex: 1;

          font-style: normal;

          font-weight: 500;

        }

        
        /* 规则记录功能样式 */
        .rules-record-controls {
          display: flex;
          gap: 0.5rem;
          margin-bottom: 1rem;
        }
        
        .add-rule-btn, .clear-rules-btn {
          background: linear-gradient(135deg, #8b4513, #a0522d);
          color: white;
          border: 1px solid #d4af37;
          border-radius: 0.25rem;
          padding: 0.25rem 0.75rem;
          font-size: 0.8rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
          font-family: 'Segoe Script', cursive;
        }
        
        .add-rule-btn:hover, .clear-rules-btn:hover {
          background: linear-gradient(135deg, #a0522d, #cd853f);
          transform: translateY(-1px);
          box-shadow: 0 2px 4px rgba(139, 69, 19, 0.3);
        }
        
        .clear-rules-btn {
          background: linear-gradient(135deg, #dc2626, #ef4444);
        }
        
        .clear-rules-btn:hover {
          background: linear-gradient(135deg, #ef4444, #f87171);
        }
        
        
        .rule-item-editable {
          position: relative;
          padding-right: 2rem;
        }
        
        .rule-edit-btn, .rule-delete-btn {
          position: absolute;
          right: 0.25rem;
          top: 50%;
          transform: translateY(-50%);
          background: none;
          border: none;
          color: #8b4513;
          cursor: pointer;
          font-size: 0.8rem;
          padding: 0.1rem;
          border-radius: 0.2rem;
          transition: all 0.2s;
        }
        
        .rule-edit-btn {
          right: 1.5rem;
        }
        
        .rule-edit-btn:hover, .rule-delete-btn:hover {
          background: rgba(139, 69, 19, 0.1);
          color: #a0522d;
        }
        
        .rule-delete-btn:hover {
          color: #dc2626;
        }
        
        .rule-input {
          width: 100%;
          background: #fff9;
          border: 1px solid #d4af37;
          border-radius: 0.25rem;
          padding: 0.25rem 0.5rem;
          font-family: 'Segoe Script', cursive;
          font-size: 0.9rem;
          color: #2d2d2d;
          resize: vertical;
          min-height: 2rem;
        }
        
        .rule-input:focus {
          outline: none;
          border-color: #8b4513;
          background: #fffc;
        }
        
        .empty-rules {
          color: #8b4513;
          font-style: italic;
          text-align: center;
          padding: 1rem;
          background: rgba(139, 69, 19, 0.1);
          border-radius: 0.25rem;
          border: 1px dashed #d4af37;
        }
        .location-display {

          color: #059669;

          background: linear-gradient(135deg, #0596691a, #10b9811a);

          border: 1px solid #059669;

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          min-width: -moz-fit-content;

          min-width: fit-content;

          padding: 0.25rem 0.75rem;

          font-size: 0.8rem;

          font-weight: 600;

          display: flex;

        }

        .inventory-item {

          background: linear-gradient(145deg, #ffffffb3, #8b69141a);

          border: 1px solid #d4af37;

          border-radius: 0.5rem;

          margin-bottom: 0.5rem;

          padding: 0.5rem;

          transition: all 0.3s;

          position: relative;

          box-shadow: 0 2px 6px #0000001a;

        }

        .inventory-item:before {

          content: '';

          opacity: 0.6;

          background: linear-gradient(90deg, #d4af37, gold, #d4af37);

          height: 2px;

          position: absolute;

          top: 0;

          left: 0;

          right: 0;

        }

        .inventory-item:hover {

          border-color: gold;

          box-shadow: 0 4px 10px #00000026;

        }

        .uma-item {

          background: 

            linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(139, 105, 20, 0.1)),

            radial-gradient(circle at 20% 30%, rgba(212, 175, 55, 0.15) 0%, transparent 60%),

            radial-gradient(circle at 20% 70%, rgba(255, 255, 255, 0.1) 0%, transparent 60%),

            linear-gradient(45deg, transparent 30%, rgba(212, 175, 55, 0.05) 50%, transparent 70%) !important;

          background-color: transparent !important;

          border: 1px solid #d4af37 !important;

          border-radius: 0.5rem;

          margin-bottom: 0.75rem;

          padding: 0.75rem;

          transition: all 0.3s;

          position: relative;

          overflow: visible;

          box-shadow: 

            0 2px 8px rgba(0, 0, 0, 0.1),

            inset 0 1px 0 rgba(255, 255, 255, 0.2),

            inset 0 -1px 0 rgba(0, 0, 0, 0.05) !important;

        }



        /* 强制覆盖任何可能的背景色设置 */

        .uma-item[style*="background"] {

          background: 

            linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(139, 105, 20, 0.1)),

            radial-gradient(circle at 20% 30%, rgba(212, 175, 55, 0.15) 0%, transparent 60%),

            radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.1) 0%, transparent 60%),

            linear-gradient(45deg, transparent 30%, rgba(212, 175, 55, 0.05) 50%, transparent 70%) !important;

        }



        /* 最高优先级强制设置 */

        div.uma-item,

        .uma-item,

        .uma-item[style],

        .parchment-page .uma-item,

        .panel-content .uma-item {

          background: 

            linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(139, 105, 20, 0.1)),

            radial-gradient(circle at 20% 30%, rgba(212, 175, 55, 0.15) 0%, transparent 60%),

            radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.1) 0%, transparent 60%),

            linear-gradient(45deg, transparent 30%, rgba(212, 175, 55, 0.05) 50%, transparent 70%) !important;

          background-color: transparent !important;

        }





        .uma-item:before {

          content: '';

          opacity: 0.7;

          background: linear-gradient(90deg, #d4af37, gold, #d4af37);

          height: 2px;

          position: absolute;

          top: 0;

          left: 0;

          right: 0;

        }


        /* 塔罗占卜样式 */
        .tarot-divination {
          color: #8b6914;
          background: #ffffffe6;
          border: 1px solid #d4af37;
          border-radius: 0.375rem;
          align-items: center;
          gap: 0.5rem;
          min-width: -moz-fit-content;
          min-width: fit-content;
          padding: 0.25rem 0.75rem;
          font-size: 0.8rem;
          font-weight: 600;
          display: flex;
          cursor: pointer;
          transition: all 0.3s;
          box-shadow: 0 1px 2px rgba(139, 69, 19, 0.3);
        }
        
        .tarot-divination:hover {
          background: #ffffff;
          transform: translateY(-1px);
          box-shadow: 0 4px 8px rgba(139, 69, 19, 0.3);
          border-color: #8b6914;
        }
        
        .tarot-modal-content {
          max-width: 800px;
          max-height: 90vh;
        }
        
        .tarot-info {
          background: linear-gradient(135deg, rgba(139, 105, 20, 0.1), rgba(139, 105, 20, 0.05));
          border: 1px solid rgba(139, 105, 20, 0.3);
          border-radius: 0.375rem;
          padding: 1rem;
          margin-bottom: 1rem;
          color: #8b4513;
        }
        
        .tarot-info p {
          margin: 0.25rem 0;
          font-weight: 600;
        }
        
        .spread-buttons {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 1rem;
          margin-bottom: 1.5rem;
        }
        
        .spread-btn {
          background: linear-gradient(135deg, rgba(139, 105, 20, 0.1), rgba(139, 105, 20, 0.05));
          border: 1px solid rgba(139, 105, 20, 0.3);
          border-radius: 0.375rem;
          padding: 1rem;
          cursor: pointer;
          transition: all 0.3s;
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 0.5rem;
          color: #8b4513;
          font-weight: 600;
          position: relative;
        }
        
        .spread-btn:hover:not(.disabled) {
          background: linear-gradient(135deg, rgba(139, 105, 20, 0.2), rgba(139, 105, 20, 0.1));
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(139, 69, 19, 0.3);
          border-color: rgba(139, 105, 20, 0.5);
        }
        
        .spread-btn.disabled {
          opacity: 0.5;
          cursor: not-allowed;
          background: linear-gradient(135deg, rgba(139, 105, 20, 0.05), rgba(139, 105, 20, 0.02));
        }
        
        .spread-btn.advanced {
          background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(34, 197, 94, 0.05));
          border-color: rgba(34, 197, 94, 0.3);
          color: #22c55e;
        }
        
        .spread-btn.advanced:hover:not(.disabled) {
          background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1));
          box-shadow: 0 4px 8px rgba(34, 197, 94, 0.3);
          border-color: rgba(34, 197, 94, 0.5);
        }
        
        .spread-icon {
          font-size: 1.5rem;
        }
        
        .spread-name {
          font-size: 0.9rem;
          font-weight: 700;
        }
        
        .spread-cost {
          font-size: 0.8rem;
          color: #6b7280;
        }
        
        .spread-requirement {
          font-size: 0.7rem;
          color: #f59e0b;
          font-weight: 600;
        }
        
        .tarot-result {
          background: linear-gradient(135deg, #4c1d951a, #7c3aed1a);
          border: 1px solid #a855f7;
          border-radius: 0.5rem;
          padding: 1rem;
          margin-top: 1rem;
        }
        
        .tarot-cards {
          display: flex;
          flex-wrap: wrap;
          gap: 1rem;
          margin-bottom: 1rem;
        }
        
        .tarot-card {
          background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
          border: 2px solid #d1d5db;
          border-radius: 0.5rem;
          padding: 1rem;
          min-width: 120px;
          text-align: center;
          position: relative;
          cursor: pointer;
          transition: all 0.3s;
        }
        
        .tarot-card:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .tarot-card.reversed {
          transform: rotate(180deg);
        }
        
        .tarot-card-name {
          font-weight: 700;
          color: #374151;
          margin-bottom: 0.5rem;
        }
        
        .tarot-card-meaning {
          font-size: 0.8rem;
          color: #6b7280;
        }
        
        .tarot-interpretation {
          background: #f9fafb;
          border: 1px solid #e5e7eb;
          border-radius: 0.5rem;
          padding: 1rem;
          margin-bottom: 1rem;
          color: #374151;
        }
        
        .tarot-effects {
          background: linear-gradient(135deg, #fef3c7, #fde68a);
          border: 1px solid #f59e0b;
          border-radius: 0.5rem;
          padding: 1rem;
          color: #92400e;
        }
        
        .tarot-effects h4 {
          margin: 0 0 0.5rem 0;
          color: #92400e;
        }
        
        .tarot-effects ul {
          margin: 0;
          padding-left: 1.5rem;
        }
        
        .tarot-effects li {
          margin: 0.25rem 0;
        }


        .uma-item::after {

          content: '';

          position: absolute;

          top: 0;

          left: 0;

          right: 0;

          bottom: 0;

          background: 

            radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.08) 0%, transparent 50%),

            radial-gradient(circle at 70% 80%, rgba(212, 175, 55, 0.06) 0%, transparent 50%),

            linear-gradient(45deg, transparent 40%, rgba(255, 255, 255, 0.02) 50%, transparent 60%);

          pointer-events: none;

          z-index: 1;

        }

        .uma-item:hover {

          border-color: gold;

          box-shadow: 

            0 4px 12px rgba(0, 0, 0, 0.15),

            inset 0 1px 0 rgba(255, 255, 255, 0.3),

            inset 0 -1px 0 rgba(0, 0, 0, 0.1);

          transform: translateY(-1px);

        }

        .uma-header {

          justify-content: space-between;

          align-items: center;

          margin-bottom: 0.5rem;

          display: flex;

          position: relative;

          z-index: 2;

        }

        .uma-info {

          align-items: center;

          gap: 0.5rem;

          display: flex;

        }



        .uma-name {

          color: #dc2626;

          text-shadow: 0 1px 2px #00000040;

          letter-spacing: 0.5px;

          font-size: 1rem;

          font-weight: 700;

          margin-bottom: 0.2rem;

        }



        .uma-text-info {

          display: flex;

          flex-direction: column;

          gap: 0.15rem;

          justify-content: center;

        }

        .uma-name {

          font-size: 1rem;

          font-weight: 600;

          line-height: 1.2;

          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);

        }



        .uma-status-text {

          font-size: 0.7rem;

          font-weight: 400;

          opacity: 0.9;

          transition: all 0.3s ease;

          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);

          border-radius: 0.3rem;

          padding: 0.1rem 0.3rem;

          background: rgba(255, 255, 255, 0.85);

          backdrop-filter: blur(3px);

          border: 1px solid rgba(212, 175, 55, 0.2);

          color: #ff69b4 !important;

          letter-spacing: 0.2px;

          box-shadow: 0 1px 3px rgba(212, 175, 55, 0.15);

        }

        /* 不同状态文字的美化样式 */
        .uma-status-text[style*="color: #059669"] {

          background: linear-gradient(135deg, rgba(5, 150, 105, 0.12), rgba(5, 150, 105, 0.08));

          border-color: rgba(5, 150, 105, 0.25);

          color: #059669 !important;

          box-shadow: 0 1px 3px rgba(5, 150, 105, 0.15);

        }

        .uma-status-text[style*="color: #8b0000"] {

          background: linear-gradient(135deg, rgba(139, 0, 0, 0.12), rgba(139, 0, 0, 0.08));

          border-color: rgba(139, 0, 0, 0.25);

          color: #8b0000 !important;

          box-shadow: 0 1px 3px rgba(139, 0, 0, 0.15);

        }

        .uma-status-text[style*="color: #6b7280"] {

          background: linear-gradient(135deg, rgba(107, 114, 128, 0.12), rgba(107, 114, 128, 0.08));

          border-color: rgba(107, 114, 128, 0.25);

          color: #6b7280 !important;

          box-shadow: 0 1px 3px rgba(107, 114, 128, 0.15);

        }

        .uma-status-text[style*="color: #f59e0b"] {

          background: linear-gradient(135deg, rgba(245, 158, 11, 0.12), rgba(245, 158, 11, 0.08));

          border-color: rgba(245, 158, 11, 0.25);

          color: #dc2626 !important;

          box-shadow: 0 1px 3px rgba(245, 158, 11, 0.15);

        }

        .uma-status-text[style*="color: #ef4444"] {

          background: linear-gradient(135deg, rgba(239, 68, 68, 0.12), rgba(239, 68, 68, 0.08));

          border-color: rgba(239, 68, 68, 0.25);

          color: #ef4444 !important;

          box-shadow: 0 1px 3px rgba(239, 68, 68, 0.15);

        }

        .uma-status-text[style*="color: #dc2626"] {

          background: linear-gradient(135deg, rgba(220, 38, 38, 0.15), rgba(185, 28, 28, 0.1));

          border-color: rgba(220, 38, 38, 0.3);

          color: #dc2626 !important;

          box-shadow: 0 1px 4px rgba(220, 38, 38, 0.2);

        }

        /* 状态文字悬停效果 */
        .uma-status-text:hover {

          transform: translateY(-0.5px);

          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);

          transition: all 0.3s ease;

        }

        .uma-avatar-container {

          position: relative;

          display: inline-block;

        }

        .uma-avatar {

          width: 3rem;

          height: 3rem;

          border-radius: 50%;

          object-fit: cover;

          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);

        }

        .avatar-decoration {

          position: absolute;

          top: -0.5rem;

          right: -0.5rem;

          display: flex;

          align-items: center;

          justify-content: center;

          width: 1.2rem;

          height: 1.2rem;

          font-size: 0.8rem;

          border-radius: 50%;

          background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));

          backdrop-filter: blur(5px);

          border: 1px solid rgba(255, 255, 255, 0.3);

          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);

          z-index: 10;

          animation: decorationFloat 2s ease-in-out infinite;

        }

        .uma-status-decoration {

          position: absolute;

          top: 0.5rem;

          right: 0.5rem;

          display: flex;

          align-items: center;

          justify-content: center;

          width: 1.5rem;

          height: 1.5rem;

          font-size: 1rem;

          border-radius: 50%;

          background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));

          backdrop-filter: blur(10px);

          border: 1px solid rgba(255, 255, 255, 0.3);

          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);

          transition: all 0.3s ease;

          animation: decorationFloat 3s ease-in-out infinite;

          z-index: 10;

        }

        .uma-status-decoration:hover {

          transform: scale(1.1) rotate(5deg);

          box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);

        }

        @keyframes decorationFloat {

          0%, 100% { transform: translateY(0px); }

          50% { transform: translateY(-3px); }

        }

        /* 不同状态的头像装饰样式 */
        .uma-avatar-container.normal .avatar-decoration {

          background: linear-gradient(135deg, rgba(5, 150, 105, 0.9), rgba(5, 150, 105, 0.7));

          border-color: rgba(5, 150, 105, 0.3);

          color: #059669;

        }

        .uma-avatar-container.possessed .avatar-decoration {

          background: linear-gradient(135deg, rgba(139, 0, 0, 0.9), rgba(139, 0, 0, 0.7));

          border-color: rgba(139, 0, 0, 0.3);

          color: #8b0000;

          animation: decorationFloat 2s ease-in-out infinite, possessedGlow 1.5s ease-in-out infinite alternate;

        }

        .uma-avatar-container.missing .avatar-decoration {

          background: linear-gradient(135deg, rgba(107, 114, 128, 0.9), rgba(107, 114, 128, 0.7));

          border-color: rgba(107, 114, 128, 0.3);

          color: #6b7280;

        }

        .uma-avatar-container.confused .avatar-decoration {

          background: linear-gradient(135deg, rgba(245, 158, 11, 0.9), rgba(245, 158, 11, 0.7));

          border-color: rgba(245, 158, 11, 0.3);

          color: #f59e0b;

          animation: decorationFloat 1.5s ease-in-out infinite, confusedSpin 3s linear infinite;

        }

        .uma-avatar-container.alert .avatar-decoration {

          background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(239, 68, 68, 0.7));

          border-color: rgba(239, 68, 68, 0.3);

          color: #ef4444;

          animation: decorationFloat 1s ease-in-out infinite, alertPulse 0.8s ease-in-out infinite;

        }

        .uma-avatar-container.yandere .avatar-decoration {

          background: linear-gradient(135deg, rgba(220, 38, 38, 0.9), rgba(185, 28, 28, 0.8));

          border-color: rgba(220, 38, 38, 0.4);

          color: #dc2626;

          animation: decorationFloat 0.8s ease-in-out infinite, yandereShake 0.5s ease-in-out infinite;

        }

        /* 不同状态的装饰样式 */
        .uma-status-decoration.normal {

          background: linear-gradient(135deg, rgba(5, 150, 105, 0.2), rgba(5, 150, 105, 0.1));

          border-color: rgba(5, 150, 105, 0.3);

          color: #059669;

        }

        .uma-status-decoration.possessed {

          background: linear-gradient(135deg, rgba(139, 0, 0, 0.2), rgba(139, 0, 0, 0.1));

          border-color: rgba(139, 0, 0, 0.3);

          color: #8b0000;

          animation: decorationFloat 2s ease-in-out infinite, possessedGlow 1.5s ease-in-out infinite alternate;

        }

        .uma-status-decoration.missing {

          background: linear-gradient(135deg, rgba(107, 114, 128, 0.2), rgba(107, 114, 128, 0.1));

          border-color: rgba(107, 114, 128, 0.3);

          color: #6b7280;

        }

        .uma-status-decoration.confused {

          background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.1));

          border-color: rgba(245, 158, 11, 0.3);

          color: #f59e0b;

          animation: decorationFloat 1.5s ease-in-out infinite, confusedSpin 3s linear infinite;

        }

        .uma-status-decoration.alert {

          background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1));

          border-color: rgba(239, 68, 68, 0.3);

          color: #ef4444;

          animation: decorationFloat 1s ease-in-out infinite, alertPulse 0.8s ease-in-out infinite;

        }

        .uma-status-decoration.yandere {

          background: linear-gradient(135deg, rgba(220, 38, 38, 0.3), rgba(185, 28, 28, 0.2));

          border-color: rgba(220, 38, 38, 0.4);

          color: #dc2626;

          animation: decorationFloat 0.8s ease-in-out infinite, yandereShake 0.5s ease-in-out infinite;

        }

        /* 特殊动画效果 */
        @keyframes possessedGlow {

          0%, 100% { box-shadow: 0 2px 8px rgba(139, 0, 0, 0.3); }

          50% { box-shadow: 0 2px 16px rgba(139, 0, 0, 0.6); }

        }

        @keyframes confusedSpin {

          0% { transform: translateY(0px) rotate(0deg); }

          50% { transform: translateY(-3px) rotate(180deg); }

          100% { transform: translateY(0px) rotate(360deg); }

        }

        @keyframes alertPulse {

          0%, 100% { transform: scale(1); }

          50% { transform: scale(1.1); }

        }

        @keyframes yandereShake {

          0%, 100% { transform: translateX(0px); }

          25% { transform: translateX(-2px); }

          75% { transform: translateX(2px); }

        }



        .uma-status-badge {

          text-transform: uppercase;

          letter-spacing: 0.5px;

          border-radius: 0.75rem;

          padding: 0.25rem 0.5rem;

          font-size: 0.7rem;

          font-weight: 600;

          box-shadow: 0 1px 3px #0003;

          transition: all 0.3s ease;

        }

        .uma-status {

          text-transform: uppercase;

          letter-spacing: 0.5px;

          border-radius: 0.75rem;

          padding: 0.25rem 0.5rem;

          font-size: 0.7rem;

          font-weight: 600;

          box-shadow: 0 1px 3px #0003;

        }

        .uma-status-badge.normal {

          color: #fff;

          background: linear-gradient(135deg, #059669cc, #05966999);

          border: 1px solid #0596694d;

        }

        .uma-status-badge.possessed {

          color: #fff;

          background: linear-gradient(135deg, #8b0000cc, #8b000099);

          border: 1px solid #8b00004d;

        }

        .uma-status-badge.missing {

          color: #fff;

          background: linear-gradient(135deg, #6b7280cc, #6b728099);

          border: 1px solid #6b72804d;

        }

        .uma-status-badge.confused {

          color: #fff;

          background: linear-gradient(135deg, #f59e0bcc, #f59e0b99);

          border: 1px solid #f59e0b4d;

        }

        .uma-status-badge.alert {

          color: #fff;

          background: linear-gradient(135deg, #ef4444cc, #ef444499);

          border: 1px solid #ef44444d;

        }

        .uma-status-badge.yandere {

          color: #fff;

          text-shadow: 0 1px 2px #00000080;

          background: linear-gradient(135deg, #dc2626e6, #b91c1ccc);

          border: 2px solid #dc262680;

          font-weight: 700;

          animation: 2s ease-in-out infinite yanderePulse;

          box-shadow: 0 0 10px #dc262666;

        }

        @keyframes yanderePulse {

          0%,

          to {

            box-shadow: 0 0 10px #dc262666;

          }

          50% {

            box-shadow:

              0 0 20px #dc2626b3,

              0 0 30px #dc26264d;

          }

        }

        @keyframes bloodGlow {

          0% {

            transform: rotate(0);

            box-shadow:

              0 0 20px #f00c,

              0 0 40px #f006,

              0 0 60px #f003;

          }

          25% {

            transform: rotate(90deg);

            box-shadow:

              0 0 25px #ff0000e6,

              0 0 50px #ff000080,

              0 0 75px #ff00004d;

          }

          50% {

            transform: rotate(180deg);

            box-shadow:

              0 0 20px #f00c,

              0 0 40px #f006,

              0 0 60px #f003;

          }

          75% {

            transform: rotate(270deg);

            box-shadow:

              0 0 25px #ff0000e6,

              0 0 50px #ff000080,

              0 0 75px #ff00004d;

          }

          to {

            transform: rotate(360deg);

            box-shadow:

              0 0 20px #f00c,

              0 0 40px #f006,

              0 0 60px #f003;

          }

        }

        .uma-status.worried {

          color: #fff;

          background: linear-gradient(135deg, #a855f7cc, #a855f799);

          border: 1px solid #a855f74d;

        }

        .uma-status.protect {

          color: #fff;

          background: linear-gradient(135deg, #22c55ecc, #22c55e99);

          border: 1px solid #22c55e4d;

        }

        .uma-desc {

          color: #654321;

          text-shadow: 0 1px 1px #ffffff80;

          margin: 0.5rem 0;

          font-size: 0.8rem;

          font-style: italic;

          line-height: 1.4;

          position: relative;

          z-index: 2;

        }

        .uma-hearts {

          justify-content: center;

          gap: 0.25rem;

          margin-top: 0.5rem;

          display: flex;

          position: relative;

          z-index: 2;

        }

        .heart {

          color: #dc2626;

          text-shadow: 0 2px 4px #dc26264d;

          font-size: 1rem;

          animation: 2s ease-in-out infinite heartBeat;

          display: inline-block;

        }

        .heart:nth-child(2) {

          animation-delay: 0.2s;

        }

        .heart:nth-child(3) {

          animation-delay: 0.4s;

        }

        .heart:nth-child(4) {

          animation-delay: 0.6s;

        }

        .heart:nth-child(5) {

          animation-delay: 0.8s;

        }

        @keyframes heartBeat {

          0%,

          to {

            transform: scale(1);

          }

          50% {

            transform: scale(1.1);

          }

        }

        .twisted-love-accent {

          color: #8b0000;

          text-shadow: 0 0 3px #8b000066;

          font-weight: 700;

        }

        .horror-glow {

          color: #8b0000;

          text-shadow: 0 0 4px #8b000099;

        }

        .typewriter-cursor {

          color: #8b0000;

          animation: 1.2s infinite blink;

        }

        @keyframes blink {

          0%,

          50% {

            opacity: 1;

          }

          51%,

          to {

            opacity: 0;

          }

        }

        @keyframes subtle-pulse {

          0%,

          to {

            opacity: 0.8;

            transform: scale(1);

          }

          50% {

            opacity: 1;

            transform: scale(1.02);

          }

        }

        .subtle-hover {

          transition: all 0.2s;

        }

        .subtle-hover:hover {

          transform: translateY(-1px);

          box-shadow: 0 2px 4px #0000004d;

        }

        .inventory-item {

          background: #ffffffb3;

          border: 1px solid #d4af37;

          border-radius: 0.375rem;

          margin-bottom: 0.5rem;

          padding: 0.5rem;

          box-shadow: 0 2px 4px #0000001a;

        }

        .item-header {

          cursor: pointer;

          z-index: 10;

          -webkit-user-select: none;

          user-select: none;

          justify-content: space-between;

          align-items: center;

          padding: 0.25rem 0;

          display: flex;

          position: relative;

        }

        .item-header:hover {

          background-color: #d4af371a;

          border-radius: 0.25rem;

        }

        .item-toggle {

          color: #8b6914;

          font-size: 0.75rem;

          transition: transform 0.2s;

        }

        .item-name {

          color: #8b6914;

          font-size: 0.875rem;

          font-weight: 600;

        }

        .item-details {

          border-top: 1px solid #d4af374d;

          margin-top: 0.5rem;

          padding-top: 0.5rem;

        }

        .item-detail-popup {

          z-index: 100;

          background: #fffffff2;

          border: 1px solid #d4af37;

          border-radius: 0.375rem;

          min-width: 180px;

          max-width: 250px;

          padding: 0.75rem;

          font-size: 0.75rem;

          position: absolute;

          top: -10px;

          left: 0;

          box-shadow: 0 2px 8px #0003;

        }



        .skill-detail-popup {

          z-index: 100;

          background: #fffffff2;

          border: 1px solid #805ad5;

          border-radius: 0.375rem;

          min-width: 150px;

          max-width: 200px;

          padding: 0.5rem;

          font-size: 0.75rem;

          position: absolute;

          top: -10px;

          left: 0;

          box-shadow: 0 2px 8px #0003;

        }



        .skill-popup:after {

          content: '';

          border-top: 5px solid #805ad5;

          border-left: 5px solid #0000;

          border-right: 5px solid #0000;

          width: 0;

          height: 0;

          position: absolute;

          top: 100%;

          left: 1rem;

        }



        .skill-desc {

          color: #654321;

          text-shadow: 0 1px 1px #ffffff80;

          margin-bottom: 0.5rem;

          font-size: 0.8rem;

          font-style: italic;

          line-height: 1.4;

        }


        .skill-header {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 12px;
          padding-bottom: 8px;
          border-bottom: 1px solid rgba(139, 69, 19, 0.2);
        }

        .skill-title {
          font-size: 16px;
          font-weight: bold;
          color: #8b4513;
        }


        .skill-use-btn {

          background: linear-gradient(135deg, #805ad5, #6b46c1);

          color: white;

          border: none;

          border-radius: 0.25rem;

          padding: 0.25rem 0.5rem;

          font-size: 0.7rem;

          cursor: pointer;

          margin: 0.25rem 0.25rem 0 0;

          transition: all 0.2s;

        }



        .skill-use-btn:hover {

          background: linear-gradient(135deg, #6b46c1, #553c9a);

          transform: translateY(-1px);

        }



        .item-popup.show {

          display: block;

        }

        .item-popup:after {

          content: '';

          border-top: 5px solid #d4af37;

          border-left: 5px solid #0000;

          border-right: 5px solid #0000;

          width: 0;

          height: 0;

          position: absolute;

          top: 100%;

          left: 1rem;

        }

        .item-desc {

          color: #654321;

          text-shadow: 0 1px 1px #ffffff80;

          margin-bottom: 0.75rem;

          font-size: 0.8rem;

          font-style: italic;

          line-height: 1.5;

        }

        .item-effect {

          color: #059669;

          text-shadow: 0 1px 1px #ffffff80;

          margin-bottom: 0.5rem;

          font-size: 0.8rem;

          font-weight: 600;

        }

        .item-rarity {

          border-radius: 0.375rem;

          padding: 0.25rem 0.5rem;

          font-size: 0.75rem;

          font-weight: 600;

          display: inline-block;

          text-align: center;

        }

        /* 稀有度样式 */

        .rarity-普通 {

          color: #696969;

          background: linear-gradient(135deg, #f5f5f5, #e0e0e0);

          border: 2px solid #b0b0b0;

          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);

        }



        .rarity-稀有 {

          color: #2563eb;

          background: linear-gradient(135deg, #dbeafe, #bfdbfe);

          border: 2px solid #3b82f6;

          box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);

          text-shadow: 0 1px 2px rgba(59, 130, 246, 0.2);

        }



        .rarity-史诗 {

          color: #7c3aed;

          background: linear-gradient(135deg, #ede9fe, #ddd6fe);

          border: 2px solid #8b5cf6;

          box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);

          text-shadow: 0 1px 2px rgba(139, 92, 246, 0.2);

        }



        .rarity-传说 {

          color: #d97706;

          background: linear-gradient(135deg, #fef3c7, #fde68a);

          border: 2px solid #f59e0b;

          box-shadow: 0 2px 12px rgba(245, 158, 11, 0.4);

          text-shadow: 0 1px 3px rgba(217, 119, 6, 0.3);

          animation: legendary-glow 2s ease-in-out infinite alternate;

        }



        @keyframes legendary-glow {

          from {

            box-shadow: 0 2px 12px rgba(245, 158, 11, 0.4);

          }

          to {

            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.6);

          }

        }

        .rules-section-header {

          cursor: pointer;

          border-bottom: 1px solid #d4af37;

          justify-content: space-between;

          align-items: center;

          margin: 0.75rem 0 0.5rem;

          padding: 0.5rem 0;

          display: flex;

        }

        .rules-section-header:hover {

          background-color: #d4af371a;

          border-radius: 0.25rem;

        }

        .rules-section-title {

          color: #8b6914;

          font-size: 0.875rem;

          font-weight: 600;

        }

        .rules-toggle {

          color: #8b6914;

          font-size: 0.75rem;

          transition: transform 0.2s;

        }

        .rules-content {

          margin-top: 0.5rem;

        }

        .currency-section {

          color: #8b6914;

          background: #ffffffe6;

          border: 1px solid #d4af37;

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          min-width: -moz-fit-content;

          min-width: fit-content;

          padding: 0.25rem 0.75rem;

          font-size: 0.8rem;

          font-weight: 600;

          display: flex;

        }

        .bottom-panel {

          white-space: nowrap;

          background-color: #fdfbf7;

          border-top: 2px solid #8b6914;

          flex-wrap: nowrap;

          grid-area: 3/1/4/4;

          justify-content: space-between;

          align-items: center;

          gap: 1rem;

          height: 40px;

          padding: 0.5rem;

          display: flex;

          overflow: hidden;

        }

        .bottom-group {

          flex-shrink: 0;

          align-items: center;

          gap: 0.5rem;

          display: flex;

        }

        .festival-notice {

          color: #b8860b;

          background: linear-gradient(135deg, #ffd7001a, #ffc1071a);

          border: 1px solid gold;

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          min-width: -moz-fit-content;

          min-width: fit-content;

          padding: 0.25rem 0.75rem;

          font-size: 0.8rem;

          font-weight: 600;

          display: flex;

        }

        .rules-countdown {

          color: #dc2626;

          background: linear-gradient(135deg, #8b00001a, #dc26261a);

          border: 1px solid #dc2626;

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          min-width: -moz-fit-content;

          min-width: fit-content;

          padding: 0.25rem 0.75rem;

          font-size: 0.8rem;

          font-weight: 600;

          display: flex;

        }

        .reply-timer {

          color: #16a34a;

          background: linear-gradient(135deg, #22c55e1a, #16a34a1a);

          border: 1px solid #16a34a;

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          min-width: -moz-fit-content;

          min-width: fit-content;

          padding: 0.25rem 0.75rem;

          font-size: 0.8rem;

          font-weight: 600;

          transition: all 0.3s;

          display: flex;

        }

        .reply-timer.warning {

          color: #d97706;

          background: linear-gradient(135deg, #f59e0b1a, #d977061a);

          border-color: #d97706;

        }

        .reply-timer.danger {

          color: #dc2626;

          background: linear-gradient(135deg, #ef44441a, #dc26261a);

          border-color: #dc2626;

          animation: 1s ease-in-out infinite pulse;

        }

        @keyframes pulse {

          0%,

          to {

            opacity: 1;

          }

          50% {

            opacity: 0.7;

          }

        }

        .gacha-coin {

          color: #b8860b;

          background: linear-gradient(135deg, #b8860b1a, #ffd7001a);

          border: 1px solid #b8860b;

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          min-width: -moz-fit-content;

          min-width: fit-content;

          padding: 0.25rem 0.75rem;

          font-size: 0.8rem;

          font-weight: 600;

          display: flex;

        }

        .hot-spring-ticket {

          color: #059669;

          background: linear-gradient(135deg, #0596691a, #10b9811a);

          border: 1px solid #059669;

          border-radius: 0.375rem;

          align-items: center;

          gap: 0.5rem;

          min-width: -moz-fit-content;

          min-width: fit-content;

          padding: 0.25rem 0.75rem;

          font-size: 0.8rem;

          font-weight: 600;

          display: flex;

        }

        .save-button,

        .view-rules-button {

          color: #2d2d2d;

          cursor: pointer;

          background: linear-gradient(135deg, #f5f0e8, #e8d5c4);

          border: 2px solid #8b4513;

          border-radius: 0.375rem;

          padding: 0.5rem 1rem;

          font-size: 0.875rem;

          font-weight: 600;

          transition: all 0.3s;

          position: relative;

          overflow: hidden;

        }

        .save-button:before,

        .view-rules-button:before {

          content: '';

          opacity: 0;

          border-radius: inherit;

          background: linear-gradient(135deg, #8b00001a, #0000);

          transition: opacity 0.3s;

          position: absolute;

          top: 0;

          right: 0;

          bottom: 0;

          left: 0;

        }

        .save-button:after,

        .view-rules-button:after {

          content: '';

          background: radial-gradient(circle, #8b00004d 0%, #0000 70%);

          border-radius: 50%;

          width: 0;

          height: 0;

          transition: all 0.4s;

          position: absolute;

          top: 50%;

          left: 50%;

          transform: translate(-50%, -50%);

        }

        .save-button:hover,

        .view-rules-button:hover {

          transform: translateY(-2px);

          box-shadow: 0 4px 12px #8b00004d;

        }

        .save-button:hover:before,

        .view-rules-button:hover:before {

          opacity: 1;

        }

        .save-button:hover:after,

        .view-rules-button:hover:after {

          width: 200px;

          height: 200px;

        }

        .save-button:active,

        .view-rules-button:active {

          transform: translateY(0);

          box-shadow: 0 2px 8px #8b000066;

        }

        .save-button:active:after,

        .view-rules-button:active:after {

          background: radial-gradient(circle, #8b000080 0%, #0000 60%);

          width: 300px;

          height: 300px;

        }

      }

      @property --tw-rotate-x {

        syntax: '*';

        inherits: false;

      }

      @property --tw-rotate-y {

        syntax: '*';

        inherits: false;

      }

      @property --tw-rotate-z {

        syntax: '*';

        inherits: false;

      }

      @property --tw-skew-x {

        syntax: '*';

        inherits: false;

      }

      @property --tw-skew-y {

        syntax: '*';

        inherits: false;

      }

      @property --tw-border-style {

        syntax: '*';

        inherits: false;

        initial-value: solid;

      }

      @property --tw-shadow {

        syntax: '*';

        inherits: false;

        initial-value: 0 0 #0000;

      }

      @property --tw-shadow-color {

        syntax: '*';

        inherits: false;

      }

      @property --tw-shadow-alpha {

        syntax: '<percentage>';

        inherits: false;

        initial-value: 100%;

      }

      @property --tw-inset-shadow {

        syntax: '*';

        inherits: false;

        initial-value: 0 0 #0000;

      }

      @property --tw-inset-shadow-color {

        syntax: '*';

        inherits: false;

      }

      @property --tw-inset-shadow-alpha {

        syntax: '<percentage>';

        inherits: false;

        initial-value: 100%;

      }

      @property --tw-ring-color {

        syntax: '*';

        inherits: false;

      }

      @property --tw-ring-shadow {

        syntax: '*';

        inherits: false;

        initial-value: 0 0 #0000;

      }

      @property --tw-inset-ring-color {

        syntax: '*';

        inherits: false;

      }

      @property --tw-inset-ring-shadow {

        syntax: '*';

        inherits: false;

        initial-value: 0 0 #0000;

      }

      @property --tw-ring-inset {

        syntax: '*';

        inherits: false;

      }

      @property --tw-ring-offset-width {

        syntax: '<length>';

        inherits: false;

        initial-value: 0;

      }

      @property --tw-ring-offset-color {

        syntax: '*';

        inherits: false;

        initial-value: #fff;

      }

      @property --tw-ring-offset-shadow {

        syntax: '*';

        inherits: false;

        initial-value: 0 0 #0000;

      }

      @property --tw-outline-style {

        syntax: '*';

        inherits: false;

        initial-value: solid;

      }

      @property --tw-backdrop-blur {

        syntax: '*';

        inherits: false;

      }

      @property --tw-backdrop-brightness {

        syntax: '*';

        inherits: false;

      }

      @property --tw-backdrop-contrast {

        syntax: '*';

        inherits: false;

      }

      @property --tw-backdrop-grayscale {

        syntax: '*';

        inherits: false;

      }

      @property --tw-backdrop-hue-rotate {

        syntax: '*';

        inherits: false;

      }

      @property --tw-backdrop-invert {

        syntax: '*';

        inherits: false;

      }

      @property --tw-backdrop-opacity {

        syntax: '*';

        inherits: false;

      }

      @property --tw-backdrop-saturate {

        syntax: '*';

        inherits: false;

      }

      /* 文本格式美化样式 */
      body, .story-text, .story-content {
        color: #000000 !important;
      }

      .dialogue-text {
        color: #000000 !important;
      }

      .psychology-text {
        color: #000000 !important;
      }

      .scenery-text {
        color: #000000 !important;
      }

      @property --tw-backdrop-sepia {

        syntax: '*';

        inherits: false;

      }

    </style>

  </head>

  <body>

    <div class="connected-panels">

      <!-- 左侧面板：训练员信息 -->

      <div class="parchment-page left-panel">

        <div class="panel-content">

          <!-- 存档读档按钮 -->

          <div class="save-section">

            <button id="save-load-btn" class="save-button subtle-hover">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path

                  d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6h-1v5.586l-2.293-2.293z"

                />

              </svg>

              <span>存档/读档</span>

            </button>

            <button id="fullscreen-btn" class="save-button subtle-hover">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path

                  d="M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 11-1.414 1.414L5 6.414V8a1 1 0 01-2 0V4zm9 1a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-2 0V6.414l-2.293 2.293a1 1 0 11-1.414-1.414L13.586 5H12zm-9 7a1 1 0 012 0v1.586l2.293-2.293a1 1 0 111.414 1.414L6.414 15H8a1 1 0 010 2H4a1 1 0 01-1-1v-4zm13-1a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293a1 1 0 111.414-1.414L15 13.586V12a1 1 0 011-1z"

                />

              </svg>

              <span>全屏</span>

            </button>

          </div>



          <!-- 状态条 -->

          <div class="status-section">

            <div class="status-item">

              <div class="status-header">

                <span class="status-label">理智值</span>

                <span class="status-value" id="sanity-value">0</span>

              </div>

              <div class="progress-bar">

                <div class="progress-fill" id="sanity-bar" style="width: 0%"></div>

              </div>

            </div>



            <div class="status-item">

              <div class="status-header">

                <span class="status-label">体力</span>

                <span class="status-value" id="stamina-value">0</span>

              </div>

              <div class="progress-bar">

                <div class="progress-fill" id="stamina-bar" style="width: 0%"></div>

              </div>

            </div>



            <div class="status-item">

              <div class="status-header">

                <span class="status-label">运气</span>

                <span class="status-value" id="luck-value">0</span>

              </div>

              <div class="progress-bar">

                <div class="progress-fill" id="luck-bar" style="width: 0%"></div>

              </div>

            </div>

          </div>



          <!-- 个人档案 -->

          <div class="profile-section">

            <div class="section-header">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" />

              </svg>

              <h3>个人档案</h3>

              <button class="expand-btn" id="profile-expand">

                <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                  <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />

                </svg>

              </button>

            </div>



            <div class="profile-basic" id="profile-basic">

              <div class="profile-link">点击查看完整档案...</div>

            </div>



            <div class="profile-detail" id="profile-detail" style="display: none">

              <div class="detail-card">

                <div class="detail-item">

                  <span class="label">身份:</span>

                  <span class="value">训练员</span>

                </div>

                <div class="detail-item">

                  <span class="label">背景:</span>

                  <span class="value" id="trainer-background">无</span>

                </div>



                <div class="detail-item">

                  <span class="label">状态:</span>

                  <span class="value" id="trainer-status">正常</span>

                </div>

                <div class="detail-item">

                  <span class="label">在校天数:</span>

                  <span class="value" id="days-in-park">0天</span>

                </div>

              </div>

            </div>

          </div>



          <!-- 人物历程 -->

          <div class="journey-section">

            <div class="section-header">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path

                  d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"

                />

              </svg>

              <h3>人物历程</h3>

              <button class="expand-btn" id="journey-history-btn">

                <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                  <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />

                </svg>

              </button>

            </div>



            <div class="journey-basic" id="journey-basic">

              <div class="journey-link">点击查看完整历程记录...</div>

            </div>



            <div class="journey-detail" id="journey-detail" style="display: none">

              <div class="journey-list">

                <div class="journey-entry">

                  <div class="journey-header">

                    <span class="journey-day">第1天</span>

                    <span class="journey-status normal">正常</span>

                  </div>

                  <div class="journey-event">初入训练场</div>

                  <div class="journey-desc">第一次见到了那些美丽的赛马娘们，心中充满期待</div>

                </div>

                <div class="journey-entry">

                  <div class="journey-header">

                    <span class="journey-day">第15天</span>

                    <span class="journey-status confused">困惑</span>

                  </div>

                  <div class="journey-event">午夜的呼唤</div>

                  <div class="journey-desc">深夜听到了不应该存在的马蹄声，开始感到不安</div>

                  <div class="sanity-change horror-glow">理智值 -10</div>

                </div>

              </div>

            </div>

          </div>



          <!-- 物品栏 -->

          <div class="inventory-section">

            <div class="section-header">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" />

              </svg>

              <h3>物品栏</h3>

              <div class="command-manager-dot" id="command-manager-dot" style="display: none">

                <span class="dot-icon">📋</span>

                <span class="dot-count">0</span>

              </div>

            </div>



            <div class="inventory-container" id="inventory-list">

              <div class="empty-inventory">物品栏为空</div>

            </div>

          </div>

        </div>

      </div>



      <!-- 分隔线 -->

      <div class="panel-divider"></div>



      <!-- 中央面板：正文内容 -->

      <div class="parchment-page center-panel">

        <div class="story-container">

          <div class="story-content" id="story-content">

            <p class="story-text">等待故事内容加载...</p>

            <span class="typewriter-cursor">|</span>

          </div>

        </div>



        <div class="input-section ruled-paper">

          <div class="input-header">

            <div class="time-display">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path

                  fill-rule="evenodd"

                  d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z"

                />

              </svg>

              <span id="current-time">等待时间加载...</span>

            </div>

            

            <!-- 技能按钮区域 -->

            <div class="skills-section" id="skills-section" style="display: none;">

              <!-- 技能按钮将根据当前大天赋动态生成 -->
            </div>

            

            <button id="danger-btn" class="danger-button twisted-love-accent">危险时段</button>

          </div>



          <div class="input-container">

            <span class="input-prompt">{">"}</span>

            <textarea id="action-input" placeholder="输入你的行动..." class="action-input"></textarea>

            <div class="input-controls">

              <button id="btn-send-action" class="send-button">发送</button>

            </div>

          </div>

        </div>

      </div>



      <!-- 分隔线 -->

      <div class="panel-divider"></div>



      <!-- 右侧面板：禁忌规则和赛马娘状态 -->

      <div class="parchment-page right-panel">

        <div class="panel-content">

          <!-- 查看规则按钮 -->

          <div class="rules-section">

            <button id="view-rules-btn" class="view-rules-button">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />

              </svg>

              <span>查看规则</span>

            </button>

          </div>



          <!-- 天赋管理按钮 -->

          <div class="rules-section">

            <button id="manage-talents-btn" class="view-rules-button">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path

                  fill-rule="evenodd"

                  d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"

                  clip-rule="evenodd"

                />

              </svg>

              <span>天赋管理</span>

            </button>

          </div>



          <!-- 赛马娘状态 -->

          <div class="uma-section">

            <div class="section-header">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path

                  fill-rule="evenodd"

                  d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z"

                />

              </svg>

              <h3>赛马娘状态</h3>

              <button class="roster-btn" id="uma-roster-btn" title="马娘记名册" onclick="window.teresenDebug.openUmaRoster()">

                📖

              </button>

            </div>



            <div class="uma-list" id="uma-status">

              <div class="loading-uma">等待状态加载...</div>

            </div>

          </div>



          <!-- QTE挣扎区域 -->

          <div class="qte-section" id="qte-section" style="display: none">

            <div class="section-header">

              <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

                <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z" />

              </svg>

              <h3>挣扎选项</h3>

            </div>



            <div class="qte-container">

              <div class="qte-info">

                <p class="qte-description">你被马娘束缚了！</p>

                <p class="qte-subtitle">选择你的行动...</p>

              </div>



              <div class="qte-options">

                <button

                  class="qte-btn struggle-btn"

                  id="qte-struggle-btn"

                  onclick="window.teresenDebug.triggerQTE('struggle')"

                >

                  <span class="qte-icon">💪</span>

                  <span class="qte-text">奋力挣扎</span>

                  <span class="qte-desc">尝试挣脱束缚</span>

                </button>



                <button

                  class="qte-btn submit-btn"

                  id="qte-submit-btn"

                  onclick="window.teresenDebug.triggerQTE('submit')"

                >

                  <span class="qte-icon">😌</span>

                  <span class="qte-text">不反抗</span>

                  <span class="qte-desc">接受现状</span>

                </button>

              </div>

            </div>

          </div>

        </div>

      </div>



      <!-- 底部面板：货币系统、节日通知、规则倒计时 -->

      <div class="bottom-panel">

        <!-- 货币相关 -->

        <div class="bottom-group">

          <div class="currency-section">

            <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

              <path

                d="M8.433 7.418c.155-.103.346-.196.567-.267v1.698a2.305 2.305 0 01-.567-.267C8.07 8.34 8 8.114 8 8c0-.114.07-.34.433-.582zM11 12.849v-1.698c.22.071.412.164.567.267.364.243.433.468.433.582 0 .114-.07.34-.433.582a2.305 2.305 0 01-.567.267z"

              />

              <path

                fill-rule="evenodd"

                d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a1 1 0 10-2 0v.092a4.535 4.535 0 00-1.676.662C6.602 6.234 6 8c0 .99.602 1.765 1.324 2.246.48.32 1.054.545 1.676.662v1.941c-.391-.127-.68-.317-.843-.504a1 1 0 10-1.51 1.31c.562.649 1.413 1.076 2.353 1.253V15a1 1 0 102 0v-.092a4.535 4.535 0 001.676-.662C13.398 13.766 14 12.991 14 12c0-.99-.602-1.765-1.324-2.246A4.535 4.535 0 0011 9.092V7.151c.391.127.68.317.843.504a1 1 0 101.511-1.31c-.563-.649-1.413-1.076-2.354-1.253V5z"

                clip-rule="evenodd"

              />

            </svg>

            <span>实验点数: <span id="currency-value">0</span></span>

          </div>



          <div class="gacha-coin" id="gacha-coin">

            <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

              <path

                fill-rule="evenodd"

                d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a1 1 0 10-2 0v.092a4.535 4.535 0 00-1.676.662C6.602 6.234 6 8c0 .99.602 1.765 1.324 2.246.48.32 1.054.545 1.676.662v1.941c-.391-.127-.68-.317-.843-.504a1 1 0 10-1.51 1.31c.562.649 1.413 1.076 2.353 1.253V15a1 1 0 102 0v-.092a4.535 4.535 0 001.676-.662C13.398 13.766 14 12.991 14 12c0-.99-.602-1.765-1.324-2.246A4.535 4.535 0 0011 9.092V7.151c.391.127.68.317.843.504a1 1 0 101.511-1.31c-.563-.649-1.413-1.076-2.354-1.253V5z"

                clip-rule="evenodd"

              />

            </svg>

            <span id="gacha-coin-text">扭蛋币: 0</span>

          </div>



          <div class="tarot-divination" id="tarot-divination">
            <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

              <path

                fill-rule="evenodd"

                d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"

              />

            </svg>

            <span id="tarot-divination-text">塔罗占卜</span>
          </div>

        </div>



        <!-- 时间相关 -->

        <div class="bottom-group">

          <div class="festival-notice" id="festival-notice" style="display: none">

            <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

              <path

                d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"

              />

            </svg>

            <span id="festival-text">节日通知</span>

          </div>







          <div class="reply-timer" id="reply-timer">

            <svg class="icon" fill="currentColor" viewBox="0 0 20 20">

              <path

                fill-rule="evenodd"

                d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z"

              />

            </svg>

            <span id="reply-timer-text">回复时间: --:--</span>

          </div>

        </div>

      </div>

    </div>



    <!-- 规则页面模态框 -->

    <div id="rules-modal" class="rules-modal" style="display: none">

      <div class="rules-modal-content">

        <div class="rules-modal-header">

          <h2 class="rules-title">特雷森规则怪谈</h2>

          <div class="music-controls" style="display: flex; align-items: center; gap: 10px; margin-right: 10px;">
            <button id="music-controller" class="music-btn" style="background: rgba(139, 105, 20, 0.8); border: 1px solid #8b6914; color: #fdfbf7; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;" title="点击切换音乐 (共2首，第3次点击关闭)">🎵 音乐控制</button>
          </div>

          <button id="close-rules-btn" class="close-rules-btn">×</button>

        </div>

        <div class="rules-modal-body">

          <div class="rules-section-fixed">

            <h3 class="rules-section-title">生存规则</h3>

            <div id="fixed-rules-list" class="rules-list-handwritten"></div>

          </div>

          <div class="rules-section-random">

            <h3 class="rules-section-title">规则记录</h3>
            <div class="rules-record-controls">
              <button id="add-rule-btn" class="add-rule-btn">+ 添加规则</button>
              <button id="clear-rules-btn" class="clear-rules-btn">清空记录</button>
            </div>
            <div id="random-rules-list" class="rules-list-handwritten"></div>

          </div>

        </div>

      </div>

    </div>





    <!-- 读档模态框 -->

    <div id="load-modal" class="rules-modal" style="display: none">

      <div class="rules-modal-content">

        <div class="rules-modal-header">

          <h2 class="rules-title">读取存档</h2>

          <button id="close-load-btn" class="close-rules-btn">×</button>

        </div>

        <div class="rules-modal-body">

          <div class="load-section">

            <h3 class="rules-section-title">本地存档 (localStorage)</h3>

            <div id="local-saves-list" class="saves-list"></div>

            <h3 class="rules-section-title">世界书存档 (TavernHelper)</h3>

            <div id="worldbook-saves-list" class="saves-list"></div>

          </div>

        </div>

      </div>

    </div>



    <!-- 历史记录模态框 -->

    <div id="history-modal" class="rules-modal" style="display: none">

      <div class="rules-modal-content">

        <div class="rules-modal-header">

          <h2 class="rules-title">历史记录</h2>

          <button id="close-history-btn" class="close-rules-btn">×</button>

        </div>

        <div class="rules-modal-body">

          <div class="history-section">

            <h3 class="rules-section-title">人物历程</h3>

            <div id="current-journey-list" class="journey-list"></div>

          </div>

        </div>

      </div>

    </div>


    <!-- 塔罗占卜模态框 -->
    <div id="tarot-modal" class="rules-modal" style="display: none">
      <div class="rules-modal-content tarot-modal-content">
        <div class="rules-modal-header">
          <h2 class="rules-title">特雷森学院塔罗占卜</h2>
          <button id="close-tarot-btn" class="close-rules-btn">×</button>
        </div>
        <div class="rules-modal-body">
          <div class="tarot-section">
            <div class="tarot-info">
              <p>今日剩余占卜次数: <span id="tarot-remaining">3</span></p>
              <p>当前理智: <span id="tarot-sanity">--</span></p>
            </div>
            
            <div class="tarot-spreads">
              <h3 class="rules-section-title">基础占卜</h3>
              <div class="spread-buttons">
                <button class="spread-btn" data-spread="single" data-cost="5">
                  <span class="spread-icon">🔮</span>
                  <span class="spread-name">单张牌占卜</span>
                  <span class="spread-cost">消耗5理智</span>
                </button>
                <button class="spread-btn" data-spread="timeline" data-cost="10">
                  <span class="spread-icon">⏰</span>
                  <span class="spread-name">时间之流</span>
                  <span class="spread-cost">消耗10理智</span>
                </button>
                <button class="spread-btn" data-spread="choice" data-cost="8">
                  <span class="spread-icon">⚖️</span>
                  <span class="spread-name">二选一</span>
                  <span class="spread-cost">消耗8理智</span>
                </button>
              </div>
              
              <h3 class="rules-section-title">高级占卜</h3>
              <div class="spread-buttons">
                <button class="spread-btn advanced" data-spread="hexagram" data-cost="15" data-requirement="7">
                  <span class="spread-icon">⭐</span>
                  <span class="spread-name">六芒星占卜</span>
                  <span class="spread-cost">消耗15理智</span>
                  <span class="spread-requirement">需要在校天数≥7</span>
                </button>
                <button class="spread-btn advanced" data-spread="celtic" data-cost="20" data-requirement="14">
                  <span class="spread-icon">🕯️</span>
                  <span class="spread-name">凯尔特十字</span>
                  <span class="spread-cost">消耗20理智</span>
                  <span class="spread-requirement">需要在校天数≥14</span>
                </button>
                <button class="spread-btn advanced" data-spread="zodiac" data-cost="25" data-requirement="21">
                  <span class="spread-icon">🌟</span>
                  <span class="spread-name">黄道十二宫</span>
                  <span class="spread-cost">消耗25理智</span>
                  <span class="spread-requirement">需要在校天数≥21</span>
                </button>
              </div>
            </div>
            
            <div class="tarot-result" id="tarot-result" style="display: none">
              <h3 class="rules-section-title">占卜结果</h3>
              <div id="tarot-cards" class="tarot-cards"></div>
              <div id="tarot-interpretation" class="tarot-interpretation"></div>
              <div id="tarot-effects" class="tarot-effects"></div>
            </div>
          </div>
        </div>
      </div>
    </div>


    <!-- 指令管理模态框 -->

    <div id="command-modal" class="rules-modal" style="display: none">

      <div class="rules-modal-content">

        <div class="rules-modal-header">

          <h2 class="rules-title">指令管理</h2>

          <button id="close-command-btn" class="close-rules-btn">×</button>

        </div>

        <div class="rules-modal-body">

          <div class="command-section">

            <div class="command-list">

              <!-- 指令列表将在这里动态生成 -->

            </div>

            <div class="command-footer">

              <button class="clear-all-btn">清除全部</button>

            </div>

          </div>

        </div>

      </div>

    </div>







    <!-- 音效 -->

    <audio id="page-flip-sound" preload="auto">

      <source src="https://files.catbox.moe/5ppdp9.mp3" type="audio/mpeg" />

    </audio>



    <audio id="talent-sound" preload="auto">

      <source src="https://files.catbox.moe/5091vt.mp3" type="audio/mpeg" />

    </audio>


    <audio id="tarot-shuffle" preload="auto">

      <source src="https://files.catbox.moe/b4b019.mp3" type="audio/mpeg" />

    </audio>

    <!-- 背景音乐 -->
    <audio id="bgm-track1" class="music-source" src="https://files.catbox.moe/umai3u.m4a" loop preload="auto"></audio>
    <audio id="bgm-track2" class="music-source" src="https://files.catbox.moe/j0qaqf.m4a" loop preload="auto"></audio>


    <audio id="save-load-sound" preload="auto">

      <source src="https://files.catbox.moe/m9h2z4.mp3" type="audio/mpeg" />

    </audio>



    <audio id="danger-rules-sound" preload="auto">

      <source src="https://files.catbox.moe/zxb18s.mp3" type="audio/mpeg" />

    </audio>



    <audio id="item-detail-sound" preload="auto">

      <source src="https://files.catbox.moe/412btp.mp3" type="audio/mpeg" />

    </audio>



    <audio id="uma-roster-sound" preload="auto">

      <source src="https://files.catbox.moe/zxb18s.mp3" type="audio/mpeg" />

    </audio>



    <audio id="journey-history-sound" preload="auto">

      <source src="https://files.catbox.moe/zxb18s.mp3" type="audio/mpeg" />

    </audio>



    <!-- 变量管理器脚本 -->



    <!-- 道具系统升级脚本 -->

    <script>

      // 道具系统升级功能

      let pendingActions = [];

      let giftSelectionMode = null;

      let skillSelectionMode = null;



      // 暴露到全局作用域，供MVU管理器使用

      window.pendingActions = pendingActions;



      // 初始化

      $(document).ready(function () {

        loadPendingActions();

        updateActionIcons();

        updateInventoryCommandManager();



        // 定期更新物品栏管理功能

        setInterval(function () {

          updateInventoryCommandManager();

        }, 2000);

      });



      // 添加待执行指令

      function addPendingAction(action, itemName, extraData = {}) {

        const actionObj = {

          action: action,

          itemName: itemName,

          ...extraData,

        };



        pendingActions.push(actionObj);

        savePendingActions();

        updateActionIcons();

        updateInventoryCommandManager();



        // 同步到全局

        window.pendingActions = pendingActions;

      }



      // 移除指定指令

      function removeAction(index) {

        pendingActions.splice(index, 1);

        savePendingActions();

        updateActionIcons();

        updateInventoryCommandManager();

      }



      // 清除所有指令

      function clearAllActions() {

        if (pendingActions.length === 0) {

          return;

        }



        if (confirm('确定要清除所有待执行指令吗？')) {

          pendingActions = [];

          savePendingActions();

          updateActionIcons();

          updateInventoryCommandManager();

        }

      }



      // 切换道具锁定状态

      function toggleItemLock(itemName, button) {

        const isLocked = button.text() === '解锁';

        button.text(isLocked ? '锁定' : '解锁');

        button.css('background', isLocked ? '#4a5568' : '#e53e3e');



        // 更新丢弃按钮状态

        const discardBtn = button.siblings('.item-discard-btn');

        if (isLocked) {

          discardBtn.prop('disabled', false).css('opacity', '1');

        } else {

          discardBtn.prop('disabled', true).css('opacity', '0.5');

        }

      }



      // 开始赠送选择

      function startGiftSelection(itemName) {

        showGiftHint();

        highlightCharacterCards();



        giftSelectionMode = {

          active: true,

          itemName: itemName,

          startTime: Date.now(),

        };



        // 30秒超时自动取消

        setTimeout(() => {

          if (giftSelectionMode?.active) {

            cancelGiftSelection();

          }

        }, 30000);

      }



      // 显示赠送提示

      function showGiftHint() {

        // 先移除现有的提示

        $('.gift-selection-hint').remove();

        

        const hint = $('<div class="gift-selection-hint">').html(`

            <div class="hint-content">

              <span class="hint-icon">🎁</span>

              <span class="hint-text">请点击要赠送的马娘卡片</span>

              <button class="hint-close" onclick="$(this).closest('.gift-selection-hint').remove()">×</button>

            </div>

          `);



        $('body').append(hint);



        // 3秒后自动移除

        setTimeout(() => {

          hint.remove();

        }, 3000);

      }



      // 高亮马娘卡片

      function highlightCharacterCards() {

        $('.character-card, .uma-item, .character-item').addClass('gift-selectable skill-selectable');

      }



      // 处理马娘卡片点击（用于赠送选择）

      $(document).on('click', '.gift-selectable', function () {

        if (!giftSelectionMode?.active) return;



        const characterName = getCharacterNameFromCard($(this));

        const characterId = getCharacterIdFromCard($(this));



        addPendingAction('gift', giftSelectionMode.itemName, {

          characterName: characterName,

          characterId: characterId,

        });



        cancelGiftSelection();



        // 防止重复点击

        $(this).off('click');

      });



      // 处理马娘卡片点击（用于技能选择）

      $(document).on('click', '.skill-selectable', function () {

        if (!skillSelectionMode?.active) return;



        const characterName = getCharacterNameFromCard($(this));

        const characterId = getCharacterIdFromCard($(this));



        addPendingAction('skill', skillSelectionMode.skillName, {

          skillType: skillSelectionMode.skillType,

          target: 'uma',

          characterName: characterName,

          characterId: characterId,

        });



        cancelSkillSelection();



        // 防止重复点击

        $(this).off('click');

      });



      // 取消赠送选择

      function cancelGiftSelection() {

        clearGiftSelectionMode();

        giftSelectionMode = null;

      }



      // 清除赠送选择模式

      function clearGiftSelectionMode() {

        $('.gift-selectable').removeClass('gift-selectable');

        $('.skill-selectable').removeClass('skill-selectable');

      }



      // 开始技能选择

      function startSkillSelection(skillName, skillType) {

        showSkillHint();

        highlightCharacterCards();



        skillSelectionMode = {

          active: true,

          skillName: skillName,

          skillType: skillType,

          startTime: Date.now(),

        };



        // 30秒超时自动取消

        setTimeout(() => {

          if (skillSelectionMode?.active) {

            cancelSkillSelection();

          }

        }, 30000);

      }



      // 显示技能提示

      function showSkillHint() {

        // 先移除现有的提示

        $('.skill-selection-hint').remove();

        

        const hint = $('<div class="skill-selection-hint">').html(`

            <div class="hint-content">

              <span class="hint-icon">⚡</span>

              <span class="hint-text">请点击要对马娘使用技能的目标</span>

              <button class="hint-close" onclick="$(this).closest('.skill-selection-hint').remove()">×</button>

            </div>

          `);



        $('body').append(hint);



        // 3秒后自动移除

        setTimeout(() => {

          hint.remove();

        }, 3000);

      }



      // 取消技能选择

      function cancelSkillSelection() {

        clearSkillSelectionMode();

        skillSelectionMode = null;

      }



      // 清除技能选择模式

      function clearSkillSelectionMode() {

        $('.skill-selectable').removeClass('skill-selectable');

      }



      // 从卡片获取角色名称

      function getCharacterNameFromCard(card) {

        const nameElement = card.find('.character-name, .uma-name, .name');

        return nameElement.length ? nameElement.text().trim() : '未知角色';

      }



      // 从卡片获取角色ID

      function getCharacterIdFromCard(card) {

        return card.data('character-id') || card.attr('id') || 'unknown';

      }



      // 保存指令到本地存储

      function savePendingActions() {

        localStorage.setItem('item_pending_actions', JSON.stringify(pendingActions));

      }



      // 从本地存储加载指令

      function loadPendingActions() {

        const saved = localStorage.getItem('item_pending_actions');

        pendingActions = saved ? JSON.parse(saved) : [];

      }



      // 更新指令图标显示

      function updateActionIcons() {

        const timeLocationBar = $('.time-location-bar');

        if (!timeLocationBar.length) return;



        // 移除现有图标

        timeLocationBar.find('.action-icons-container').remove();



        if (pendingActions.length === 0) return;



        // 统计各种操作的数量

        const actionCounts = { use: 0, discard: 0, gift: 0, lock: 0, skill: 0 };

        pendingActions.forEach(action => {

          if (actionCounts.hasOwnProperty(action.action)) {

            actionCounts[action.action]++;

          }

        });



        // 生成图标HTML

        const icons = [];

        if (actionCounts.use > 0) {

          icons.push(

            `<span class="action-icon use-icon" title="使用 ${actionCounts.use} 个道具"> (${actionCounts.use})</span>`,

          );

        }

        if (actionCounts.discard > 0) {

          icons.push(

            `<span class="action-icon discard-icon" title="丢弃 ${actionCounts.discard} 个道具">🗑️ (${actionCounts.discard})</span>`,

          );

        }

        if (actionCounts.gift > 0) {

          icons.push(

            `<span class="action-icon gift-icon" title="赠送 ${actionCounts.gift} 个道具">🎁 (${actionCounts.gift})</span>`,

          );

        }

        if (actionCounts.lock > 0) {

          icons.push(

            `<span class="action-icon lock-icon" title="锁定 ${actionCounts.lock} 个道具">🔒 (${actionCounts.lock})</span>`,

          );

        }

        if (actionCounts.skill > 0) {

          icons.push(

            `<span class="action-icon skill-icon" title="使用 ${actionCounts.skill} 个技能">⚡ (${actionCounts.skill})</span>`,

          );

        }



        if (icons.length > 0) {

          const iconsContainer = $('<div class="action-icons-container">').html(icons.join(''));

          timeLocationBar.find('.current-location').after(iconsContainer);

        }

      }



      // 更新物品栏管理指令功能

      function updateInventoryCommandManager() {

        const commandDot = $('#command-manager-dot');



        if (pendingActions.length > 0) {

          commandDot.show();

          commandDot.find('.dot-count').text(pendingActions.length);



          // 绑定点击事件

          commandDot.off('click').on('click', function () {

            toggleCommandManager();

          });

        } else {

          commandDot.hide();

        }

      }



      // 切换指令管理器显示

      function toggleCommandManager() {

        const commandModal = $('#command-modal');

        const isVisible = commandModal.is(':visible');



        if (isVisible) {

          commandModal.hide();

        } else {

          commandModal.show();

          updateCommandList();

        }

      }



      // 绑定关闭按钮事件

      $(document).on('click', '#close-command-btn', function () {

        $('#command-modal').hide();

      });



      // 绑定点击背景关闭弹窗事件

      $(document).on('click', '#command-modal', function (e) {

        if (e.target === this) {

          $('#command-modal').hide();

        }

      });



      // 绑定清除全部按钮事件

      $(document).on('click', '.clear-all-btn', function () {

        clearAllActions();

        updateCommandList();

      });



      // 更新指令列表

      function updateCommandList() {

        const commandList = $('#command-modal .command-list');



        if (pendingActions.length === 0) {

          commandList.html('<div class="empty-command">暂无待执行指令</div>');

          return;

        }



        const commandItems = pendingActions

          .map(

            (action, index) => `

                <div class="command-item">

                  <div class="command-content">

                    <span class="command-icon">${getActionIcon(action.action)}</span>

                    <span class="command-text">${formatActionText(action)}</span>

                  </div>

                  <button class="remove-command-btn" onclick="removeAction(${index}); updateCommandList();">×</button>

                </div>

              `,

          )

          .join('');



        commandList.html(commandItems);

      }



      // 获取操作图标

      function getActionIcon(action) {

        const icons = {

          use: ' ',

          discard: '🗑️',

          gift: '🎁',

          lock: '🔒',

          skill: '⚡',

        };

        return icons[action] || '📝';

      }



      // 格式化指令文本

      function formatActionText(action) {

        switch (action.action) {

          case 'use':
            let useText = `使用道具 [${action.itemName}]`;
            if (action.itemData) {
              useText += `\n效果: ${action.itemData.效果 || '无效果说明'}`;
              useText += `\n稀有度: ${action.itemData.稀有度 || '普通'}`;
            }
            return useText;

          case 'discard':
            let discardText = `丢弃道具 [${action.itemName}]`;
            if (action.itemData) {
              discardText += `\n描述: ${action.itemData.描述 || '无描述'}`;
            }
            return discardText;

          case 'gift':
            let giftText = `赠送道具 [${action.itemName}] 给 [${action.characterName || action.target}]`;
            if (action.itemData) {
              giftText += `\n效果: ${action.itemData.效果 || '无效果说明'}`;
            }
            return giftText;

          case 'lock':
            let lockText = `锁定道具 [${action.itemName}]`;
            if (action.itemData) {
              lockText += `\n描述: ${action.itemData.描述 || '无描述'}`;
            }
            return lockText;

          case 'skill':

            // 获取技能详细信息
            let skillInfo = '';
            if (action.skillType && action.majorTalent) {
              // 根据技能类型获取详细信息
              const skillDetails = {
                // 强化系（占有之爱）
                'defense': { name: '防御技能', description: '基于强化系天赋的防御能力，可以强化自身防御力。' },
                'rule_enhance': { name: '规则洞察', description: '基于强化系天赋的洞察能力，可以看穿规则的本质。' },
                'chain_enhance': { name: '锁链控制', description: '基于强化系天赋的控制能力，可以强化锁链的束缚效果。' },
                // 变化系（谎言之爱）
                'rule_change': { name: '规则修改', description: '基于变化系天赋的修改能力，可以临时改变规则。' },
                'emotion': { name: '情感操控', description: '基于变化系天赋的操控能力，可以操控目标的情感。' },
                'shadow': { name: '影子操控', description: '基于变化系天赋的影子能力，可以操控影子进行攻击。' },
                // 放出系（牺牲之爱）
                'emotion_release': { name: '情绪释放', description: '基于放出系天赋的释放能力，可以释放强烈的情感能量。' },
                'sacrifice': { name: '生命献祭', description: '基于放出系天赋的献祭能力，可以牺牲生命或记忆获得力量。' },
                'phantom': { name: '分身具现', description: '基于放出系天赋的分身能力，可以具现化幻影分身。' },
                // 操作系（控制之爱）
                'suggestion': { name: '心理暗示', description: '基于操作系天赋的心理暗示能力，可以植入思想控制目标。' },
                'control': { name: '精神操控', description: '基于操作系天赋的精神操控能力，可以直接控制敌人行动。' },
                'absorption': { name: '爱意吸收', description: '基于操作系天赋的吸收能力，可以吸收他人的爱意获得力量。' },
                // 具现化系（理想之爱）
                'armor': { name: '理想盔甲', description: '基于具现化系天赋的盔甲能力，可以具现化完美的防护装备。' },
                'ring': { name: '承诺戒指', description: '基于具现化系天赋的戒指能力，可以具现化拥有强大力量的戒指。' },
                'npc': { name: '完美NPC', description: '基于具现化系天赋的NPC能力，可以具现化完美的助手。' },
                // 特质系（扭曲之爱）
                'contract': { name: '怪谈契约', description: '基于特质系天赋的契约能力，可以与规则怪谈签订契约。' },
                'resonance': { name: '情绪共鸣', description: '基于特质系天赋的共鸣能力，可以与目标进行情绪共鸣。' },
                'chaos': { name: '混沌混合', description: '基于特质系天赋的混合能力，可以混合不同爱意创造新技能。' }
              };
              
              const skillDetail = skillDetails[action.skillType];
              if (skillDetail) {
                skillInfo = `使用大天赋技能 [${skillDetail.name}] (${action.majorTalent})\n技能描述: ${skillDetail.description}`;
              }
            }

            if (action.target === 'self') {
              return `${skillInfo}\n使用目标: 自己`;
            } else if (action.target === 'uma' && action.characterName) {
              return `${skillInfo}\n使用目标: ${action.characterName}`;
            } else {
              return `${skillInfo}\n使用目标: 未指定`;
            }

          default:

            return JSON.stringify(action);

        }

      }



      // 显示临时消息

      function showTemporaryMessage(message) {

        const messageDiv = $('<div class="temporary-message">').text(message);

        $('body').append(messageDiv);



        setTimeout(() => {

          messageDiv.remove();

        }, 2000);

      }



      // 获取待执行指令（供外部调用）

      window.getPendingActions = function () {

        return pendingActions;

      };



      // 清除所有指令（供外部调用）

      window.clearAllPendingActions = function () {

        clearAllActions();

      };



      // ESC键取消赠送选择

      $(document).on('keydown', function (e) {

        if (e.key === 'Escape' && giftSelectionMode?.active) {

          cancelGiftSelection();

        }

        if (e.key === 'Escape' && skillSelectionMode?.active) {

          cancelSkillSelection();

        }

      });

    </script>



    <!-- 道具系统样式 -->

    <style>

      /* 道具弹窗按钮样式 */

      .item-info-row {

        display: flex;

        justify-content: space-between;

        align-items: center;

        margin-top: 0.5rem;

      }



      .item-actions {

        display: flex;

        gap: 4px;

        align-items: center;

      }



      .item-use-btn,

      .item-discard-btn,

      .item-lock-btn,

      .item-gift-btn {

        padding: 6px;

        border: none;

        border-radius: 50%;

        font-size: 14px;

        font-weight: bold;

        cursor: pointer;

        transition: all 0.2s;

        width: 28px;

        height: 28px;

        display: flex;

        align-items: center;

        justify-content: center;

        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);

      }



      .item-use-btn:hover,

      .item-discard-btn:hover,

      .item-lock-btn:hover,

      .item-gift-btn:hover {

        transform: scale(1.1);

        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);

      }



      .item-use-btn {

        background: #38a169;

        color: white;

      }



      .item-use-btn:hover {

        background: #2f855a;

      }



      .item-discard-btn {

        background: #e53e3e;

        color: white;

      }



      .item-discard-btn:hover {

        background: #c53030;

      }

      .item-discard-btn:disabled {

        opacity: 0.5;

        cursor: not-allowed;

      }



      .item-lock-btn {

        background: #4a5568;

        color: white;

      }



      .item-lock-btn:hover {

        background: #2d3748;

      }



      .item-gift-btn {

        background: #d69e2e;

        color: white;

      }



      .item-gift-btn:hover {

        background: #b7791f;

      }



      /* 指令图标样式 */

      .action-icons-container {

        display: flex;

        align-items: center;

        gap: 8px;

        margin: 0 15px;

      }



      .action-icon {

        display: inline-flex;

        align-items: center;

        padding: 3px 6px;

        border-radius: 12px;

        font-size: 11px;

        font-weight: bold;

        cursor: pointer;

        transition: all 0.2s;

        border: 1px solid transparent;

      }



      .action-icon:hover {

        transform: scale(1.1);

      }



      .use-icon {

        background: #38a169;

        color: white;

        border-color: #2f855a;

      }



      .discard-icon {

        background: #e53e3e;

        color: white;

        border-color: #c53030;

      }



      .gift-icon {

        background: #d69e2e;

        color: white;

        border-color: #b7791f;

      }



      .lock-icon {

        background: #4a5568;

        color: white;

        border-color: #2d3748;

      }



      .skill-icon {

        background: #805ad5;

        color: white;

        border-color: #6b46c1;

      }



      /* 赠送选择提示样式 */

      .gift-selection-hint {

        position: fixed;

        top: 20px;

        right: 20px;

        background: rgba(0, 0, 0, 0.9);

        color: white;

        padding: 15px 20px;

        border-radius: 8px;

        font-size: 14px;

        z-index: 1001;

        animation: fadeInOut 2s ease-in-out;

      }



      .hint-content {

        display: flex;

        align-items: center;

        gap: 10px;

      }



      .hint-icon {

        font-size: 18px;

      }



      .hint-close {

        background: none;

        border: none;

        color: white;

        font-size: 16px;

        cursor: pointer;

        margin-left: 10px;

      }



      /* 技能选择提示样式 */

      .skill-selection-hint {

        position: fixed;

        top: 20px;

        right: 20px;

        background: rgba(128, 90, 213, 0.9);

        color: white;

        padding: 15px 20px;

        border-radius: 8px;

        font-size: 14px;

        z-index: 1001;

        animation: fadeInOut 2s ease-in-out;

      }



      /* 技能系统样式 */

      .skills-section {

        display: flex;

        gap: 8px;

        align-items: center;

        margin: 0 15px;

      }



      .skill-btn {

        display: flex;

        align-items: center;

        justify-content: center;

        padding: 2px 4px;

        border: 1px solid #8b4513;

        border-radius: 4px;

        background: linear-gradient(135deg, #2d1b1b, #1a0f0f);

        color: #ffffff;

        cursor: pointer;

        transition: all 0.3s ease;

        width: 24px;

        height: 24px;

        box-shadow: 0 1px 2px rgba(139, 69, 19, 0.3);

      }



      .skill-btn:hover {

        transform: translateY(-2px);

        box-shadow: 0 4px 16px rgba(139, 69, 19, 0.5);

        border-color: #a0522d;

      }



      .skill-btn:active {

        transform: translateY(0);

      }



      .skill-icon {

        font-size: 12px;

        filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));

      }



      .no-skills-message {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2px 8px;
        border: 1px solid rgba(139, 69, 19, 0.3);
        border-radius: 4px;
        background: linear-gradient(135deg, rgba(45, 27, 27, 0.6), rgba(26, 15, 15, 0.6));
        color: rgba(139, 69, 19, 0.9);
        font-size: 11px;
        font-style: italic;
        width: 120px;
        height: 24px;
        box-shadow: 0 1px 3px rgba(139, 69, 19, 0.3);
        opacity: 1;
        transition: all 0.3s ease;
      }

      .no-skills-message:hover {
        opacity: 1;
        border-color: rgba(139, 69, 19, 0.5);
        box-shadow: 0 2px 4px rgba(139, 69, 19, 0.3);
      }





      .skill-use-btn {

        background: linear-gradient(135deg, #805ad5, #6b46c1);

        color: white;

        border: none;

        border-radius: 0.25rem;

        padding: 0.25rem 0.5rem;

        font-size: 0.7rem;

        cursor: pointer;

        margin: 0.25rem 0.25rem 0 0;

        transition: all 0.2s;

      }



      .skill-use-btn:hover {

        background: linear-gradient(135deg, #6b46c1, #553c9a);

        transform: translateY(-1px);

      }



      @keyframes fadeInOut {

        0%,

        100% {

          opacity: 0;

        }

        20%,

        80% {

          opacity: 1;

        }

      }



      /* 可选择的马娘卡片样式 */

      .gift-selectable {

        cursor: pointer;

      }



      .skill-selectable {

        cursor: pointer;

        transform: scale(1.05);

        box-shadow: 0 0 20px rgba(128, 90, 213, 0.6);

        transition: all 0.3s ease;

      }



      .skill-selectable:hover {

        transform: scale(1.1);

        box-shadow: 0 0 30px rgba(128, 90, 213, 0.8);

      }



      /* 临时消息样式 */

      .temporary-message {

        position: fixed;

        top: 20px;

        right: 20px;

        background: rgba(0, 0, 0, 0.8);

        color: white;

        padding: 10px 15px;

        border-radius: 6px;

        font-size: 12px;

        z-index: 1002;

        animation: slideIn 0.3s ease-out;

      }



      @keyframes slideIn {

        from {

          transform: translateX(100%);

          opacity: 0;

        }

        to {

          transform: translateX(0);

          opacity: 1;

        }

      }


      @keyframes tarotResultFadeIn {
        from {
          opacity: 0;
          transform: scale(0.8) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .tarot-result-card:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 8px 25px rgba(168, 85, 247, 0.5);
      }

      .tarot-result-card.reversed:hover {
        transform: rotate(180deg) translateY(-5px) scale(1.05);
      }

      @keyframes tarotStartPulse {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
      }

      @keyframes tarotIconFloat {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
      }

      @keyframes tarotDotPulse {
        0%, 100% { 
          transform: scale(1);
          opacity: 0.6;
        }
        50% { 
          transform: scale(1.2);
          opacity: 1;
        }
      }

      @keyframes tarotFloat {
        0%, 100% { 
          transform: translateY(0px) rotate(0deg);
          opacity: 0.3;
        }
        50% { 
          transform: translateY(-15px) rotate(5deg);
          opacity: 0.6;
        }
      }


      /* 物品栏指令管理器样式 - 参考个人档案和人物历程的弹窗设计 */

      .command-manager-dot {

        display: inline-flex;

        align-items: center;

        margin-left: auto;

        cursor: pointer;

        background: #e53e3e;

        color: white;

        border-radius: 12px;

        padding: 2px 6px;

        font-size: 11px;

        font-weight: bold;

        transition: all 0.2s;

        animation: pulse 1.5s infinite;

      }



      .command-manager-dot:hover {

        background: #c53030;

        transform: scale(1.1);

      }



      .dot-icon {

        margin-right: 3px;

      }



      .dot-count {

        font-size: 10px;

      }



      @keyframes pulse {

        0%,

        100% {

          opacity: 1;

        }

        50% {

          opacity: 0.7;

        }

      }



      .command-section {

        margin-bottom: 1rem;

      }



      .command-list {

        flex-direction: column;

        gap: 0.5rem;

        max-height: 300px;

        display: flex;

        overflow-y: auto;

        margin-bottom: 1rem;

      }



      .command-item {

        background-color: #8b69141a;

        border-left: 2px solid #8b6914;

        border-radius: 0.25rem;

        padding: 0.5rem;

        display: flex;

        align-items: center;

        justify-content: space-between;

      }



      .command-content {

        display: flex;

        align-items: center;

        flex: 1;

      }



      .command-icon {

        margin-right: 0.5rem;

        font-size: 0.875rem;

      }



      .command-text {

        flex: 1;

        font-size: 0.75rem;

        color: #654321;

        font-weight: 500;

      }



      .remove-command-btn {

        background: #e53e3e;

        color: white;

        border: none;

        width: 16px;

        height: 16px;

        border-radius: 50%;

        cursor: pointer;

        font-size: 10px;

        line-height: 1;

        transition: all 0.2s;

        margin-left: 0.5rem;

      }



      .remove-command-btn:hover {

        background: #c53030;

        transform: scale(1.1);

      }



      .command-footer {

        text-align: center;

        padding-top: 0.5rem;

        margin-top: 0.5rem;

        border-top: 1px solid #8b691433;

      }



      .clear-all-btn {

        background: #e53e3e;

        color: white;

        border: none;

        border-radius: 0.375rem;

        padding: 0.5rem 1rem;

        font-size: 0.875rem;

        font-weight: 600;

        cursor: pointer;

        transition: all 0.2s;

      }



      .clear-all-btn:hover {

        background: #c53030;

        transform: translateY(-1px);

      }



      .empty-command {

        text-align: center;

        color: #8b4513;

        padding: 1rem;

        font-size: 0.75rem;

      }



      /* 存档样式 */

      .save-item {

        background: rgba(139, 105, 20, 0.1);

        border: 1px solid rgba(139, 105, 20, 0.3);

        border-radius: 0.375rem;

        padding: 0.75rem;

        margin-bottom: 0.5rem;

        cursor: pointer;

        transition: all 0.2s;

      }



      .save-item:hover {

        background: rgba(139, 105, 20, 0.2);

        border-color: rgba(139, 105, 20, 0.5);

        transform: translateY(-1px);

      }



      /* 手动存档样式 */

      .manual-save-item {

        background: rgba(59, 130, 246, 0.1);

        border: 1px solid rgba(59, 130, 246, 0.3);

      }



      .manual-save-item:hover {

        background: rgba(59, 130, 246, 0.2);

        border-color: rgba(59, 130, 246, 0.5);

      }



      /* 自动存档样式 */

      .auto-save-item {

        background: rgba(34, 197, 94, 0.1);

        border: 1px solid rgba(34, 197, 94, 0.3);

        position: relative;

      }



      .auto-save-item:hover {

        background: rgba(34, 197, 94, 0.2);

        border-color: rgba(34, 197, 94, 0.5);

      }



      /* 世界书存档样式 */

      .worldbook-save-item {

        background: rgba(168, 85, 247, 0.1);

        border: 1px solid rgba(168, 85, 247, 0.3);

      }



      .worldbook-save-item:hover {

        background: rgba(168, 85, 247, 0.2);

        border-color: rgba(168, 85, 247, 0.5);

      }



      .save-type {

        font-size: 0.75rem;

        font-weight: 600;

        margin-top: 0.25rem;

      }



      .manual-save-item .save-type {

        color: #3b82f6;

      }



      .auto-save-item .save-type {

        color: #22c55e;

      }



      .worldbook-save-item .save-type {

        color: #a855f7;

      }



      .save-name {

        font-weight: bold;

        margin-bottom: 0.25rem;

        color: #e0e0e0;

      }



      .save-content {

        font-size: 0.8rem;

        color: #c0c0c0;

        margin-bottom: 0.25rem;

        line-height: 1.3;

        max-height: 2.6rem;

        overflow: hidden;

        text-overflow: ellipsis;

        display: -webkit-box;

        -webkit-line-clamp: 2;  /* WebKit浏览器 */

        line-clamp: 2;          /* 标准属性，提高兼容性 */

        -webkit-box-orient: vertical;

      }



      .save-time {

        font-size: 0.75rem;

        color: #a0a0a0;

      }



      .empty-save {

        text-align: center;

        color: #8b4513;

        padding: 1rem;

        font-size: 0.875rem;

        font-style: italic;

      }



      /* QTE挣扎区域样式 */

      .qte-section {

        margin-top: 15px;

        padding: 15px;

        background: rgba(139, 69, 19, 0.05);

        border: 2px dashed rgba(139, 69, 19, 0.3);

        border-radius: 8px;

        animation: qtePulse 2s ease-in-out infinite;

      }



      @keyframes qtePulse {

        0%,

        100% {

          border-color: rgba(139, 69, 19, 0.3);

        }

        50% {

          border-color: rgba(139, 69, 19, 0.6);

        }

      }



      .qte-container {

        text-align: center;

      }



      .qte-info {

        margin-bottom: 15px;

      }



      .qte-description {

        font-size: 1.1em;

        font-weight: bold;

        color: #8b4513;

        margin: 0 0 5px 0;

        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);

      }



      .qte-subtitle {

        font-size: 0.9em;

        color: #654321;

        margin: 0;

        font-style: italic;

      }



      .qte-options {

        display: flex;

        gap: 10px;

        justify-content: center;

        flex-wrap: wrap;

      }



      .qte-btn {

        display: flex;

        flex-direction: column;

        align-items: center;

        padding: 12px 16px;

        border: 2px solid #8b4513;

        border-radius: 8px;

        background: rgba(244, 241, 232, 0.9);

        cursor: pointer;

        transition: all 0.3s ease;

        min-width: 100px;

        box-shadow: 0 2px 8px rgba(139, 69, 19, 0.2);

      }



      .qte-btn:hover {

        transform: translateY(-2px);

        box-shadow: 0 4px 12px rgba(139, 69, 19, 0.4);

        background: rgba(244, 241, 232, 1);

      }



      .qte-btn:active {

        transform: translateY(0);

      }



      .qte-icon {

        font-size: 1.5em;

        margin-bottom: 5px;

      }



      .qte-text {

        font-weight: bold;

        color: #8b4513;

        font-size: 0.9em;

        margin-bottom: 3px;

      }



      .qte-desc {

        font-size: 0.75em;

        color: #654321;

        opacity: 0.8;

      }



      .struggle-btn:hover {

        border-color: #dc2626;

        background: rgba(220, 38, 38, 0.1);

      }



              .submit-btn:hover {

          border-color: #059669;

          background: rgba(5, 150, 105, 0.1);

        }





    </style>



    <!-- 天赋管理模态框 -->

          <div id="talents-modal" class="rules-modal" style="display: none; justify-content: center; align-items: center;">

              <div class="rules-modal-content" style="max-width: 1200px; width: 95%; max-height: 90vh; background: linear-gradient(135deg, #2d1b1b, #1a0f0f); border: 2px solid #8b4513;">

        <div class="rules-modal-header" style="background: linear-gradient(135deg, #8b6914, #a0865a); padding: 2px 20px; border-bottom: 1px solid #654321; display: flex; justify-content: flex-end; position: relative; min-height: 30px;">

          <button id="close-talents-btn" class="close-rules-btn" style="background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.2); color: #ffffff; font-size: 14px; padding: 3px 6px; border-radius: 3px; cursor: pointer; position: absolute; top: 6px; right: 20px; transition: all 0.2s ease;">×</button>

        </div>

        <div class="rules-modal-body" style="padding: 20px 30px 30px 30px; background: linear-gradient(135deg, #fdfbf7 0%, #f5f0e8 100%); min-height: 500px; max-height: calc(90vh - 80px); overflow-y: auto;">

          <!-- 书页翻页控制 - 底部书签式设计 -->

          <div class="book-controls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; justify-content: center; align-items: center; gap: 20px; z-index: 10;">

            <button id="prev-page-btn" class="page-btn book-tab" onclick="window.teresenDebug.prevTalentPage()" style="background: linear-gradient(135deg, #8b6914, #a0865a); border: 2px solid #654321; color: #ffffff; padding: 8px 16px; border-radius: 8px 8px 0 0; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.3s; display: flex; align-items: center; gap: 6px; box-shadow: 0 -2px 8px rgba(139, 105, 20, 0.3); transform: translateY(0);">

              <span style="font-size: 14px;">◀</span>

              <span>上一页</span>

            </button>

            

            <div class="page-indicator book-tab" style="background: linear-gradient(135deg, rgba(139, 105, 20, 0.15), rgba(160, 134, 90, 0.08)); border: 2px solid rgba(139, 105, 20, 0.4); border-radius: 8px 8px 0 0; padding: 8px 16px; text-align: center; box-shadow: 0 -2px 12px rgba(139, 105, 20, 0.2); transform: translateY(0);">

              <div id="current-page-title" style="color: #8b4513; font-size: 13px; font-weight: bold; margin-bottom: 2px;">📖 第 <span id="page-number">1</span> 页</div>

              <div style="color: #666666; font-size: 10px;">共 7 页</div>

            </div>

            

            <button id="next-page-btn" class="page-btn book-tab" onclick="window.teresenDebug.nextTalentPage()" style="background: linear-gradient(135deg, #8b6914, #a0865a); border: 2px solid #654321; color: #ffffff; padding: 8px 16px; border-radius: 8px 8px 0 0; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.3s; display: flex; align-items: center; gap: 6px; box-shadow: 0 -2px 8px rgba(139, 105, 20, 0.3); transform: translateY(0);">

              <span>下一页</span>

              <span style="font-size: 14px;">▶</span>

            </button>

          </div>



          <!-- 书页内容 - 真正的书页翻页效果 -->

          <div class="book-content" style="position: relative; overflow: hidden; min-height: 600px;">

            <div id="book-pages-container" style="display: flex; transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1); height: 100%;">

              <!-- 当前天赋页面 -->

              <div class="book-page" style="min-width: 100%; flex-shrink: 0; padding: 20px;">

                <div class="book-page-content" style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(245, 240, 232, 0.9)); border: 2px solid rgba(139, 105, 20, 0.3); border-radius: 16px; padding: 30px; min-height: 500px; box-shadow: 0 8px 32px rgba(139, 105, 20, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.8); max-width: 800px; margin: 0 auto; position: relative;">

                  <!-- 书页装饰角 -->

                  <div style="position: absolute; top: 15px; right: 15px; width: 20px; height: 20px; background: linear-gradient(135deg, transparent 50%, rgba(139, 105, 20, 0.2) 50%); border-radius: 0 16px 0 0;"></div>

                  <div style="position: absolute; bottom: 15px; left: 15px; width: 20px; height: 20px; background: linear-gradient(135deg, rgba(139, 105, 20, 0.2) 50%, transparent 50%); border-radius: 0 0 0 16px;"></div>

                  

                  <h3 style="color: #8b4513; font-size: 20px; font-weight: bold; margin-bottom: 25px; text-align: center; text-shadow: 0 2px 4px rgba(139, 105, 20, 0.2); font-family: 'Georgia', serif;">🌟 当前天赋</h3>

                  <div id="current-talents-list" class="talents-list" style="min-height: 350px"></div>

                </div>

              </div>



              <!-- 萌芽页面 -->

              <div class="book-page" style="min-width: 100%; flex-shrink: 0; padding: 20px;">

                <div class="book-page-content" style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(245, 240, 232, 0.9)); border: 2px solid rgba(139, 69, 19, 0.3); border-radius: 16px; padding: 30px; min-height: 500px; box-shadow: 0 8px 32px rgba(139, 69, 19, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.8); max-width: 800px; margin: 0 auto; position: relative;">

                  <!-- 书页装饰角 -->

                  <div style="position: absolute; top: 15px; right: 15px; width: 20px; height: 20px; background: linear-gradient(135deg, transparent 50%, rgba(139, 69, 19, 0.2) 50%); border-radius: 0 16px 0 0;"></div>

                  <div style="position: absolute; bottom: 15px; left: 15px; width: 20px; height: 20px; background: linear-gradient(135deg, rgba(139, 69, 19, 0.2) 50%, transparent 50%); border-radius: 0 0 0 16px;"></div>

                  

                  <h3 style="color: #8b4513; font-size: 20px; font-weight: bold; margin-bottom: 25px; text-align: center; text-shadow: 0 2px 4px rgba(139, 69, 19, 0.2); font-family: 'Georgia', serif;">🌱 萌芽 (The Seed)</h3>

                  <div style="display: flex; gap: 20px; max-width: 800px; margin: 0 auto;">

                    <!-- 左侧：故事描述 -->

                    <div style="width: 300px; background: linear-gradient(135deg, rgba(75, 0, 0, 0.12), rgba(50, 0, 0, 0.06)); border: 2px solid rgba(75, 0, 0, 0.35); border-radius: 16px; padding: 20px; box-shadow: 0 4px 16px rgba(75, 0, 0, 0.2);">

                      <h4 style="color: #dc2626; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">📖 故事背景</h4>

                                              <p style="color: #000000; font-size: 13px; line-height: 1.6; text-align: center; font-style: italic; margin: 0; word-wrap: break-word; overflow-wrap: break-word; font-weight: 600; text-shadow: none; letter-spacing: 0.3px;">"你只是在绝境中，无意识地抓住了求生的稻草。这份力量微弱、不受控制，是你在这别样世界中发出的第一声微弱的啼哭。"</p>

                    </div>

                    <!-- 右侧：天赋选择 -->

                    <div style="flex: 1; max-width: 550px; background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 16px; padding: 20px;">

                      <h4 style="color: #8b4513; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">🎯 选择你的道路</h4>

                      <div id="seed-options" style="max-height: 250px; overflow-y: auto;"></div>

                    </div>

                  </div>

                </div>

              </div>



              <!-- 生长页面 -->

              <div class="book-page" style="min-width: 100%; flex-shrink: 0;">

                <div style="background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 12px; padding: 20px; min-height: 400px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);">

                  <h3 style="color: #8b4513; font-size: 18px; font-weight: bold; margin-bottom: 16px; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);">🌿 生长 (The Growth)</h3>

                  <div style="display: flex; gap: 20px; max-width: 800px; margin: 0 auto;">

                    <!-- 左侧：故事描述 -->

                    <div style="width: 300px; background: linear-gradient(135deg, rgba(139, 0, 0, 0.15), rgba(75, 0, 0, 0.08)); border: 2px solid rgba(139, 0, 0, 0.4); border-radius: 16px; padding: 20px; box-shadow: 0 4px 16px rgba(139, 0, 0, 0.2);">

                      <h4 style="color: #dc2626; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">📖 故事背景</h4>

                      <p style="color: #000000; font-size: 13px; line-height: 1.6; text-align: center; font-style: italic; margin: 0; word-wrap: break-word; overflow-wrap: break-word; font-weight: 600; letter-spacing: 0.3px;">"你开始理解并有意识地运用这份力量，将其作为解决问题的工具。你从被动的受害者，转变为一个能在棋盘上谨慎落子的参与者。"</p>

                    </div>

                    <!-- 右侧：天赋选择 -->

                    <div style="flex: 1; max-width: 550px; background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 16px; padding: 20px;">

                      <h4 style="color: #8b4513; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">🎯 选择你的道路</h4>

                      <div id="growth-options" style="max-height: 250px; overflow-y: auto;"></div>

                    </div>

                  </div>

                </div>

              </div>



              <!-- 畸变页面 -->

              <div class="book-page" style="min-width: 100%; flex-shrink: 0;">

                <div style="background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 12px; padding: 20px; min-height: 400px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);">

                  <h3 style="color: #8b4513; font-size: 18px; font-weight: bold; margin-bottom: 16px; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);">🌀 畸变 (The Aberration)</h3>

                  <div style="display: flex; gap: 20px; max-width: 800px; margin: 0 auto;">

                    <!-- 左侧：故事描述 -->

                    <div style="width: 300px; background: linear-gradient(135deg, rgba(75, 0, 130, 0.18), rgba(45, 0, 80, 0.10)); border: 2px solid rgba(75, 0, 130, 0.5); border-radius: 16px; padding: 20px; box-shadow: 0 4px 16px rgba(75, 0, 130, 0.25);">

                      <h4 style="color: #8b5cf6; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">📖 故事背景</h4>

                      <p style="color: #000000; font-size: 13px; line-height: 1.6; text-align: center; font-style: italic; margin: 0; word-wrap: break-word; overflow-wrap: break-word; font-weight: 600; letter-spacing: 0.3px;">"力量开始反过来影响你的心智和行为。你获得了更强大的能力，但也感受到了其背后那令人战栗的甜美与疯狂。"</p>

                    </div>

                    <!-- 右侧：天赋选择 -->

                    <div style="flex: 1; max-width: 550px; background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 16px; padding: 20px;">

                      <h4 style="color: #8b4513; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">🎯 选择你的道路</h4>

                      <div id="mutation-options" style="max-height: 250px; overflow-y: auto;"></div>

                    </div>

                  </div>

                </div>

              </div>



              <!-- 权柄页面 -->

              <div class="book-page" style="min-width: 100%; flex-shrink: 0;">

                <div style="background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 12px; padding: 20px; min-height: 400px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);">

                  <h3 style="color: #8b4513; font-size: 18px; font-weight: bold; margin-bottom: 16px; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);">👑 权柄 (The Authority)</h3>

                  <div style="display: flex; gap: 20px; max-width: 800px; margin: 0 auto;">

                    <!-- 左侧：故事描述 -->

                    <div style="width: 300px; background: linear-gradient(135deg, rgba(139, 0, 0, 0.22), rgba(100, 0, 0, 0.12)); border: 2px solid rgba(139, 0, 0, 0.6); border-radius: 16px; padding: 20px; box-shadow: 0 4px 16px rgba(139, 0, 0, 0.3);">

                      <h4 style="color: #ef4444; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">📖 故事背景</h4>

                      <p style="color: #000000; font-size: 13px; line-height: 1.6; text-align: center; font-style: italic; margin: 0; word-wrap: break-word; overflow-wrap: break-word; font-weight: 600; letter-spacing: 0.3px;">"在经历了内心的挣扎后，你做出了选择。你不再视其为诅咒，而是开始享受这份力量，并主动将其锻造成属于自己的'权柄'。"</p>

                    </div>

                    <!-- 右侧：天赋选择 -->

                    <div style="flex: 1; max-width: 550px; background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 16px; padding: 20px;">

                      <h4 style="color: #8b4513; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">🎯 选择你的道路</h4>

                      <div id="authority-options" style="max-height: 250px; overflow-y: auto;"></div>

                    </div>

                  </div>

                </div>

              </div>



              <!-- 深渊页面 -->

              <div class="book-page" style="min-width: 100%; flex-shrink: 0;">

                <div style="background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 12px; padding: 20px; min-height: 400px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);">

                  <h3 style="color: #8b4513; font-size: 18px; font-weight: bold; margin-bottom: 16px; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);">🌌 深渊 (The Abyss)</h3>

                  <div style="display: flex; gap: 20px; max-width: 800px; margin: 0 auto;">

                    <!-- 左侧：故事描述 -->

                    <div style="width: 300px; background: linear-gradient(135deg, rgba(0, 0, 0, 0.25), rgba(20, 20, 20, 0.15)); border: 2px solid rgba(0, 0, 0, 0.7); border-radius: 16px; padding: 20px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);">

                      <h4 style="color: #6b7280; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">📖 故事背景</h4>

                      <p style="color: #000000; font-size: 13px; line-height: 1.6; text-align: center; font-style: italic; margin: 0; word-wrap: break-word; overflow-wrap: break-word; font-weight: 600; letter-spacing: 0.3px;">"你走到了这条路的终点。你与所选的'不凡之爱'彻底融为一体，成为了一个新的'概念'、一个新的'规则怪谈'。"</p>

                    </div>

                    <!-- 右侧：天赋选择 -->

                    <div style="flex: 1; max-width: 550px; background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 16px; padding: 20px;">

                      <h4 style="color: #8b4513; font-size: 16px; font-weight: bold; margin-bottom: 12px; text-align: center;">🎯 选择你的道路</h4>

                      <div id="abyss-options" style="max-height: 250px; overflow-y: auto;"></div>

                    </div>

                  </div>

                </div>

              </div>



              <!-- 升级记录页面 -->

              <div class="book-page" style="min-width: 100%; flex-shrink: 0;">

                <div style="background: rgba(139, 69, 19, 0.08); border: 2px solid rgba(139, 69, 19, 0.25); border-radius: 12px; padding: 20px; min-height: 400px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);">

                  <h3 style="color: #8b4513; font-size: 18px; font-weight: bold; margin-bottom: 16px; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);">📚 升级记录</h3>

                  <div id="upgrade-history" style="min-height: 300px">

                    <div style="text-align: center; color: #666666; font-style: italic; padding: 50px;">暂无升级记录</div>

                  </div>

                </div>

              </div>

            </div>

          </div>

        </div>

      </div>

    </div>



    <!-- 暴露全局函数供MVU管理器使用 -->

    <script>

      // 暴露道具系统函数到全局

      window.savePendingActions = savePendingActions;

      window.updateActionIcons = updateActionIcons;

      window.updateInventoryCommandManager = updateInventoryCommandManager;

    </script>



    <!-- 技能系统脚本 -->

    <script>

      // 技能系统

      class SkillSystem {

        constructor() {

          this.currentSkill = null;

          this.skillData = {

            // 强化系（占有之爱）的三个技能方向
            'defense': {

              icon: '🛡️',

              name: '防御技能',

              description: '基于强化系天赋的防御能力，可以提升自身或目标的防御力。',

              majorTalent: '强化系（占有之爱）'

            },

            'rule_enhance': {
              icon: '📜',

              name: '规则洞察',
              description: '基于强化系天赋的规则洞察能力，可以看穿规则漏洞并加以利用。',
              majorTalent: '强化系（占有之爱）'
            },
            'chain_enhance': {
              icon: '🔗',

              name: '锁链控制',
              description: '基于强化系天赋的锁链控制能力，可以束缚或锁定目标。',
              majorTalent: '强化系（占有之爱）'
            },
            
            // 变化系（谎言之爱）的三个技能方向
            'rule_change': {
              icon: '📝',
              name: '规则修改',
              description: '基于变化系天赋的规则修改能力，可以临时改变规则内容。',
              majorTalent: '变化系（谎言之爱）'
            },
            'emotion': {
              icon: '💭',
              name: '情感操控',
              description: '基于变化系天赋的情感操控能力，可以将谎言具象化为情感武器。',
              majorTalent: '变化系（谎言之爱）'
            },
            'shadow': {
              icon: '👤',
              name: '影子操控',
              description: '基于变化系天赋的影子操控能力，可以创造和控制虚假影子。',
              majorTalent: '变化系（谎言之爱）'
            },
            
            // 放出系（牺牲之爱）的三个技能方向
            'emotion_release': {
              icon: '💔',
              name: '情绪释放',
              description: '基于放出系天赋的情绪释放能力，可以牺牲情感影响敌人。',
              majorTalent: '放出系（牺牲之爱）'
            },
            'sacrifice': {
              icon: '⚰️',
              name: '生命献祭',
              description: '基于放出系天赋的献祭能力，可以牺牲生命或记忆获得力量。',
              majorTalent: '放出系（牺牲之爱）'
            },
            'phantom': {
              icon: '👻',
              name: '分身具现',
              description: '基于放出系天赋的分身能力，可以具现化幻影分身。',
              majorTalent: '放出系（牺牲之爱）'
            },
            
            // 操作系（控制之爱）的三个技能方向
            'suggestion': {
              icon: '🧠',
              name: '心理暗示',
              description: '基于操作系天赋的心理暗示能力，可以植入思想控制目标。',
              majorTalent: '操作系（控制之爱）'

            },
            'control': {
              icon: '🎮',
              name: '精神操控',
              description: '基于操作系天赋的精神操控能力，可以直接控制敌人行动。',
              majorTalent: '操作系（控制之爱）'
            },
            'absorption': {
              icon: '💕',
              name: '爱意吸收',
              description: '基于操作系天赋的吸收能力，可以吸收他人的爱意获得力量。',
              majorTalent: '操作系（控制之爱）'
            },
            
            // 具现化系（理想之爱）的三个技能方向
            'armor': {
              icon: '🛡️',
              name: '理想盔甲',
              description: '基于具现化系天赋的盔甲能力，可以具现化完美的防护装备。',
              majorTalent: '具现化系（理想之爱）'
            },
            'ring': {
              icon: '💍',
              name: '承诺戒指',
              description: '基于具现化系天赋的戒指能力，可以具现化拥有强大力量的戒指。',
              majorTalent: '具现化系（理想之爱）'
            },
            'npc': {
              icon: '🤖',
              name: '完美NPC',
              description: '基于具现化系天赋的NPC能力，可以具现化完美的助手。',
              majorTalent: '具现化系（理想之爱）'
            },
            
            // 特质系（扭曲之爱）的三个技能方向
            'contract': {
              icon: '📋',
              name: '怪谈契约',
              description: '基于特质系天赋的契约能力，可以与规则怪谈签订契约。',
              majorTalent: '特质系（扭曲之爱）'
            },
            'resonance': {
              icon: '🎵',
              name: '情绪共鸣',
              description: '基于特质系天赋的共鸣能力，可以与目标进行情绪共鸣。',
              majorTalent: '特质系（扭曲之爱）'
            },
            'chaos': {
              icon: '🌀',
              name: '混沌混合',
              description: '基于特质系天赋的混合能力，可以混合不同爱意创造新技能。',
              majorTalent: '特质系（扭曲之爱）'
            }

          };

          

          this.init();

        }



        init() {

          this.bindEvents();

          this.checkSkillUnlock();

        }



        bindEvents() {

          // 技能按钮点击事件 - 动态绑定
          $(document).on('click', '.skill-btn', (e) => {
            const skillType = $(e.currentTarget).data('skill-type');
            if (skillType) {
              this.showSkillPopup(skillType, e);
            }
          });


          // 点击其他地方关闭技能弹窗

          $(document).on('click', (e) => {

            if (!$(e.target).closest('.skill-detail-popup').length && !$(e.target).closest('.skill-btn').length) {

              this.hideSkillPopup();

            }

          });

        }



        checkSkillUnlock() {

          // 检查是否解锁了萌芽层天赋

          try {

            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {

              const mvuData = Mvu.getMvuData({ type: 'chat' });

              const seedTalent = Mvu.getMvuVariable(mvuData, '训练员.天赋.小天赋.萌芽[0]', { default_value: null });

              

              if (seedTalent && seedTalent !== '') {

                // 解锁技能按钮

                $('#skills-section').show();

                this.updateSkillButtons();
                console.log('🎯 技能系统已解锁');

              } else {

                $('#skills-section').hide();

              }

            }

          } catch (error) {

            console.error('检查技能解锁状态失败:', error);

            $('#skills-section').hide();

          }

        }


        updateSkillButtons() {
          // 获取当前大天赋
          let majorTalent = '强化系（占有之爱）';
          try {
            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              majorTalent = Mvu.getMvuVariable(mvuData, '训练员.天赋.大天赋.name[0]', { default_value: '强化系（占有之爱）' });
            }
          } catch (error) {
            console.warn('获取大天赋失败，使用默认值:', error);
          }

          // 根据大天赋获取对应的3个技能
          const skills = this.getSkillsByMajorTalent(majorTalent);
          
          // 更新技能按钮
          const container = $('#skills-section');
          container.empty();
          
          if (skills.length === 0) {
            // 没有技能时显示提示
            container.html('<div class="no-skills-message">潜能未觉醒，暂无技能</div>');
          } else {
            skills.forEach(skill => {
              const button = $(`
                <button class="skill-btn" data-skill-type="${skill.type}" title="${skill.name}">
                  <span class="skill-icon">${skill.icon}</span>
                </button>
              `);
              container.append(button);
            });
          }
        }

        getSkillsByMajorTalent(majorTalent) {
          const skillMapping = {
            '强化系（占有之爱）': [
              { type: 'defense', icon: '🛡️', name: '防御技能' },
              { type: 'rule_enhance', icon: '📜', name: '规则洞察' },
              { type: 'chain_enhance', icon: '🔗', name: '锁链控制' }
            ],
            '变化系（谎言之爱）': [
              { type: 'rule_change', icon: '📝', name: '规则修改' },
              { type: 'emotion', icon: '💭', name: '情感操控' },
              { type: 'shadow', icon: '👤', name: '影子操控' }
            ],
            '放出系（牺牲之爱）': [
              { type: 'emotion_release', icon: '💔', name: '情绪释放' },
              { type: 'sacrifice', icon: '⚰️', name: '生命献祭' },
              { type: 'phantom', icon: '👻', name: '分身具现' }
            ],
            '操作系（控制之爱）': [
              { type: 'suggestion', icon: '🧠', name: '心理暗示' },
              { type: 'control', icon: '🎮', name: '精神操控' },
              { type: 'absorption', icon: '💕', name: '爱意吸收' }
            ],
            '具现化系（理想之爱）': [
              { type: 'armor', icon: '🛡️', name: '理想盔甲' },
              { type: 'ring', icon: '💍', name: '承诺戒指' },
              { type: 'npc', icon: '🤖', name: '完美NPC' }
            ],
            '特质系（扭曲之爱）': [
              { type: 'contract', icon: '📋', name: '怪谈契约' },
              { type: 'resonance', icon: '🎵', name: '情绪共鸣' },
              { type: 'chaos', icon: '🌀', name: '混沌混合' }
            ]
          };
          
          return skillMapping[majorTalent] || skillMapping['强化系（占有之爱）'];
        }


        showSkillPopup(skillType, event) {

          const skill = this.skillData[skillType];

          if (!skill) return;



          this.currentSkill = skillType;



          // 移除现有的技能弹窗

          $('.skill-detail-popup').remove();



          // 创建技能弹窗

          const popup = $(`

            <div class="skill-detail-popup">

              <div class="skill-header">
                <span class="skill-icon">${skill.icon}</span>
                <span class="skill-title">${skill.name}</span>
              </div>
              <div class="skill-desc">${skill.description}</div>

              <div>

                <button class="skill-use-btn" data-target="self">👤 对自己使用</button>

                <button class="skill-use-btn" data-target="uma">🐎 对马娘使用</button>

              </div>

            </div>

          `);



          // 绑定按钮事件

          popup.find('.skill-use-btn').on('click', (e) => {

            const target = $(e.target).data('target');

            this.useSkill(target);

          });



          // 定位弹窗

          const button = $(event.target).closest('.skill-btn');

          const buttonOffset = button.offset();

          popup.css({

            position: 'absolute',

            top: buttonOffset.top - popup.outerHeight() - 10,

            left: buttonOffset.left

          });



          // 添加到页面

          $('body').append(popup);

          

          // 播放音效

          const skillSound = document.getElementById('item-detail-sound');

          if (skillSound) {

            skillSound.currentTime = 0;

            skillSound.play().catch(e => console.log('音效播放失败:', e));

          }

        }



        hideSkillPopup() {

          $('.skill-detail-popup').remove();

          this.currentSkill = null;

        }



        useSkill(target) {

          if (!this.currentSkill) return;



          const skill = this.skillData[this.currentSkill];



          if (target === 'self') {

            const actionText = `[使用技能: ${skill.name}]`;

            

            // 添加到指令队列

            addPendingAction('skill', skill.name, {

              skillType: this.currentSkill,

              target: target,

              majorTalent: skill.majorTalent

            });



            // 关闭弹窗

            this.hideSkillPopup();



            // 显示提示

            this.showTemporaryMessage(`已将 ${actionText} 加入指令队列`);

          } else if (target === 'uma') {

            // 关闭弹窗

            this.hideSkillPopup();

            

            // 开始技能选择模式

            startSkillSelection(skill.name, this.currentSkill);

          }

        }



        showTemporaryMessage(message) {

          const messageDiv = $('<div class="temporary-message">')

            .text(message)

            .css({

              position: 'fixed',

              top: '50%',

              left: '50%',

              transform: 'translate(-50%, -50%)',

              background: 'rgba(0, 0, 0, 0.8)',

              color: 'white',

              padding: '10px 20px',

              borderRadius: '8px',

              fontSize: '14px',

              zIndex: 1000,

              animation: 'fadeInOut 2s ease-in-out'

            });



          $('body').append(messageDiv);



          setTimeout(() => {

            messageDiv.remove();

          }, 2000);

        }

      }



      // 初始化技能系统

      $(document).ready(function() {

        window.skillSystem = new SkillSystem();

        
        // 监听天赋变化，更新技能按钮
        if (window.teresenDebug && window.teresenDebug.updateInterface) {
          const originalUpdateInterface = window.teresenDebug.updateInterface;
          window.teresenDebug.updateInterface = function() {
            originalUpdateInterface.call(this);
            if (window.skillSystem) {
              window.skillSystem.checkSkillUnlock();
            }
          };
                }

        // 简单直接的音乐播放功能
        function setupMusicControls() {
          console.log('🎵 初始化音乐控制');
          
          // 直接用jQuery绑定点击事件
          $('#music-controller').on('click', function() {
            console.log('🎵 音乐按钮被点击');
            
            const audio1 = document.getElementById('bgm-track1');
            const audio2 = document.getElementById('bgm-track2');
            
            // 设置音量
            if (audio1) audio1.volume = 0.3;
            if (audio2) audio2.volume = 0.3;
            
            // 检查当前状态并切换
            if (audio1 && audio1.paused && audio2 && audio2.paused) {
              // 都没播放，播放第一首
              audio1.play().then(() => {
                console.log('🎵 开始播放音乐1');
                $(this).text('🎵 播放中1');
              }).catch(e => console.log('播放失败:', e));
            } else if (audio1 && !audio1.paused) {
              // 第一首在播放，切换到第二首
              audio1.pause();
              audio1.currentTime = 0;
              audio2.play().then(() => {
                console.log('🎵 开始播放音乐2');
                $(this).text('🎵 播放中2');
              }).catch(e => console.log('播放失败:', e));
            } else if (audio2 && !audio2.paused) {
              // 第二首在播放，停止所有
              audio2.pause();
              audio2.currentTime = 0;
              console.log('🎵 停止播放');
              $(this).text('🎵 音乐控制');
            }
          });
        }

        // 调用音乐控制初始化
        setupMusicControls();
      });
      
      // 塔罗占卜系统
      class TarotDivinationSystem {
        constructor() {
          console.log('🎴 塔罗占卜系统构造函数开始');
          this.tarotCards = [
            { name: "愚者", meaning: "新的开始，冒险精神", reversed: "鲁莽，不负责任" },
            { name: "魔术师", meaning: "创造力，技能掌握", reversed: "技能不足，机会浪费" },
            { name: "女祭司", meaning: "直觉，神秘知识", reversed: "隐藏的真相，表面现象" },
            { name: "女皇", meaning: "丰收，母性，创造力", reversed: "依赖，过度保护" },
            { name: "皇帝", meaning: "权威，领导力，稳定", reversed: "专制，缺乏灵活性" },
            { name: "教皇", meaning: "传统，精神指导", reversed: "教条，限制" },
            { name: "恋人", meaning: "爱情，选择，和谐", reversed: "不和谐，错误选择" },
            { name: "战车", meaning: "胜利，意志力，控制", reversed: "失控，失败" },
            { name: "力量", meaning: "内在力量，勇气", reversed: "软弱，缺乏信心" },
            { name: "隐者", meaning: "智慧，内省，指导", reversed: "孤独，拒绝帮助" },
            { name: "命运之轮", meaning: "变化，命运转折", reversed: "坏运气，停滞" },
            { name: "正义", meaning: "公平，真理，平衡", reversed: "不公，偏见" },
            { name: "倒吊人", meaning: "牺牲，新视角", reversed: "无意义的牺牲" },
            { name: "死神", meaning: "结束，转变，重生", reversed: "停滞，拒绝改变" },
            { name: "节制", meaning: "平衡，适度，和谐", reversed: "过度，不平衡" },
            { name: "恶魔", meaning: "束缚，物质欲望", reversed: "摆脱束缚，觉醒" },
            { name: "塔", meaning: "突然变化，启示", reversed: "避免灾难，重建" },
            { name: "星星", meaning: "希望，灵感，信心", reversed: "失望，缺乏信心" },
            { name: "月亮", meaning: "直觉，幻想，恐惧", reversed: "释放恐惧，真相" },
            { name: "太阳", meaning: "成功，快乐，活力", reversed: "暂时的困难" },
            { name: "审判", meaning: "重生，内在召唤", reversed: "自我怀疑，拒绝改变" },
            { name: "世界", meaning: "完成，和谐，成功", reversed: "未完成，延迟" }
          ];

          this.tarotItems = {
            "赫尔墨斯羽毛": {
              "描述": "信使神赫尔墨斯翅膀上的一片羽毛，能带来好运",
              "效果": "运气+8，解锁1个隐藏对话",
              "稀有度": "稀有",
              "特性": "信使之翼"
            },
            "智慧之泉": {
              "描述": "来自北欧神话智慧之泉的一滴水珠",
              "效果": "理智+10，获得1个特殊知识",
              "稀有度": "稀有",
              "特性": "智慧启迪"
            },
            "净化之镜": {
              "描述": "能驱散负面能量的神秘镜子",
              "效果": "净化1个负面状态，运气+5",
              "稀有度": "稀有",
              "特性": "净化之光"
            },
            "命运硬币": {
              "描述": "能改变一次随机事件结果的神秘硬币",
              "效果": "下次随机事件结果+20%",
              "稀有度": "稀有",
              "特性": "命运翻转"
            },
            "灵魂碎片": {
              "描述": "来自神秘灵魂的微小碎片",
              "效果": "随机马娘好感度+8，理智+3",
              "稀有度": "稀有",
              "特性": "灵魂共鸣"
            },
            "时间沙粒": {
              "描述": "来自时间长河的一粒沙",
              "效果": "在校天数+1，体力+10",
              "稀有度": "稀有",
              "特性": "时间操控"
            }
          };

          this.bindEvents();
          console.log('🎴 塔罗占卜系统构造函数完成');
        }

        bindEvents() {
          console.log('🎴 绑定塔罗占卜事件');
          
          // 绑定塔罗占卜按钮点击事件
          $(document).on('click', '#tarot-divination', (e) => {
            console.log('🎴 塔罗占卜按钮被点击');
            // 播放塔罗声音
            const sound = document.getElementById('tarot-shuffle');
            if (sound) {
              sound.currentTime = 0;
              sound.play().catch(e => console.log('塔罗音效播放失败:', e));
            }
            e.preventDefault();
            e.stopPropagation();
            this.openTarotModal();
          });

          // 绑定模态框关闭事件
          $(document).on('click', '#close-tarot-btn', (e) => {
            console.log('🎴 关闭塔罗占卜模态框');
            e.preventDefault();
            e.stopPropagation();
            this.closeTarotModal();
          });

          // 绑定占卜按钮事件
          $(document).on('click', '.spread-btn:not(.disabled)', (e) => {
            console.log('🎴 占卜按钮被点击');
            e.preventDefault();
            e.stopPropagation();
            const spreadType = $(e.currentTarget).data('spread');
            const cost = $(e.currentTarget).data('cost');
            this.performDivination(spreadType, cost);
          });
          
          console.log('🎴 塔罗占卜事件绑定完成');
        }

        openTarotModal() {
          console.log('🎴 打开塔罗占卜模态框');
          this.updateTarotInfo();
          this.updateSpreadButtons();
          $('#tarot-modal').show();
          console.log('🎴 塔罗占卜模态框已显示');
        }

        closeTarotModal() {
          $('#tarot-modal').hide();
          $('#tarot-result').hide();
        }

        updateTarotInfo() {
          console.log('🎴 更新塔罗占卜信息');
          
          // 参考天赋系统的实现方式
          let sanity = 100;
          let gameDay = 1;
          try {
            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              sanity = Mvu.getMvuVariable(mvuData, '训练员.理智[0]', { default_value: 100 });
              gameDay = Mvu.getMvuVariable(mvuData, '训练员.在校天数[0]', { default_value: 1 });
              console.log('🎴 MVU理智值获取成功:', sanity);
              console.log('🎴 游戏天数获取成功:', gameDay);
            }
          } catch (error) {
            console.warn('🎴 获取理智值失败，使用默认值:', error);
          }
          
          const remaining = this.getDailyRemaining();
          console.log('🎴 理智:', sanity, '游戏天数:', gameDay, '剩余次数:', remaining);
          
          // 显示理智值
          $('#tarot-sanity').text(sanity);
          
          // 显示游戏天数和剩余次数
          const remainingText = `游戏第${gameDay}天 - 剩余次数: ${remaining}`;
          $('#tarot-remaining').text(remainingText);
          
          // 如果次数用完，添加提示
          if (remaining === 0) {
            $('#tarot-remaining').append('<br><small style="color: #ef4444; font-size: 0.8rem;">需要等到游戏内下一天才能继续使用</small>');
          }
        }

        updateSpreadButtons() {
          console.log('🎴 更新占卜按钮状态');
          
          // 参考天赋系统的实现方式
          // 使用和个人档案相同的变量获取方式
          let sanity = 100;
          let schoolDays = 0;
          try {
            const allVars = this.getAllVariables();
            sanity = this.getVariable(allVars, 'stat_data.训练员.理智[0]', 100);
            schoolDays = this.getVariable(allVars, 'stat_data.训练员.在校天数[0]', 1);
            console.log('🎴 使用getAllVariables获取变量成功:', { sanity, schoolDays });
          } catch (error) {
            console.warn('🎴 获取变量失败，使用默认值:', error);
          }
          
          console.log('🎴 理智:', sanity, '在校天数:', schoolDays);
          console.log('🎴 getGameDay()返回:', this.getGameDay());

          $('.spread-btn').each((index, button) => {
            const $btn = $(button);
            const cost = $btn.data('cost');
            const requirement = $btn.data('requirement');

            let disabled = false;
            let reason = '';

            if (sanity < cost) {
              disabled = true;
              reason = '理智不足';
            } else if (requirement && schoolDays < requirement) {
              disabled = true;
              reason = '在校天数不足';
            }

            if (disabled) {
              $btn.addClass('disabled');
              $btn.attr('title', reason);
            } else {
              $btn.removeClass('disabled');
              $btn.attr('title', '');
            }
          });
          console.log('🎴 占卜按钮状态更新完成');
        }

        async performDivination(spreadType, cost) {
          console.log('🎴 开始占卜:', spreadType, '消耗:', cost);
          
          // 检查每日剩余次数（基于游戏天数）
          const dailyRemaining = this.getDailyRemaining();
          if (dailyRemaining <= 0) {
            const gameDay = this.getGameDay();
            alert(`游戏第${gameDay}天的占卜次数已用完，需要等到游戏内下一天才能继续使用！`);
            return;
          }
          
          // 参考天赋系统的实现方式获取理智值
          let currentSanity = 100;
          try {
            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              currentSanity = Mvu.getMvuVariable(mvuData, '训练员.理智[0]', { default_value: 100 });
              console.log('🎴 当前理智值:', currentSanity);
            }
          } catch (error) {
            console.warn('🎴 获取理智值失败:', error);
          }
          
          // 检查理智是否足够
          if (currentSanity < cost) {
            alert('理智不足，无法进行占卜！');
            return;
          }

          // 消耗理智 - 参考天赋系统的实现方式
          const newSanity = currentSanity - cost;
          try {
            if (typeof Mvu !== 'undefined' && Mvu.setMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              await Mvu.setMvuVariable(mvuData, '训练员.理智[0]', newSanity, {
                reason: '塔罗占卜消耗',
                is_recursive: true,
              });
              await Mvu.replaceMvuData(mvuData, { type: 'chat' });
              console.log('🎴 理智值扣除成功:', currentSanity, '->', newSanity);
            }
          } catch (error) {
            console.error('🎴 扣除理智值失败:', error);
            alert('扣除理智值失败！');
            return;
          }

          // 显示占卜开始动画
          this.showDivinationStartAnimation(spreadType);
          
          // 延迟生成结果，增加神秘感
          setTimeout(async () => {
            // 生成占卜结果
            const result = await this.generateDivinationResult(spreadType);
            
            // 隐藏开始动画
            $('.tarot-start-animation').fadeOut(500, () => {
              $('.tarot-start-animation').remove();
            });
            
            // 显示结果
            this.showTarotResultPopup(result);
          }, 2000);
          
          // 更新界面
          this.updateTarotInfo();
          this.updateSpreadButtons();
          
          // 记录使用次数
          this.recordDailyUsage();
        }

        async generateDivinationResult(spreadType) {
          const cards = [];
          const cardCount = this.getCardCount(spreadType);
          
          for (let i = 0; i < cardCount; i++) {
            const card = this.getRandomCard();
            cards.push(card);
          }

          const result = await this.interpretCards(cards, spreadType);
          return { cards, result };
        }

        getCardCount(spreadType) {
          const counts = {
            'single': 1,
            'timeline': 3,
            'choice': 2,
            'hexagram': 6,
            'celtic': 10,
            'zodiac': 12
          };
          return counts[spreadType] || 1;
        }

        getRandomCard() {
          const card = this.tarotCards[Math.floor(Math.random() * this.tarotCards.length)];
          const isReversed = Math.random() < 0.3; // 30%概率逆位
          return {
            ...card,
            reversed: isReversed,
            meaning: isReversed ? card.reversed : card.meaning
          };
        }

        async interpretCards(cards, spreadType) {
          const result = {
            type: this.determineResultType(cards),
            luckChange: 0,
            reasonChange: 0,
            canGetItem: false,
            affectionChange: 0,
            interpretation: '',
            effects: []
          };

          // 根据卡牌和牌阵类型生成结果
          switch (spreadType) {
            case 'single':
              result.luckChange = this.calculateLuckChange(cards);
              result.reasonChange = this.calculateReasonChange(cards);
              result.canGetItem = Math.random() < 0.15;
              result.affectionChange = this.calculateAffectionChange(cards);
              break;
            case 'timeline':
              result.luckChange = this.calculateLuckChange(cards) * 1.5;
              result.reasonChange = this.calculateReasonChange(cards) * 1.5;
              result.canGetItem = Math.random() < 0.20;
              result.affectionChange = this.calculateAffectionChange(cards) * 1.5;
              break;
            case 'choice':
              result.luckChange = this.calculateLuckChange(cards) * 0.8;
              result.reasonChange = this.calculateReasonChange(cards) * 0.8;
              result.canGetItem = Math.random() < 0.12;
              result.affectionChange = this.calculateAffectionChange(cards) * 0.8;
              break;
            default:
              result.luckChange = this.calculateLuckChange(cards) * 2;
              result.reasonChange = this.calculateReasonChange(cards) * 2;
              result.canGetItem = Math.random() < 0.25;
              result.affectionChange = this.calculateAffectionChange(cards) * 2;
          }

          // 生成解释文本
          result.interpretation = this.generateInterpretation(cards, spreadType);
          
          // 应用效果
          await this.applyDivinationEffects(result);

          return result;
        }

        determineResultType(cards) {
          const positiveCards = cards.filter(card => !card.reversed).length;
          const totalCards = cards.length;
          const positiveRatio = positiveCards / totalCards;

          if (positiveRatio >= 0.8) return '神迹显现';
          if (positiveRatio >= 0.6) return '智慧启迪';
          if (positiveRatio >= 0.4) return '命运波动';
          if (positiveRatio >= 0.2) return '迷雾笼罩';
          if (positiveRatio >= 0.1) return '混沌回响';
          return '深渊低语';
        }

        calculateLuckChange(cards) {
          let change = 0;
          cards.forEach(card => {
            if (card.reversed) {
              change -= 3 + Math.random() * 5;
            } else {
              change += 3 + Math.random() * 5;
            }
          });
          return Math.round(change / cards.length);
        }

        calculateReasonChange(cards) {
          let change = 0;
          cards.forEach(card => {
            if (card.reversed) {
              change -= 2 + Math.random() * 3;
            } else {
              change += 2 + Math.random() * 3;
            }
          });
          return Math.round(change / cards.length);
        }

        calculateAffectionChange(cards) {
          let change = 0;
          cards.forEach(card => {
            if (card.reversed) {
              change -= 2 + Math.random() * 3;
            } else {
              change += 2 + Math.random() * 3;
            }
          });
          return Math.round(change / cards.length);
        }

        generateInterpretation(cards, spreadType) {
          const spreadNames = {
            'single': '单张牌占卜',
            'timeline': '时间之流占卜',
            'choice': '二选一占卜',
            'hexagram': '六芒星占卜',
            'celtic': '凯尔特十字占卜',
            'zodiac': '黄道十二宫占卜'
          };

          const spreadDescriptions = {
            'single': '在神秘的月光下，你抽出了命运之牌。这张牌如同夜空中的北极星，为你指明前进的方向...',
            'timeline': '时间的长河在你面前展开，过去、现在与未来交织成命运的织锦。每一张牌都承载着时光的重量...',
            'choice': '命运在你面前摆出了两条道路，如同十字路口的选择。每一条路都通向不同的未来...',
            'hexagram': '六芒星的古老符号在虚空中闪烁，六张牌如同星辰般排列，揭示着深层的命运密码...',
            'celtic': '凯尔特十字的古老智慧在你面前展开，十张牌如同生命之树的枝叶，展现着内心的深层结构...',
            'zodiac': '黄道十二宫的星象在你周围旋转，十二张牌如同宇宙的和谐乐章，映射着天地的平衡...'
          };

          let interpretation = spreadDescriptions[spreadType] || '在神秘的占卜仪式中，命运的奥秘在你面前缓缓展开...';
          
          interpretation += '\n\n';
          
          cards.forEach((card, index) => {
            const cardNumber = index + 1;
            const positionText = card.reversed ? '逆位' : '正位';
            const positionDesc = card.reversed ? '这张牌以逆位出现，暗示着挑战与警示' : '这张牌以正位出现，带来祝福与指引';
            
            interpretation += `第${cardNumber}张牌：${card.name}（${positionText}）\n`;
            interpretation += `${positionDesc}。${card.meaning}\n\n`;
          });

          // 添加总结性的话语
          const positiveCards = cards.filter(card => !card.reversed).length;
          const totalCards = cards.length;
          const positiveRatio = positiveCards / totalCards;

          if (positiveRatio >= 0.8) {
            interpretation += '🌟 命运之镜显示，你的未来充满光明与希望。勇敢地向前迈进吧！';
          } else if (positiveRatio >= 0.6) {
            interpretation += '✨ 虽然前路有些波折，但智慧与勇气将指引你走向成功。';
          } else if (positiveRatio >= 0.4) {
            interpretation += '🌙 命运之轮正在转动，保持耐心与坚持，转机即将到来。';
          } else if (positiveRatio >= 0.2) {
            interpretation += '⚡ 挑战与机遇并存，谨慎行事，智慧将助你度过难关。';
          } else {
            interpretation += '🔮 黑暗中的星光最为珍贵，保持希望，命运终将眷顾勇敢者。';
          }

          return interpretation;
        }

        async applyDivinationEffects(result) {
          console.log('🎴 应用占卜效果');
          
          // 参考天赋系统的实现方式
          try {
            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable && Mvu.setMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              
              // 应用运气变化
              const currentLuck = Mvu.getMvuVariable(mvuData, '训练员.运气[0]', { default_value: 50 });
              const newLuck = Math.max(0, Math.min(100, currentLuck + result.luckChange));
              await Mvu.setMvuVariable(mvuData, '训练员.运气[0]', newLuck, {
                reason: '塔罗占卜效果',
                is_recursive: true,
              });
              result.effects.push(`运气${result.luckChange > 0 ? '+' : ''}${result.luckChange}`);

              // 应用理智变化
              const currentReason = Mvu.getMvuVariable(mvuData, '训练员.理智[0]', { default_value: 100 });
              const newReason = Math.max(0, Math.min(100, currentReason + result.reasonChange));
              await Mvu.setMvuVariable(mvuData, '训练员.理智[0]', newReason, {
                reason: '塔罗占卜效果',
                is_recursive: true,
              });
              result.effects.push(`理智${result.reasonChange > 0 ? '+' : ''}${result.reasonChange}`);
              
              // 保存更新后的数据
              await Mvu.replaceMvuData(mvuData, { type: 'chat' });
              console.log('🎴 占卜效果应用成功');
            }
          } catch (error) {
            console.error('🎴 应用占卜效果失败:', error);
          }

          // 处理物品获取
          if (result.canGetItem) {
            const itemCheck = this.canGetTarotItem();
            if (itemCheck.canGet) {
              const item = this.getRandomTarotItem();
              if (item) {
                await this.addTarotItem(item, this.tarotItems[item]);
                result.effects.push(`获得神秘物品：${item}`);
                this.recordItemAcquisition();
              }
            }
          }

          // 处理马娘好感度
          if (result.affectionChange !== 0) {
            const affectionResult = await this.affectRandomHorseGirlAffection(result.affectionChange);
            if (affectionResult) {
              result.effects.push(`${affectionResult.name}好感度${result.affectionChange > 0 ? '+' : ''}${result.affectionChange}`);
            }
          }
        }

        showTarotResultPopup(result) {
          console.log('🎴 显示占卜结果:', result);
          
          // 调试：检查result结构
          if (!result || !result.cards || !result.result) {
            console.error('🎴 result数据结构错误:', result);
            alert('占卜数据生成失败！result=' + JSON.stringify(result));
            return;
          }
          
          // 移除现有的结果弹窗
          $('.tarot-result-modal').remove();
          
          // 创建神秘优美的占卜结果弹窗
          const resultModal = $(`
            <div class="tarot-result-modal" style="
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.8);
              display: flex;
              justify-content: center;
              align-items: center;
              z-index: 10000;
              backdrop-filter: blur(5px);
            ">
              <div class="tarot-result-content" style="
                background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
                border: 2px solid #a855f7;
                border-radius: 20px;
                padding: 30px;
                max-width: 800px;
                max-height: 90vh;
                overflow-y: auto;
                position: relative;
                box-shadow: 0 0 50px rgba(168, 85, 247, 0.5);
                animation: tarotResultFadeIn 0.8s ease-out;
              ">
                <!-- 关闭按钮 -->
                <button class="tarot-result-close" style="
                  position: absolute;
                  top: 15px;
                  right: 20px;
                  background: none;
                  border: none;
                  color: #a855f7;
                  font-size: 24px;
                  cursor: pointer;
                  z-index: 10001;
                ">×</button>
                
                <!-- 神秘标题 -->
                <div class="tarot-result-header" style="
                  text-align: center;
                  margin-bottom: 25px;
                  padding-bottom: 20px;
                  border-bottom: 2px solid rgba(168, 85, 247, 0.3);
                ">
                  <h2 style="
                    color: #a855f7;
                    font-size: 28px;
                    margin: 0;
                    text-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
                    font-family: 'Times New Roman', serif;
                  ">🔮 命运之镜 🔮</h2>
                  <p style="
                    color: #cbd5e1;
                    font-size: 16px;
                    margin: 10px 0 0 0;
                    font-style: italic;
                  ">${result.result.type}</p>
                </div>
                
                <!-- 卡牌展示区域 -->
                <div class="tarot-cards-display" style="
                  display: grid;
                  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                  gap: 15px;
                  margin-bottom: 25px;
                ">
                  ${result.cards.map((card, index) => `
                    <div class="tarot-result-card ${card.reversed ? 'reversed' : ''}" style="
                      background: linear-gradient(135deg, #2d1b69, #4c1d95);
                      border: 2px solid ${card.reversed ? '#ef4444' : '#a855f7'};
                      border-radius: 12px;
                      padding: 15px;
                      text-align: center;
                      position: relative;
                      transform: ${card.reversed ? 'rotate(180deg)' : 'none'};
                      transition: all 0.3s ease;
                      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
                    ">
                      <div class="card-number" style="
                        position: absolute;
                        top: 5px;
                        left: 10px;
                        color: #a855f7;
                        font-size: 12px;
                        font-weight: bold;
                      ">${index + 1}</div>
                      <div class="card-name" style="
                        color: #f3f4f6;
                        font-size: 14px;
                        font-weight: bold;
                        margin-bottom: 8px;
                        text-shadow: 0 0 5px rgba(168, 85, 247, 0.5);
                      ">${card.name}</div>
                      <div class="card-meaning" style="
                        color: #cbd5e1;
                        font-size: 12px;
                        line-height: 1.4;
                        font-style: italic;
                      ">${card.meaning}</div>
                      ${card.reversed ? '<div style="position: absolute; top: 5px; right: 10px; color: #ef4444; font-size: 12px;">逆位</div>' : ''}
                    </div>
                  `).join('')}
                </div>
                
                <!-- 神秘解读 -->
                <div class="tarot-interpretation-section" style="
                  background: rgba(168, 85, 247, 0.1);
                  border: 1px solid rgba(168, 85, 247, 0.3);
                  border-radius: 12px;
                  padding: 20px;
                  margin-bottom: 25px;
                ">
                  <h3 style="
                    color: #a855f7;
                    font-size: 20px;
                    margin: 0 0 15px 0;
                    text-align: center;
                    font-family: 'Times New Roman', serif;
                  ">🌟 神秘解读 🌟</h3>
                  <div class="interpretation-text" style="
                    color: #e2e8f0;
                    font-size: 14px;
                    line-height: 1.6;
                    text-align: justify;
                    font-family: 'Georgia', serif;
                  ">${result.result.interpretation}</div>
                </div>
                
                <!-- 命运影响 -->
                <div class="tarot-effects-section" style="
                  background: rgba(34, 197, 94, 0.1);
                  border: 1px solid rgba(34, 197, 94, 0.3);
                  border-radius: 12px;
                  padding: 20px;
                ">
                  <h3 style="
                    color: #22c55e;
                    font-size: 20px;
                    margin: 0 0 15px 0;
                    text-align: center;
                    font-family: 'Times New Roman', serif;
                  ">✨ 命运影响 ✨</h3>
                  <div class="effects-list" style="
                    display: grid;
                    gap: 8px;
                  ">
                    ${result.result.effects.map(effect => `
                      <div class="effect-item" style="
                        background: rgba(34, 197, 94, 0.1);
                        border: 1px solid rgba(34, 197, 94, 0.2);
                        border-radius: 8px;
                        padding: 10px;
                        color: #22c55e;
                        font-size: 14px;
                        text-align: center;
                        font-weight: 500;
                      ">${effect}</div>
                    `).join('')}
                  </div>
                </div>
                
                <!-- 神秘装饰 -->
                <div style="
                  position: absolute;
                  top: 10px;
                  left: 10px;
                  font-size: 20px;
                  color: rgba(168, 85, 247, 0.3);
                ">🌙</div>
                <div style="
                  position: absolute;
                  top: 10px;
                  right: 50px;
                  font-size: 20px;
                  color: rgba(168, 85, 247, 0.3);
                ">⭐</div>
                <div style="
                  position: absolute;
                  bottom: 10px;
                  left: 10px;
                  font-size: 20px;
                  color: rgba(168, 85, 247, 0.3);
                ">🔮</div>
                <div style="
                  position: absolute;
                  bottom: 10px;
                  right: 10px;
                  font-size: 20px;
                  color: rgba(168, 85, 247, 0.3);
                ">✨</div>
              </div>
            </div>
          `);
          
          // 绑定关闭事件
          resultModal.find('.tarot-result-close').on('click', () => {
            resultModal.fadeOut(300, () => resultModal.remove());
          });
          
          // 点击背景关闭
          resultModal.on('click', (e) => {
            if (e.target === resultModal[0]) {
              resultModal.fadeOut(300, () => resultModal.remove());
            }
          });
          
          // 添加到页面并显示
          $('body').append(resultModal);
          
          // 播放神秘音效（如果有的话）
          const tarotSound = document.getElementById('tarot-result-sound');
          if (tarotSound) {
            tarotSound.currentTime = 0;
            tarotSound.play().catch(e => console.log('音效播放失败:', e));
          }
          
          console.log('🎴 占卜结果弹窗已显示');
        }

        showDivinationStartAnimation(spreadType) {
          console.log('🎴 显示占卜开始动画');
          
          // 移除现有的开始动画
          $('.tarot-start-animation').remove();
          
          const spreadNames = {
            'single': '单张牌占卜',
            'timeline': '时间之流占卜',
            'choice': '二选一占卜',
            'hexagram': '六芒星占卜',
            'celtic': '凯尔特十字占卜',
            'zodiac': '黄道十二宫占卜'
          };
          
          const spreadIcons = {
            'single': '🔮',
            'timeline': '⏰',
            'choice': '⚖️',
            'hexagram': '⭐',
            'celtic': '🕯️',
            'zodiac': '🌟'
          };
          
          // 创建神秘的开启动画
          const startAnimation = $(`
            <div class="tarot-start-animation" style="
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: radial-gradient(circle, rgba(0,0,0,0.9) 0%, rgba(26,26,46,0.95) 100%);
              display: flex;
              justify-content: center;
              align-items: center;
              z-index: 9999;
              backdrop-filter: blur(10px);
            ">
              <div class="animation-content" style="
                text-align: center;
                color: #a855f7;
                animation: tarotStartPulse 2s ease-in-out infinite;
              ">
                <div class="mystical-icon" style="
                  font-size: 80px;
                  margin-bottom: 20px;
                  text-shadow: 0 0 30px rgba(168, 85, 247, 0.8);
                  animation: tarotIconFloat 3s ease-in-out infinite;
                ">${spreadIcons[spreadType] || '🔮'}</div>
                
                <h2 style="
                  font-size: 32px;
                  margin: 0 0 15px 0;
                  text-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
                  font-family: 'Times New Roman', serif;
                ">${spreadNames[spreadType] || '神秘占卜'}</h2>
                
                <p style="
                  font-size: 18px;
                  margin: 0 0 30px 0;
                  color: #cbd5e1;
                  font-style: italic;
                ">命运之镜正在揭示你的未来...</p>
                
                <div class="loading-dots" style="
                  display: flex;
                  justify-content: center;
                  gap: 8px;
                ">
                  <div class="dot" style="
                    width: 12px;
                    height: 12px;
                    background: #a855f7;
                    border-radius: 50%;
                    animation: tarotDotPulse 1.5s ease-in-out infinite;
                  "></div>
                  <div class="dot" style="
                    width: 12px;
                    height: 12px;
                    background: #a855f7;
                    border-radius: 50%;
                    animation: tarotDotPulse 1.5s ease-in-out infinite 0.2s;
                  "></div>
                  <div class="dot" style="
                    width: 12px;
                    height: 12px;
                    background: #a855f7;
                    border-radius: 50%;
                    animation: tarotDotPulse 1.5s ease-in-out infinite 0.4s;
                  "></div>
                </div>
                
                <!-- 神秘装饰元素 -->
                <div style="
                  position: absolute;
                  top: 20%;
                  left: 10%;
                  font-size: 24px;
                  color: rgba(168, 85, 247, 0.3);
                  animation: tarotFloat 4s ease-in-out infinite;
                ">🌙</div>
                <div style="
                  position: absolute;
                  top: 30%;
                  right: 15%;
                  font-size: 20px;
                  color: rgba(168, 85, 247, 0.3);
                  animation: tarotFloat 4s ease-in-out infinite 1s;
                ">⭐</div>
                <div style="
                  position: absolute;
                  bottom: 25%;
                  left: 15%;
                  font-size: 22px;
                  color: rgba(168, 85, 247, 0.3);
                  animation: tarotFloat 4s ease-in-out infinite 2s;
                ">✨</div>
                <div style="
                  position: absolute;
                  bottom: 35%;
                  right: 10%;
                  font-size: 26px;
                  color: rgba(168, 85, 247, 0.3);
                  animation: tarotFloat 4s ease-in-out infinite 3s;
                ">🔮</div>
              </div>
            </div>
          `);
          
          // 添加到页面
          $('body').append(startAnimation);
          
          // 播放神秘音效（如果有的话）
          const tarotStartSound = document.getElementById('tarot-start-sound');
          if (tarotStartSound) {
            tarotStartSound.currentTime = 0;
            tarotStartSound.play().catch(e => console.log('音效播放失败:', e));
          }
          
          console.log('🎴 占卜开始动画已显示');
        }

        // 物品相关方法
        canGetTarotItem() {
          const lastItemTime = localStorage.getItem('tarot_last_item_time');
          const itemCount = parseInt(localStorage.getItem('tarot_item_count') || '0');
          
          if (itemCount >= 3) {
            return { canGet: false, reason: '已达到最大物品数量限制' };
          }
          
          if (lastItemTime) {
            const hoursSinceLastItem = (Date.now() - parseInt(lastItemTime)) / (1000 * 60 * 60);
            if (hoursSinceLastItem < 24) {
              return { canGet: false, reason: '物品获取冷却中' };
            }
          }
          
          return { canGet: true };
        }

        getRandomTarotItem() {
          const items = Object.keys(this.tarotItems);
          const rand = Math.random();
          if (rand < 0.15) { // 15%概率获得物品
            return items[Math.floor(Math.random() * items.length)];
          }
          return null;
        }

        async addTarotItem(itemName, itemData) {
          try {
            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable && Mvu.setMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              const currentItems = Mvu.getMvuVariable(mvuData, '训练员.物品栏', { default_value: {} });
              currentItems[itemName] = itemData;
              
              await Mvu.setMvuVariable(mvuData, '训练员.物品栏', currentItems, {
                reason: '塔罗占卜获得物品',
                is_recursive: true,
              });
              await Mvu.replaceMvuData(mvuData, { type: 'chat' });
              console.log('🎴 物品添加成功:', itemName);
            }
          } catch (error) {
            console.error('🎴 添加物品失败:', error);
          }
        }

        recordItemAcquisition() {
          localStorage.setItem('tarot_last_item_time', Date.now().toString());
          localStorage.setItem('tarot_item_count', 
            (parseInt(localStorage.getItem('tarot_item_count') || '0') + 1).toString());
        }

        // 马娘相关方法
        getExistingHorseGirls() {
          const horseGirls = this.getVariable('马娘', {});
          return Object.keys(horseGirls).filter(name => name !== '$meta');
        }

        getRandomExistingHorseGirl() {
          const existingGirls = this.getExistingHorseGirls();
          if (existingGirls.length === 0) return null;
          return existingGirls[Math.floor(Math.random() * existingGirls.length)];
        }

        async affectRandomHorseGirlAffection(affectionChange) {
          const horseGirlName = this.getRandomExistingHorseGirl();
          if (!horseGirlName) return null;
          
          try {
            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable && Mvu.setMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              const currentHorseGirls = Mvu.getMvuVariable(mvuData, '马娘', { default_value: {} });
              const currentAffection = currentHorseGirls[horseGirlName]?.好感度?.[0] || 0;
              const newAffection = Math.max(0, Math.min(100, currentAffection + affectionChange));
              
              // 更新马娘好感度
              if (!currentHorseGirls[horseGirlName]) {
                currentHorseGirls[horseGirlName] = { 好感度: [0] };
              }
              currentHorseGirls[horseGirlName].好感度[0] = newAffection;
              
              await Mvu.setMvuVariable(mvuData, '马娘', currentHorseGirls, {
                reason: '塔罗占卜马娘好感度变化',
                is_recursive: true,
              });
              await Mvu.replaceMvuData(mvuData, { type: 'chat' });
              
              return { 
                name: horseGirlName, 
                oldAffection: currentAffection, 
                newAffection: newAffection,
                change: affectionChange 
              };
            }
          } catch (error) {
            console.error('🎴 更新马娘好感度失败:', error);
          }
          return null;
        }

        // 每日限制相关方法
        getDailyRemaining() {
          try {
            // 使用游戏内天数而不是现实天数
            const gameDay = this.getGameDay();
            const lastUsedDay = localStorage.getItem('tarot_last_used_day');
            const gameDayKey = `tarot_usage_day_${gameDay}`;
            const usageCount = parseInt(localStorage.getItem(gameDayKey) || '0');
            
            // 检测新开局或新的游戏天数
            const lastUsedDayNum = parseInt(lastUsedDay) || -1;
            
            // 如果当前天数小于上次记录的天数，说明是新开局
            if (gameDay < lastUsedDayNum) {
              console.log(`🎴 检测到新开局: 当前天数=${gameDay}, 上次天数=${lastUsedDayNum}`);
              this.resetTarotData();
              return 3;
            }
            
            // 如果是新的游戏天数，重置使用次数
            if (lastUsedDay !== gameDay.toString()) {
              console.log(`🎴 新的游戏天数: 从第${lastUsedDay}天到第${gameDay}天`);
              localStorage.setItem('tarot_last_used_day', gameDay.toString());
              // 清理旧天数的数据
              this.cleanupOldUsageData();
              return 3;
            }
            
            return Math.max(0, 3 - usageCount);
          } catch (error) {
            console.warn('🎴 获取每日剩余次数失败，使用备用方案:', error);
            // 备用方案：使用现实天数
            const today = new Date().toDateString();
            const lastUsage = localStorage.getItem('tarot_last_usage');
            const usageCount = parseInt(localStorage.getItem('tarot_usage_count') || '0');
            
            if (lastUsage !== today) {
              localStorage.setItem('tarot_last_usage', today);
              localStorage.setItem('tarot_usage_count', '0');
              return 3;
            }
            
            return Math.max(0, 3 - usageCount);
          }
        }

        // 清理旧天数的使用数据
        cleanupOldUsageData() {
          try {
            const currentGameDay = this.getGameDay();
            // 清理30天前的数据
            for (let i = 1; i <= 30; i++) {
              const oldDay = currentGameDay - i;
              if (oldDay > 0) {
                localStorage.removeItem(`tarot_usage_day_${oldDay}`);
              }
            }
            console.log('🎴 已清理旧天数的塔罗占卜使用数据');
          } catch (error) {
            console.warn('🎴 清理旧数据失败:', error);
          }
        }

        // 重置所有塔罗牌数据（新开局时使用）
        resetTarotData() {
          try {
            // 清除所有塔罗牌相关的localStorage数据
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('tarot_')) {
                keysToRemove.push(key);
              }
            }
            
            keysToRemove.forEach(key => {
              localStorage.removeItem(key);
              console.log(`🎴 清除塔罗牌数据: ${key}`);
            });
            
            console.log('🎴 已重置所有塔罗牌数据（新开局）');
          } catch (error) {
            console.warn('🎴 重置塔罗牌数据失败:', error);
          }
        }

        recordDailyUsage() {
          // 使用游戏内天数而不是现实天数
          try {
            // 获取游戏内当前天数
            const gameDay = this.getGameDay();
            const gameDayKey = `tarot_usage_day_${gameDay}`;
            const currentCount = parseInt(localStorage.getItem(gameDayKey) || '0');
            localStorage.setItem(gameDayKey, (currentCount + 1).toString());
            
            // 记录最后一次使用的游戏天数
            localStorage.setItem('tarot_last_used_day', gameDay.toString());
            
            console.log(`🎴 塔罗占卜使用记录：游戏第${gameDay}天，使用${currentCount + 1}次`);
          } catch (error) {
            console.warn('🎴 记录塔罗占卜使用失败，使用备用方案:', error);
            // 备用方案：使用现实天数
            const today = new Date().toDateString();
            const currentCount = parseInt(localStorage.getItem('tarot_usage_count') || '0');
            localStorage.setItem('tarot_usage_count', (currentCount + 1).toString());
          }
        }

        // 获取游戏内天数 - 使用和renderUI相同的方法
        getGameDay() {
          try {
            // 使用和updateTarotInfo相同的变量获取方式
            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              const gameDay = Mvu.getMvuVariable(mvuData, '训练员.在校天数[0]', { default_value: 1 });
              const day = parseInt(gameDay) || 1;
              console.log(`🎴 使用MVU获取在校天数: ${gameDay} -> ${day}`);
              return day;
            }
            
            // 备用方案：使用getAllVariables
            const allVars = this.getAllVariables();
            const schoolDays = this.getVariable(allVars, 'stat_data.训练员.在校天数[0]', 1);
            const day = parseInt(schoolDays) || 1;
            console.log(`🎴 使用getAllVariables获取在校天数: ${schoolDays} -> ${day}`);
            return day;
            
            // 备用方案：从localStorage获取
            const savedDay = localStorage.getItem('game_current_day');
            if (savedDay) {
              return parseInt(savedDay) || 1;
            }
            
            // 默认返回第1天
            return 1;
          } catch (error) {
            console.warn('🎴 获取游戏天数失败:', error);
            return 1;
          }
        }

        // 工具方法
        getVariable(path, defaultValue = null) {
          try {
            if (typeof Mvu !== 'undefined' && Mvu.getMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              return Mvu.getMvuVariable(mvuData, path, { default_value: defaultValue });
            }
            return defaultValue;
          } catch (e) {
            console.warn('获取变量失败:', path, e);
            return defaultValue;
          }
        }

        setVariable(path, value) {
          try {
            if (typeof Mvu !== 'undefined' && Mvu.setMvuVariable) {
              const mvuData = Mvu.getMvuData({ type: 'chat' });
              Mvu.setMvuVariable(mvuData, path, value, {
                reason: '塔罗占卜效果',
                is_recursive: true,
              });
              Mvu.replaceMvuData(mvuData, { type: 'chat' });
            }
          } catch (e) {
            console.error('设置变量失败:', path, e);
          }
        }
      }

      // 马娘记名册系统
      class UmaRosterSystem {
        constructor() {
          this.rosterKey = 'uma_roster';
          this.init();
        }

        init() {
          // 初始化记名册数据
          if (!localStorage.getItem(this.rosterKey)) {
            localStorage.setItem(this.rosterKey, JSON.stringify({}));
          }
        }

        // 获取记名册数据
        getUmaRoster() {
          try {
            const rosterData = localStorage.getItem(this.rosterKey);
            return rosterData ? JSON.parse(rosterData) : {};
          } catch (error) {
            console.error('获取马娘记名册失败:', error);
            return {};
          }
        }

        // 添加马娘到记名册
        addUmaToRoster(umaName, details = {}) {
          try {
            const roster = this.getUmaRoster();
            const now = new Date().toISOString();
            
            if (!roster[umaName]) {
              roster[umaName] = {
                name: umaName,
                encounter_count: 1,
                first_met: now,
                last_met: now,
                notes: details.notes || '',
                personality: details.personality || '',
                abilities: details.abilities || ''
              };
            } else {
              roster[umaName].encounter_count += 1;
              roster[umaName].last_met = now;
              if (details.notes) roster[umaName].notes = details.notes;
              if (details.personality) roster[umaName].personality = details.personality;
              if (details.abilities) roster[umaName].abilities = details.abilities;
            }
            
            localStorage.setItem(this.rosterKey, JSON.stringify(roster));
            console.log(`📖 已添加 ${umaName} 到马娘记名册`);
            return true;
          } catch (error) {
            console.error('添加马娘到记名册失败:', error);
            return false;
          }
        }

        // 打开记名册界面
        openUmaRoster() {
          // 播放马娘记名册音效
          const sound = document.getElementById('uma-roster-sound');
          if (sound) {
            sound.currentTime = 0;
            sound.play().catch(e => console.log('播放马娘记名册音效失败:', e));
          }
          
          const roster = this.getUmaRoster();
          const umaList = Object.values(roster);
          
          let rosterHtml = `
            <div class="roster-modal" id="roster-modal">
              <div class="roster-content">
                <div class="roster-header">
                  <h2>📖 马娘记名册</h2>
                  <button class="roster-close-btn" onclick="this.closest('.roster-modal').remove()">×</button>
                </div>
                <div class="roster-body">
          `;
          
          if (umaList.length === 0) {
            rosterHtml += '<div class="empty-roster">还没有遇到任何马娘...</div>';
          } else {
            rosterHtml += '<div class="roster-list">';
            umaList.forEach(uma => {
              const firstMet = new Date(uma.first_met).toLocaleDateString('zh-CN');
              const lastMet = new Date(uma.last_met).toLocaleDateString('zh-CN');
              
              rosterHtml += `
                <div class="roster-item">
                  <div class="roster-item-header">
                    <h3>${uma.name}</h3>
                    <span class="encounter-count">遇到 ${uma.encounter_count} 次</span>
                  </div>
                  <div class="roster-item-details">
                    <div class="roster-detail">
                      <strong>首次遇到:</strong> ${firstMet}
                    </div>
                    <div class="roster-detail">
                      <strong>最后遇到:</strong> ${lastMet}
                    </div>
                    ${uma.personality ? `<div class="roster-detail"><strong>性格:</strong> ${uma.personality}</div>` : ''}
                    ${uma.abilities ? `<div class="roster-detail"><strong>能力:</strong> ${uma.abilities}</div>` : ''}
                    ${uma.notes ? `<div class="roster-detail"><strong>备注:</strong> ${uma.notes}</div>` : ''}
                  </div>
                </div>
              `;
            });
            rosterHtml += '</div>';
          }
          
          rosterHtml += `
                </div>
              </div>
            </div>
          `;
          
          // 移除现有的记名册弹窗
          $('.roster-modal').remove();
          
          // 添加新的记名册弹窗
          $('body').append(rosterHtml);
        }
        
        // 新增：状态触发系统
        checkStatusTriggers() {
          try {
            // 防止重复触发
            if (this.statusAnimationActive) {
              console.log('🎭 状态动画已激活，跳过检查');
              return;
            }
            
            const variables = this.getAllVariables();
            const trainer = variables?.stat_data?.训练员;
            
            if (!trainer) return;
            
            const stamina = trainer.体力?.[0] || 0;
            const sanity = trainer.理智?.[0] || 0;
            
            console.log('🎭 检查状态触发 - 体力:', stamina, '理智:', sanity);
            
            // 检查是否需要触发状态判定
            if (stamina <= 0 || sanity <= 0) {
              console.log('🎭 触发状态动画 - 体力:', stamina, '理智:', sanity);
              this.triggerStatusAnimation(stamina, sanity);
            }
          } catch (error) {
            console.warn('状态触发检查失败:', error);
          }
        }

        // 新增：状态动画演出
        triggerStatusAnimation(stamina, sanity) {
          console.log('🎭 触发状态动画演出');
          
          // 设置状态标志，防止重复触发
          this.statusAnimationActive = true;
          
          // 判断状态类型
          let statusType = 'normal';
          let statusTitle = '状态变化';
          let statusMessage = 'AI将为你判定新的状态...';
          
          if (stamina <= 0 && sanity <= 0) {
            statusType = 'critical';
            statusTitle = '⚠️ 双重崩溃';
            statusMessage = '体力与理智同时崩溃！AI将判定你的命运...';
          } else if (stamina <= 0) {
            statusType = 'stamina';
            statusTitle = '💪 体力崩溃';
            statusMessage = '体力耗尽！这是考验意志的时刻...';
          } else if (sanity <= 0) {
            statusType = 'sanity';
            statusTitle = '🧠 理智崩溃';
            statusMessage = '理智崩溃！疯狂中蕴含着力量...';
          }
          
          // 创建状态动画容器
          const animationContainer = document.createElement('div');
          animationContainer.className = `status-animation-container ${statusType}`;
          animationContainer.innerHTML = `
            <div class="status-animation">
              <div class="status-title">${statusTitle}</div>
              <div class="status-content">
                ${stamina <= 0 ? `<div class="status-item stamina">体力: ${stamina}</div>` : ''}
                ${sanity <= 0 ? `<div class="status-item sanity">理智: ${sanity}</div>` : ''}
              </div>
              <div class="status-message">${statusMessage}</div>
              <div class="status-hint">等待AI的判定...</div>
            </div>
          `;
          
          // 添加到页面
          document.body.appendChild(animationContainer);
          
          // 播放动画
          setTimeout(() => {
            animationContainer.classList.add('show');
          }, 100);
          
          // 5秒后自动移除
          setTimeout(() => {
            animationContainer.classList.remove('show');
            setTimeout(() => {
              if (animationContainer.parentNode) {
                animationContainer.parentNode.removeChild(animationContainer);
              }
              // 重置状态标志
              this.statusAnimationActive = false;
            }, 500);
          }, 5000);
        }

        // 已删除重复的塔罗占卜系统
      }

      // 初始化马娘记名册系统
      $(document).ready(function() {
        // 延迟初始化，确保DOM完全加载
        setTimeout(() => {
          window.umaRosterSystem = new UmaRosterSystem();
          console.log('📖 马娘记名册系统初始化完成');
        }, 100);
      });

      // 初始化塔罗占卜系统
      $(document).ready(function() {
        // 延迟初始化，确保DOM完全加载
        setTimeout(() => {
          window.tarotSystem = new TarotDivinationSystem();
          console.log('🎴 塔罗占卜系统初始化完成');
        }, 100);
      });

    </script>

  </body>

</html>

<!--
================================================================================
  特雷森规则怪谈 - 训练员生存指南 (结束)
  
  作者: Eternal zz
  创意支持，技术支持
  Discord ID: eternalzz0840
  
  感谢使用本项目！
  
  版权声明:
  - 禁止商用
  - 禁止二创  
  - 只能在类脑、旅程二传
================================================================================
-->



